<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turkey Evolution - Thanksgiving Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;700;900&family=Caveat:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --autumn-orange: #D2691E;
            --harvest-gold: #DAA520;
            --pumpkin: #FF7518;
            --cranberry: #9F1D35;
            --turkey-brown: #8B4513;
            --sage-green: #9DC183;
            --cream: #FFFDD0;
            --bark: #3D2914;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Fraunces', serif;
            background: linear-gradient(135deg, #2D1B0E 0%, #4A2C17 50%, #1A0F05 100%);
            min-height: 100vh;
            min-height: 100dvh;
            margin: 0;
            display: block;
            overflow: hidden;
        }

        .game-container {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: linear-gradient(180deg, #87CEEB 0%, #FDB347 30%, #D2691E 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .level-display {
            font-family: 'Caveat', cursive;
            font-size: 28px;
            color: var(--cream);
            text-shadow: 3px 3px 0 var(--bark), -1px -1px 0 var(--bark);
            background: linear-gradient(135deg, var(--cranberry), var(--turkey-brown));
            padding: 8px 20px;
            border-radius: 30px;
            border: 3px solid var(--harvest-gold);
        }

        .score-display {
            font-size: 22px;
            color: var(--harvest-gold);
            text-shadow: 2px 2px 0 var(--bark);
        }

        .xp-bar-container {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            max-width: 80%;
            height: 25px;
            background: var(--bark);
            border-radius: 15px;
            border: 3px solid var(--harvest-gold);
            overflow: hidden;
            box-shadow: inset 0 3px 10px rgba(0,0,0,0.5);
        }

        .leftover-panel {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 210px;
            padding: 12px 14px;
            border-radius: 18px;
            background: rgba(61, 41, 20, 0.8);
            border: 2px solid var(--harvest-gold);
            color: var(--cream);
            font-size: 14px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.35);
            pointer-events: auto;
        }

        .leftover-panel h3 {
            font-family: 'Caveat', cursive;
            font-size: 22px;
            margin: 0 0 6px;
            color: var(--pumpkin);
        }

        .leftover-scraps {
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .leftover-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .leftover-btn {
            font-family: 'Fraunces', serif;
            font-size: 14px;
            padding: 8px 10px;
            border-radius: 14px;
            border: 2px solid var(--harvest-gold);
            background: linear-gradient(135deg, rgba(255,117,24,0.8), rgba(210,105,30,0.8));
            color: var(--cream);
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.15s ease;
        }

        .leftover-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .leftover-status {
            margin-top: 6px;
            font-size: 12px;
            color: var(--harvest-gold);
            min-height: 30px;
        }

        @media (max-width: 600px) {
            .leftover-panel {
                width: calc(100% - 40px);
                left: 50%;
                transform: translateX(-50%);
                bottom: 90px;
            }
            .leftover-actions {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .leftover-btn {
                flex: 1 1 48%;
                font-size: 12px;
                padding: 6px 4px;
            }
        }

        .xp-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--sage-green), var(--pumpkin), var(--cranberry));
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--pumpkin);
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            color: var(--cream);
            text-shadow: 1px 1px 2px var(--bark);
        }

        /* Mobile UI adjustments */
        @media (max-width: 600px) {
            .ui-overlay {
                padding: 8px 12px;
            }
            
            .level-display {
                font-size: 18px;
                padding: 5px 12px;
                border-width: 2px;
            }
            
            .score-display {
                font-size: 18px;
            }
            
            .xp-bar-container {
                height: 20px;
                bottom: 10px;
            }
            
            .xp-text {
                font-size: 11px;
            }
        }

        .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(29, 15, 5, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: safe center;
            z-index: 100;
            overflow-y: auto;
            padding: 20px 10px;
            -webkit-overflow-scrolling: touch;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-family: 'Caveat', cursive;
            font-size: 64px;
            color: var(--pumpkin);
            text-shadow: 4px 4px 0 var(--cranberry), 8px 8px 0 var(--bark);
            margin-bottom: 20px;
            animation: wobble 2s ease-in-out infinite;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }

        .subtitle {
            font-size: 24px;
            color: var(--harvest-gold);
            margin-bottom: 30px;
        }

        .version-badge {
            font-size: 14px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--cream);
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 14px;
            border-radius: 999px;
            margin-bottom: 22px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .instructions {
            color: var(--cream);
            font-size: 18px;
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
            margin-bottom: 30px;
            padding: 0 15px;
        }

        .btn {
            font-family: 'Fraunces', serif;
            font-size: 24px;
            font-weight: 700;
            padding: 15px 50px;
            background: linear-gradient(135deg, var(--pumpkin), var(--autumn-orange));
            color: var(--cream);
            border: 4px solid var(--harvest-gold);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 2px 2px 0 var(--bark);
            box-shadow: 0 6px 0 var(--bark), 0 10px 20px rgba(0,0,0,0.3);
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 var(--bark), 0 15px 30px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 var(--bark), 0 5px 10px rgba(0,0,0,0.3);
        }

        .level-name {
            font-family: 'Caveat', cursive;
            font-size: 48px;
            color: var(--sage-green);
            text-shadow: 3px 3px 0 var(--bark);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .boss-name {
            color: var(--cranberry);
            font-size: 56px;
        }

        .turkey-emoji {
            font-size: 80px;
            animation: bounce 0.5s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--harvest-gold);
            font-size: 14px;
            opacity: 0.8;
        }

        /* Touch indicator for mobile */
        .touch-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid var(--harvest-gold);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 50;
            background: radial-gradient(circle, rgba(218,165,32,0.3) 0%, transparent 70%);
        }

        .touch-indicator.visible {
            opacity: 1;
        }

        .touch-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: var(--harvest-gold);
            border-radius: 50%;
        }

        /* Mobile screen adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 36px;
                text-shadow: 2px 2px 0 var(--cranberry), 4px 4px 0 var(--bark);
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .version-badge {
                font-size: 12px;
                margin-bottom: 16px;
            }

            .instructions {
                font-size: 14px;
                line-height: 1.5;
                margin-bottom: 20px;
                max-width: 90%;
            }

            .btn {
                font-size: 18px;
                padding: 12px 35px;
                border-width: 3px;
            }

            .level-name {
                font-size: 32px;
            }

            .boss-name {
                font-size: 36px;
            }

            .turkey-emoji {
                font-size: 50px;
            }

            .touch-indicator {
                width: 60px;
                height: 60px;
                border-width: 3px;
            }

            .touch-indicator::after {
                width: 14px;
                height: 14px;
            }
        }

        @media (max-height: 500px) {
            h1 {
                font-size: 28px;
                margin-bottom: 8px;
            }

            .subtitle {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .instructions {
                font-size: 12px;
                margin-bottom: 12px;
            }

            .turkey-emoji {
                font-size: 40px;
            }

            .btn {
                font-size: 16px;
                padding: 10px 30px;
            }
        }

        /* Extra small height screens (small phones in landscape or very compact screens) */
        @media (max-height: 400px) {
            .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
                justify-content: flex-start;
                padding-top: 10px;
            }

            h1 {
                font-size: 24px;
                margin-bottom: 5px;
            }

            .subtitle {
                font-size: 12px;
                margin-bottom: 8px;
            }

            .instructions {
                font-size: 11px;
                margin-bottom: 10px;
                line-height: 1.3;
            }

            .turkey-emoji {
                font-size: 30px;
            }

            .btn {
                font-size: 14px;
                padding: 8px 25px;
                margin-bottom: 10px;
            }
        }

        /* Ensure button is always tappable and visible */
        .btn {
            min-height: 44px;
            min-width: 120px;
            flex-shrink: 0;
        }

        /* Show/hide controls based on device */
        .mobile-controls {
            display: none;
        }

        .desktop-controls {
            display: inline;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: inline;
            }

            .desktop-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
        
        <!-- Touch indicator for mobile -->
        <div class="touch-indicator" id="touchIndicator"></div>
        
        <div class="ui-overlay">
            <div class="level-display" id="levelDisplay">Level 1: Barn Turkey Barn</div>
            <div class="score-display"><span id="scoreIcon" aria-hidden="true">üçé</span> <span id="scoreDisplay">0</span></div>
        </div>
        
        <div class="xp-bar-container">
            <div class="xp-bar" id="xpBar" style="width: 0%"></div>
            <div class="xp-text" id="xpText">0 / 10 XP</div>
        </div>

        <section class="leftover-panel" aria-live="polite">
            <h3>Leftovers Lab</h3>
            <div class="leftover-scraps"><span id="leftoverScraps">0</span> scraps</div>
            <div class="leftover-actions">
                <button class="leftover-btn" id="craftCranberryBtn">‚ö° Speed Boost</button>
            </div>
            <div class="leftover-status" id="leftoverStatus">Collect treats to charge your Speed Boost!</div>
        </section>

        <div class="start-screen" id="startScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Turkey Evolution</h1>
            <p class="subtitle">A Thanksgiving Adventure</p>
            <div class="version-badge" id="versionBadge" aria-live="polite"></div>
            <div class="instructions">
                Gobble treats, dodge kitchen chaos, and evolve before dinner.<br><br>
                <span class="desktop-controls"><strong>Arrow Keys</strong> / <strong>WASD</strong> or <strong>click & drag</strong> to move<br><strong>SPACE</strong> or double-click for your ability (üõ°Ô∏è bosses, ‚ö° levels)</span>
                <span class="mobile-controls"><strong>Touch & hold</strong> to move<br><strong>Double-tap</strong> to trigger your ability</span>
            </div>
            <button class="btn" onclick="startGame()">Start Gobbling!</button>
            <a href="vr.html" style="display: block; margin-top: 20px; color: #DAA520; font-size: 16px; text-decoration: none; opacity: 0.9;">ü•Ω Try VR Version</a>
        </div>

        <div class="level-up-screen hidden" id="levelUpScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Level Up!</h1>
            <p class="level-name" id="newLevelName">Turkey Run</p>
            <p class="instructions" id="levelDescription">You've escaped the barn! Now run through the fields!</p>
            <p class="instructions" id="levelCountdown" aria-live="polite" style="display: none;">Press SPACE or wait 10s for the next level.</p>
            <button class="btn" onclick="continueGame()">Continue</button>
        </div>

        <div class="boss-screen hidden" id="bossScreen">
            <div style="font-size: 80px;" id="bossEmoji">ü•ß</div>
            <h1>Boss Fight!</h1>
            <p class="boss-name" id="bossName">Pumpkin Pie</p>
            <p class="instructions" id="bossInstructions">The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck automatically when you get close enough<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!</p>
            <button class="btn" onclick="startBossFight()">Fight!</button>
        </div>

        <div class="game-over-screen hidden" id="gameOverScreen">
            <div style="font-size: 80px;">üíÄ</div>
            <h1>Game Over!</h1>
            <p class="subtitle" id="deathMessage">The turkey has been caught!</p>
            <p class="instructions">Final Score: <span id="finalScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Try Again</button>
        </div>

        <div class="win-screen hidden" id="winScreen">
            <div style="font-size: 80px;">üèÜ</div>
            <h1>Victory!</h1>
            <p class="level-name">The Turkey Survives Thanksgiving!</p>
            <p class="instructions">You've evolved from a barn turkey to a legendary survivor!<br><br>Final Score: <span id="winScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const touchIndicator = document.getElementById('touchIndicator');
        const gameContainer = document.querySelector('.game-container');
        const bossEmojiEl = document.getElementById('bossEmoji');
        const bossNameEl = document.getElementById('bossName');
        const bossInstructionsEl = document.getElementById('bossInstructions');
        const scoreIconEl = document.getElementById('scoreIcon');
        const levelCountdownEl = document.getElementById('levelCountdown');
        const versionBadgeEl = document.getElementById('versionBadge');
        const leftoverScrapsEl = document.getElementById('leftoverScraps');
        const leftoverStatusEl = document.getElementById('leftoverStatus');
        const craftCranberryBtn = document.getElementById('craftCranberryBtn');

        const VERSION = Object.freeze({
            major: 1,
            minor: 1,
            patch: 0,
            codename: 'Harvest Escape',
            toString() {
                return `${this.major}.${this.minor}.${this.patch}`;
            }
        });

        function formatVersionLabel() {
            const base = `v${VERSION.toString()}`;
            return VERSION.codename ? `${base} ¬∑ ${VERSION.codename}` : base;
        }

        if (versionBadgeEl) {
            versionBadgeEl.textContent = formatVersionLabel();
            versionBadgeEl.setAttribute('aria-label', `Game version ${VERSION.toString()}`);
        }

        window.TURKEY_EVOLUTION_VERSION = VERSION;

        // Base canvas dimensions (used for game logic)
        let BASE_WIDTH = window.innerWidth || 600;
        let BASE_HEIGHT = window.innerHeight || 800;
        const FLOOR_PADDING = 30;
        const BOMBER_GROUND_BAND_HEIGHT = 140;
        const TEN_SECOND_FRAMES = 10 * 60;
        const HUNTER_RELOAD_FRAMES = TEN_SECOND_FRAMES;
        const BOMBER_RELOAD_FRAMES = TEN_SECOND_FRAMES;
        const PUMPKIN_ATTACK_INTERVAL_FRAMES = 120; // ~2 seconds between pie throws
        const PUMPKIN_SLICE_COUNT = 8;

        const BOSS_TYPES = {
            PUMPKIN: 'pumpkinPie',
            AURORA: 'auroraSpirit'
        };
        const CORN_MAZE_SPEED_MODIFIER = 0.65;
        const AURORA_ATTACK_WINDOW_FRAMES = 360;
        const AURORA_RECHARGE_FRAMES = 10 * 60;

        // Game State
        let gameState = 'start'; // start, playing, levelup, boss, gameover, win
        let currentLevel = 1;
        let score = 0;
        let xp = 0;
        let xpNeeded = 10;
        let nextBossType = null;
        let levelCountdownInterval = null;
        let levelCountdownRemaining = 0;

        // Pointer/touch state
        let touchActive = false;
        let touchTarget = null;
        let pointerIndicatorVisible = false;
        let canvasScale = 1;

        // Peck attack state
        let peckCooldown = 0;
        const PECK_COOLDOWN_MAX = 30; // frames between pecks
        const PECK_RANGE = 100; // distance to peck the boss
        const PECK_DAMAGE = 1;
        let isPecking = false;
        let peckAnimTimer = 0;

        // Level definitions
        const levels = {
            1: { name: 'Barn Turkey Barn', xpNeeded: 10, bgColor: '#8B4513', description: 'Eat apples in the cozy barn!' },
            2: { name: 'Turkey Run', xpNeeded: 15, bgColor: '#228B22', description: 'Run through the autumn fields!' },
            3: { name: 'Hunter Hunt Down', xpNeeded: 20, bgColor: '#2F4F4F', description: 'Hide behind barriers to survive! The hunter is waking up...' },
            4: { name: 'Stealth Bomber Siege', xpNeeded: 3, bgColor: '#0f1a2b', description: 'B-2 bomber overhead! Survive 3 bombing runs.' },
            5: { name: 'Northern Lights Siege', xpNeeded: 1, bgColor: '#082137', description: 'Aurora beast attacks! Pineapples fuel your survival.' },
            6: { name: 'Corn Maze Migration', xpNeeded: 14, bgColor: '#6b3e12', description: 'Navigate a shifting corn maze and harvest cobs for guidance!' },
            7: { name: 'Parade Float Builder', xpNeeded: 6, bgColor: '#320b28', description: 'Collect float parts and assemble the victory parade!' }
        };
        const MAX_LEVEL = Object.keys(levels).length;

        const LEFTOVER_CONFIG = Object.freeze({
            scrapsPerFruit: 1,
            cranberry: {
                cost: 4,
                duration: 6 * 60,
                cooldown: 8 * 60,
                speedBoost: 1.6
            }
        });

        const TURKEY_SIZE_PRESETS = Object.freeze({
            default: { width: 60, height: 50 },
            maze: { width: 48, height: 42 }
        });

        // Turkey
        const turkey = {
            x: BASE_WIDTH / 2,
            y: BASE_HEIGHT / 2,
            width: TURKEY_SIZE_PRESETS.default.width,
            height: TURKEY_SIZE_PRESETS.default.height,
            speed: 5,
            mouthOpen: 0,
            direction: 1,
            evolution: 1,
            legPhase: 0,
            legSwingAmount: 0
        };

        function applyTurkeySizeForLevel(levelOverride = currentLevel) {
            const preset = levelOverride === 6 ? TURKEY_SIZE_PRESETS.maze : TURKEY_SIZE_PRESETS.default;
            turkey.width = preset.width;
            turkey.height = preset.height;
        }

        function getTurkeyVerticalBounds() {
            const minY = turkey.height / 2;
            const maxY = BASE_HEIGHT - turkey.height / 2 - FLOOR_PADDING;
            if (currentLevel === 4 && gameState === 'playing') {
                const groundTop = Math.max(minY, BASE_HEIGHT - BOMBER_GROUND_BAND_HEIGHT);
                return { minY: groundTop, maxY };
            }
            return { minY, maxY };
        }

        function clampTurkeyToBounds() {
            const horizontalMin = turkey.width / 2;
            const horizontalMax = BASE_WIDTH - turkey.width / 2;
            turkey.x = Math.max(horizontalMin, Math.min(horizontalMax, turkey.x));
            const { minY, maxY } = getTurkeyVerticalBounds();
            turkey.y = Math.max(minY, Math.min(maxY, turkey.y));
        }

        function placeTurkeyOnGroundBand() {
            const { minY, maxY } = getTurkeyVerticalBounds();
            turkey.y = (minY + maxY) / 2;
        }

        // Apples
        let apples = [];

        // Boss
        let boss = null;
        let bossProjectiles = [];

        function isAuroraBossVulnerable() {
            return (
                boss &&
                boss.type === BOSS_TYPES.AURORA &&
                boss.isRecharging &&
                boss.graceTimer <= 0
            );
        }

        // Hunter (Level 3)
        let hunter = null;

        // Bomber (Level 4)
        let bomber = null;
        let bomberBombs = [];
        let bomberRoundsSurvived = 0;

        // Northern lights effects
        let auroraWaves = [];
        let auroraBlasts = [];
        let roamingAuroras = [];

        // Barriers for hiding
        let barriers = [];

        // Particles
        let particles = [];
        let paradeFloat = null;
        let paradeConfetti = [];

        const leftoverBuffs = {
            scraps: 0,
            cranberry: { activeTimer: 0, cooldownTimer: 0 }
        };
        function isBossFightActive() {
            return gameState === 'boss';
        }
        function isAbilityEnabled(buffKey) {
            return buffKey === 'cranberry';
        }
        let leftoverUIFrame = 0;

        // Input
        const keys = {};

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;

            if (e.code === 'Space') {
                if (gameState === 'levelup') {
                    e.preventDefault();
                    continueGame();
                    return;
                }

                if (gameState === 'boss' || gameState === 'playing') {
                    e.preventDefault();
                    activateContextAbility();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });
        
        if (craftCranberryBtn) {
            craftCranberryBtn.addEventListener('click', () => craftCranberryDash());
        }
        
        // Peck attack function
        function tryPeckAttack() {
            if (peckCooldown > 0) return;
            if (gameState !== 'boss' || !boss) return;
            if (boss.type === BOSS_TYPES.AURORA && !isAuroraBossVulnerable()) return;
            
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            
            if (distToBoss < PECK_RANGE + bossRadius) {
                // Successful peck!
                isPecking = true;
                peckAnimTimer = 15;
                peckCooldown = PECK_COOLDOWN_MAX;
                
                // Damage boss
                const damage = boss.type === BOSS_TYPES.AURORA ? PECK_DAMAGE + 1 : PECK_DAMAGE;
                boss.health -= damage;
                
                // Visual feedback
                const hitColor = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FF7518';
                spawnParticles(boss.x, boss.y, hitColor, 12);
                spawnParticles(turkey.x + turkey.direction * 30, turkey.y - 10, '#FFD700', 8);
                
                // Knockback effect on boss
                if (boss.type !== BOSS_TYPES.AURORA) {
                    boss.x += (boss.x - turkey.x) * 0.1;
                }
                
                if (boss.health <= 0) {
                    const primaryBurst = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FFD700';
                    const secondaryBurst = boss.type === BOSS_TYPES.AURORA ? '#a855ff' : '#FF7518';
                    spawnParticles(boss.x, boss.y, primaryBurst, 30);
                    spawnParticles(boss.x, boss.y, secondaryBurst, 20);
                    if (boss.type !== BOSS_TYPES.AURORA) {
                        spawnParticles(boss.x, boss.y, '#FFFAF0', 15);
                    }
                    boss = null;
                    levelUp();
                }
                
                updateUI();
            } else {
                // Out of range - still show peck animation but no damage
                isPecking = true;
                peckAnimTimer = 10;
                peckCooldown = PECK_COOLDOWN_MAX / 2; // Shorter cooldown for missed peck
                spawnParticles(turkey.x + turkey.direction * 40, turkey.y - 5, '#FFA500', 3);
            }
        }

        // Pointer/touch helpers
        function getPointerPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (clientX - rect.left) / canvasScale,
                y: (clientY - rect.top) / canvasScale
            };
        }

        function updateTouchIndicator(clientX, clientY) {
            const rect = gameContainer.getBoundingClientRect();
            const indicatorSize = touchIndicator.offsetWidth || 80;
            const offset = indicatorSize / 2;
            touchIndicator.style.left = (clientX - rect.left - offset) + 'px';
            touchIndicator.style.top = (clientY - rect.top - offset) + 'px';
        }

        function startPointerControl(clientX, clientY, showIndicator = false) {
            touchActive = true;
            touchTarget = getPointerPos(clientX, clientY);
            pointerIndicatorVisible = showIndicator;
            if (showIndicator) {
                touchIndicator.classList.add('visible');
                updateTouchIndicator(clientX, clientY);
            }
        }

        function movePointerControl(clientX, clientY, showIndicator = false) {
            if (!touchActive) return;
            touchTarget = getPointerPos(clientX, clientY);
            if (showIndicator || pointerIndicatorVisible) {
                pointerIndicatorVisible = true;
                touchIndicator.classList.add('visible');
                updateTouchIndicator(clientX, clientY);
            }
        }

        function endPointerControl() {
            touchActive = false;
            touchTarget = null;
            if (pointerIndicatorVisible) {
                pointerIndicatorVisible = false;
                touchIndicator.classList.remove('visible');
            }
        }

        // Double-press detection for ability activation
        let lastTapTime = 0;
        const DOUBLE_TAP_DELAY = 300; // ms

        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (gameState !== 'playing' && gameState !== 'boss') return;
            activateContextAbility();
        });

        // Touch events for guiding movement
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'playing' && gameState !== 'boss') return;
            
            const touch = e.touches[0];
            const currentTime = Date.now();
            
            // Check for double-tap
            if (currentTime - lastTapTime < DOUBLE_TAP_DELAY) {
                activateContextAbility();
                lastTapTime = 0; // Reset to prevent triple-tap triggering
            } else {
                lastTapTime = currentTime;
            }
            
            startPointerControl(touch.clientX, touch.clientY, true);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive) return;
            
            const touch = e.touches[0];
            movePointerControl(touch.clientX, touch.clientY, true);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                movePointerControl(touch.clientX, touch.clientY, true);
                return;
            }
            endPointerControl();
        }, { passive: false });

        canvas.addEventListener('touchcancel', () => {
            endPointerControl();
        });

        const mouseMoveHandler = (event) => {
            movePointerControl(event.clientX, event.clientY);
        };

        const mouseUpHandler = () => {
            endPointerControl();
            window.removeEventListener('mousemove', mouseMoveHandler);
            window.removeEventListener('mouseup', mouseUpHandler);
        };

        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (gameState !== 'playing' && gameState !== 'boss') return;
            e.preventDefault();
            startPointerControl(e.clientX, e.clientY);
            window.addEventListener('mousemove', mouseMoveHandler);
            window.addEventListener('mouseup', mouseUpHandler);
        });

        // Handle window resize for responsive canvas
        function resizeCanvas() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            gameContainer.style.width = viewportWidth + 'px';
            gameContainer.style.height = viewportHeight + 'px';
            
            BASE_WIDTH = viewportWidth;
            BASE_HEIGHT = viewportHeight;
            canvas.width = viewportWidth;
            canvas.height = viewportHeight;
            canvas.style.width = viewportWidth + 'px';
            canvas.style.height = viewportHeight + 'px';
            canvasScale = 1;

            // Ensure turkey stays in bounds after resize
            clampTurkeyToBounds();
            if (hunter) {
                hunter.patrolBounds = getHunterPatrolBounds();
            }

            if (currentLevel === 5 || (boss && boss.type === BOSS_TYPES.AURORA) || nextBossType === BOSS_TYPES.AURORA) {
                ensureAuroraAmbience(true);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function configureBossScreen(type) {
            if (type === BOSS_TYPES.AURORA) {
                bossEmojiEl.textContent = 'üåå';
                bossNameEl.textContent = 'Northern Light Monster';
                bossInstructionsEl.innerHTML = 'The Aurora Beast awakens!<br>üåå Dodge aurora volleys when it attacks<br>üå≤ Hide behind the glowing trees<br>üçç Pineapples fuel scraps but can\'t hurt it<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>üí• It unleashes a mega blast after recharging ‚Äî stay mobile!';
            } else {
                bossEmojiEl.textContent = 'ü•ß';
                bossNameEl.textContent = 'Pumpkin Pie';
                bossInstructionsEl.innerHTML = 'The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck automatically when you get close enough<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!';
            }
        }

        function queueBossFight(type) {
            nextBossType = type;
            configureBossScreen(type);
            if (type === BOSS_TYPES.AURORA) {
                ensureAuroraAmbience();
            }
            document.getElementById('bossScreen').classList.remove('hidden');
            gameState = 'boss'; // boss intro state
        }

        function clearLevelCountdown() {
            if (levelCountdownInterval !== null) {
                clearInterval(levelCountdownInterval);
                levelCountdownInterval = null;
            }
            levelCountdownRemaining = 0;
            if (levelCountdownEl) {
                levelCountdownEl.style.display = 'none';
            }
        }

        function startLevelCountdown() {
            if (!levelCountdownEl) return;
            clearLevelCountdown();
            levelCountdownRemaining = 10;
            levelCountdownEl.style.display = 'block';
            levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
            levelCountdownInterval = setInterval(() => {
                if (gameState !== 'levelup') {
                    clearLevelCountdown();
                    return;
                }
                levelCountdownRemaining--;
                if (levelCountdownRemaining <= 0) {
                    clearInterval(levelCountdownInterval);
                    levelCountdownInterval = null;
                    levelCountdownEl.textContent = 'Starting next level...';
                    if (gameState === 'levelup') {
                        continueGame();
                    }
                } else {
                    levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
                }
            }, 1000);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            resetLeftovers();
            gameState = 'playing';
            resetLevel();
            gameLoop();
        }

        function continueGame() {
            if (gameState !== 'levelup') return;
            clearLevelCountdown();
            document.getElementById('levelUpScreen').classList.add('hidden');
            gameState = 'playing';
            resetLevel();
        }

        function startBossFight() {
            document.getElementById('bossScreen').classList.add('hidden');
            initBoss(nextBossType || BOSS_TYPES.PUMPKIN);
            nextBossType = null;
            gameState = 'boss';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            clearLevelCountdown();
            currentLevel = 1;
            score = 0;
            xp = 0;
            turkey.evolution = 1;
            turkey.x = 300;
            turkey.y = 400;
            gameState = 'playing';
            resetLeftovers();
            resetLevel();
        }

        function resetLevel() {
            apples = [];
            particles = [];
            paradeConfetti = [];
            bossProjectiles = [];
            bomberBombs = [];
            auroraWaves = [];
            auroraBlasts = [];
            roamingAuroras = [];
            boss = null;
            hunter = null;
            bomber = null;
            barriers = [];
            paradeFloat = null;
            xp = 0;
            bomberRoundsSurvived = 0;
            xpNeeded = (levels[currentLevel] && levels[currentLevel].xpNeeded) || 10;
            turkey.x = 300;
            turkey.y = 400;
            applyTurkeySizeForLevel();
            
            const shouldSpawnCollectibles = currentLevel !== 5;
            let initialCollectibles = 5;
            if (currentLevel === 4) {
                initialCollectibles = 6;
            } else if (currentLevel === 6) {
                initialCollectibles = 8;
            } else if (currentLevel === 7) {
                initialCollectibles = 4;
            }
            if (shouldSpawnCollectibles) {
                for (let i = 0; i < initialCollectibles; i++) {
                    spawnApple();
                }
            }

            if (currentLevel === 3) {
                initHunterEncounter();
            } else if (currentLevel === 4) {
                spawnBarriersForLevel(4);
                initBomberLevel();
                placeTurkeyOnGroundBand();
            } else if (currentLevel === 5) {
                spawnBarriersForLevel(5);
                queueBossFight(BOSS_TYPES.AURORA);
                ensureAuroraAmbience(true);
            } else if (currentLevel === 6) {
                spawnCornMazeLevel();
                turkey.x = BASE_WIDTH / 2;
                turkey.y = BASE_HEIGHT - 120;
            } else if (currentLevel === 7) {
                spawnParadeWorkshop();
                initParadeFloatBuilder();
            }

            updateUI();
        }
        
        function initHunterEncounter() {
            hunter = {
                x: BASE_WIDTH / 2,
                y: BASE_HEIGHT / 2,
                width: 50,
                height: 70,
                speed: 0,
                shootTimer: 0,
                graceTimer: 180,
                shotsFired: 0,
                reloadTimer: 0,
                isReloading: false,
                walkSpeed: 0.8,
                patrolDirection: 1,
                wanderAxis: 'x',
                patrolBounds: getHunterPatrolBounds()
            };
            
            spawnBarriersForLevel(3);
            
            const corners = [
                { x: 80, y: 100 },
                { x: BASE_WIDTH - 80, y: 100 },
                { x: 80, y: BASE_HEIGHT - 150 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 150 }
            ];
            const randomCorner = corners[Math.floor(Math.random() * corners.length)];
            turkey.x = randomCorner.x;
            turkey.y = randomCorner.y;
        }

        function getHunterPatrolBounds() {
            const marginX = Math.max(80, BASE_WIDTH * 0.15);
            const minX = marginX;
            const maxX = Math.max(minX + 40, BASE_WIDTH - marginX);
            const bandY = Math.max(100, BASE_HEIGHT * 0.15);
            const minY = Math.max(120, BASE_HEIGHT / 2 - bandY);
            const maxY = Math.max(minY + 40, Math.min(BASE_HEIGHT - 160, BASE_HEIGHT / 2 + bandY));
            return { minX, maxX, minY, maxY };
        }

        function beginHunterReload() {
            if (!hunter) return;
            hunter.isReloading = true;
            hunter.reloadTimer = 0;
            hunter.patrolBounds = getHunterPatrolBounds();
            hunter.wanderAxis = Math.random() > 0.5 ? 'x' : 'y';
            hunter.patrolDirection = Math.random() > 0.5 ? 1 : -1;
        }

        function updateHunterPatrol() {
            if (!hunter || !hunter.isReloading) return;
            const bounds = hunter.patrolBounds || getHunterPatrolBounds();
            const axis = hunter.wanderAxis || 'x';
            const speed = hunter.walkSpeed || 0.8;
            if (axis === 'x') {
                hunter.x += speed * hunter.patrolDirection;
                if (hunter.x < bounds.minX || hunter.x > bounds.maxX) {
                    hunter.patrolDirection *= -1;
                    hunter.x = Math.max(bounds.minX, Math.min(bounds.maxX, hunter.x));
                }
            } else {
                hunter.y += speed * hunter.patrolDirection;
                if (hunter.y < bounds.minY || hunter.y > bounds.maxY) {
                    hunter.patrolDirection *= -1;
                    hunter.y = Math.max(bounds.minY, Math.min(bounds.maxY, hunter.y));
                }
            }
        }

        function spawnBarriersForLevel(level) {
            barriers = [];
            if (level === 3) {
                const hayColumns = [0.18, 0.5, 0.82];
                const hayRows = [0.32, 0.68];
                hayRows.forEach(rowRatio => {
                    hayColumns.forEach(colRatio => {
                        barriers.push({
                            x: BASE_WIDTH * colRatio,
                            y: BASE_HEIGHT * rowRatio,
                            width: 70,
                            height: 45,
                            type: 'haybale'
                        });
                    });
                });

                const rockPositions = [
                    { x: BASE_WIDTH * 0.25, y: BASE_HEIGHT * 0.48 },
                    { x: BASE_WIDTH * 0.75, y: BASE_HEIGHT * 0.48 },
                    { x: BASE_WIDTH * 0.22, y: BASE_HEIGHT * 0.82 },
                    { x: BASE_WIDTH * 0.78, y: BASE_HEIGHT * 0.82 }
                ];
                rockPositions.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: 70,
                        height: 50,
                        type: 'rock'
                    });
                });

            } else if (level === 4) {
                const coverBandTop = BASE_HEIGHT - BOMBER_GROUND_BAND_HEIGHT + 20;
                const hayRowY = coverBandTop + 30;
                const hayColumns = [0.18, 0.38, 0.58, 0.78];
                hayColumns.forEach((ratio, index) => {
                    barriers.push({
                        x: BASE_WIDTH * ratio,
                        y: hayRowY + (index % 2) * 25,
                        width: 70,
                        height: 45,
                        type: 'haybale'
                    });
                });

                const rockRowY = coverBandTop + 80;
                const rockColumns = [0.3, 0.5, 0.7];
                rockColumns.forEach(ratio => {
                    barriers.push({
                        x: BASE_WIDTH * ratio,
                        y: rockRowY,
                        width: 80,
                        height: 55,
                        type: 'rock'
                    });
                });

            } else if (level === 5) {
                // glowing pine obstacles
                const crystalRings = [
                    { x: BASE_WIDTH / 2 - 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 + 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 - 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 + 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 - 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' },
                    { x: BASE_WIDTH / 2 + 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' }
                ];
                crystalRings.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.type === 'iceWall' ? 70 : 50,
                        height: pos.type === 'iceWall' ? 120 : 100,
                        type: pos.type
                    });
                });
            }
        }

        function spawnCornMazeLevel() {
            barriers = [];
            const margin = 60;
            const gapWidth = 120;
            const rowConfigs = [
                { y: 140, gapCenter: BASE_WIDTH / 2 },
                { y: 240, gapCenter: BASE_WIDTH / 2 - 140 },
                { y: 340, gapCenter: BASE_WIDTH / 2 + 140 },
                { y: 440, gapCenter: BASE_WIDTH / 2 - 80 },
                { y: 540, gapCenter: BASE_WIDTH / 2 + 60 }
            ];

            rowConfigs.forEach((row, index) => {
                const leftWidth = row.gapCenter - gapWidth / 2 - margin;
                if (leftWidth > 0) {
                    barriers.push({
                        x: margin + leftWidth / 2,
                        y: row.y,
                        width: leftWidth,
                        height: 26,
                        type: 'cornWall',
                        solid: true,
                        waveOffset: index * 0.4
                    });
                }

                const rightWidth = BASE_WIDTH - margin - (row.gapCenter + gapWidth / 2);
                if (rightWidth > 0) {
                    barriers.push({
                        x: BASE_WIDTH - margin - rightWidth / 2,
                        y: row.y,
                        width: rightWidth,
                        height: 26,
                        type: 'cornWall',
                        solid: true,
                        waveOffset: index * 0.5 + 0.3
                    });
                }
            });

            const verticalColumns = [
                { x: margin + 30, top: 200, height: 360 },
                { x: BASE_WIDTH - margin - 30, top: 220, height: 340 },
                { x: BASE_WIDTH / 2 - 120, top: 180, height: 420 },
                { x: BASE_WIDTH / 2 + 120, top: 260, height: 360 }
            ];

            verticalColumns.forEach((col, index) => {
                barriers.push({
                    x: col.x,
                    y: col.top + col.height / 2,
                    width: 28,
                    height: col.height,
                    type: 'cornWall',
                    solid: true,
                    waveOffset: index * 0.7
                });
            });

            // add a couple of diagonal blockers to keep the player weaving
            barriers.push(
                { x: BASE_WIDTH / 2 - 170, y: 300, width: 90, height: 26, type: 'cornWall', solid: true, waveOffset: 2.3 },
                { x: BASE_WIDTH / 2 + 170, y: 420, width: 90, height: 26, type: 'cornWall', solid: true, waveOffset: 2.6 }
            );
        }

        function initParadeFloatBuilder() {
            paradeFloat = {
                partsBuilt: 0,
                partsRequired: levels[7].xpNeeded,
                stage: 0,
                stageLabels: ['Chassis', 'Balloon Rigging', 'Light Show', 'Music Stack', 'Final Touches'],
                status: 'Collect float parts scattered across the runway!'
            };
            paradeConfetti = [];
        }

        function incrementParadeFloat() {
            if (!paradeFloat) return;
            paradeFloat.partsBuilt++;
            paradeFloat.stage = Math.min(paradeFloat.stageLabels.length - 1, paradeFloat.partsBuilt - 1);
            const remaining = Math.max(0, paradeFloat.partsRequired - paradeFloat.partsBuilt);
            paradeFloat.status = remaining > 0
                ? `${paradeFloat.stageLabels[paradeFloat.stage]} complete! ${remaining} parts left.`
                : 'Float ready! Return to center!';
            spawnConfettiBurst(turkey.x, turkey.y);
        }

        function spawnConfettiBurst(x, y) {
            for (let i = 0; i < 25; i++) {
                paradeConfetti.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 2,
                    life: 1,
                    color: ['#ff69b4', '#ffd700', '#7fffd4', '#ff7f50'][i % 4]
                });
            }
        }

        function updateParadeConfetti() {
            for (let i = paradeConfetti.length - 1; i >= 0; i--) {
                const confetti = paradeConfetti[i];
                confetti.x += confetti.vx;
                confetti.y += confetti.vy;
                confetti.vy += 0.12;
                confetti.life -= 0.02;
                if (confetti.life <= 0 || confetti.y > BASE_HEIGHT) {
                    paradeConfetti.splice(i, 1);
                }
            }
        }

        function spawnParadeWorkshop() {
            barriers = [];
            const stage = {
                x: BASE_WIDTH / 2,
                y: BASE_HEIGHT - 140,
                width: 260,
                height: 60,
                type: 'floatStage',
                solid: false
            };
            barriers.push(stage);

            const balloonStacks = [
                { x: BASE_WIDTH / 2 - 200, y: BASE_HEIGHT - 200 },
                { x: BASE_WIDTH / 2 + 200, y: BASE_HEIGHT - 200 }
            ];

            balloonStacks.forEach(stack => {
                barriers.push({
                    x: stack.x,
                    y: stack.y,
                    width: 60,
                    height: 140,
                    type: 'balloonStack',
                    solid: false
                });
            });

            const railings = [
                { x: BASE_WIDTH / 2, y: BASE_HEIGHT - 220 },
                { x: BASE_WIDTH / 2, y: BASE_HEIGHT - 260 }
            ];

            railings.forEach((rail, index) => {
                barriers.push({
                    x: rail.x,
                    y: rail.y,
                    width: BASE_WIDTH - 120,
                    height: 14,
                    type: 'workshopRail',
                    solid: false,
                    waveOffset: index * 0.3
                });
            });
        }

        function initBomberLevel() {
            bomber = {
                x: BASE_WIDTH / 2,
                y: 230, // Slightly lower so it clears the UI overlay
                width: 160,
                height: 50,
                direction: 1,
                speed: 1.5,
                stealthPulse: 0,
                graceTimer: 180,
                isReloading: false,
                reloadTimer: 0,
                reloadFrames: BOMBER_RELOAD_FRAMES, // 10 seconds at ~60fps
                activeBomb: null,
                roundsToSurvive: 3
            };
        }

        function dropBomberBomb() {
            if (!bomber) return;
            const targetX = turkey.x + (Math.random() - 0.5) * 120;
            const bomb = {
                x: bomber.x,
                y: bomber.y + 30,
                vx: (targetX - bomber.x) / 120,
                vy: 1.5,
                gravity: 0.08,
                exploded: false,
                explosionRadius: 120,
                trailTimer: 0
            };
            bomberBombs.push(bomb);
            bomber.activeBomb = bomb;
            bomber.isReloading = true;
            bomber.reloadTimer = 0;
        }

        function updateBomber() {
            if (!bomber || currentLevel !== 4 || gameState !== 'playing') return;
            
            bomber.stealthPulse += 0.02;
            bomber.x += bomber.speed * bomber.direction;
            if (bomber.x < 80 || bomber.x > BASE_WIDTH - 80) {
                bomber.direction *= -1;
            }

            if (bomber.graceTimer > 0) {
                bomber.graceTimer--;
                return;
            }

            if (!bomber.activeBomb && !bomber.isReloading && bomberRoundsSurvived < bomber.roundsToSurvive) {
                dropBomberBomb();
            }

            if (bomber.isReloading) {
                bomber.reloadTimer++;
                if (bomber.reloadTimer >= bomber.reloadFrames) {
                    bomber.isReloading = false;
                    bomber.reloadTimer = 0;
                    bomber.activeBomb = null;
                }
            }
        }

        function resolveBombExplosion(bomb) {
            spawnParticles(bomb.x, bomb.y, '#FFA500', 20);
            spawnParticles(bomb.x, bomb.y, '#FF4500', 20);
            const dist = Math.hypot(turkey.x - bomb.x, turkey.y - bomb.y);
            if (dist < bomb.explosionRadius) {
                const didFail = handleTurkeyDamage('The stealth bomber roasted you!');
                return didFail;
            }
            bomberRoundsSurvived++;
            xp = bomberRoundsSurvived;
            bomber.activeBomb = null;
            if (bomberRoundsSurvived >= bomber.roundsToSurvive) {
                levelUp();
            }
            updateUI();
            return false;
        }

        function updateBomberBombs() {
            if (!bomber || currentLevel !== 4) return;
            for (let i = bomberBombs.length - 1; i >= 0; i--) {
                const bomb = bomberBombs[i];
                if (!bomb.exploded) {
                    bomb.vy += bomb.gravity;
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    
                    bomb.trailTimer++;
                    if (bomb.trailTimer % 5 === 0) {
                        spawnParticles(bomb.x, bomb.y, '#B0C4DE', 2);
                    }

                    // Barrier collision
                    for (let j = 0; j < barriers.length; j++) {
                        const barrier = barriers[j];
                        if (bomb.x > barrier.x - barrier.width / 2 &&
                            bomb.x < barrier.x + barrier.width / 2 &&
                            bomb.y > barrier.y - barrier.height / 2 &&
                            bomb.y < barrier.y + barrier.height / 2) {
                            bomb.exploded = true;
                            barriers.splice(j, 1);
                            if (resolveBombExplosion(bomb)) return;
                            bomberBombs.splice(i, 1);
                            break;
                        }
                    }

                    if (bomb.y >= BASE_HEIGHT - 80) {
                        bomb.exploded = true;
                        if (resolveBombExplosion(bomb)) return;
                        bomberBombs.splice(i, 1);
                        continue;
                    }
                }
            }
        }

        function initBoss(type = BOSS_TYPES.PUMPKIN) {
            if (type === BOSS_TYPES.AURORA) {
                boss = {
                    type,
                    x: BASE_WIDTH / 2,
                    y: BASE_HEIGHT / 2 - 120,
                    radius: 90,
                    health: 30,
                    maxHealth: 30,
                    attackTimer: 0,
                    graceTimer: 240,
                    pulse: 0,
                    isRecharging: false,
                    rechargeTimer: 0
                };
                ensureAuroraAmbience();
            } else {
                boss = {
                    type: BOSS_TYPES.PUMPKIN,
                    x: 300,
                    y: 150,
                    width: 100,
                    height: 100,
                    health: 16,
                    maxHealth: 16,
                    speed: 2,
                    direction: 1,
                    attackTimer: 0,
                    opacity: 1,
                    shotsThrown: 0,
                    missingSlices: [],
                    currentScale: 1
                };
            }
            
            const corners = [
                { x: 80, y: BASE_HEIGHT - 150 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 150 },
                { x: 80, y: BASE_HEIGHT - 300 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 300 }
            ];
            const randomCorner = corners[Math.floor(Math.random() * corners.length)];
            turkey.x = randomCorner.x;
            turkey.y = randomCorner.y;
            
            apples = [];
            const initialDrops = type === BOSS_TYPES.AURORA ? 6 : 3;
            for (let i = 0; i < initialDrops; i++) {
                spawnApple();
            }
        }

        function getAppleSpawnRange() {
            if (currentLevel === 4) {
                const { minY, maxY } = getTurkeyVerticalBounds();
                const padding = 20;
                const groundMin = Math.max(minY + padding, BASE_HEIGHT - BOMBER_GROUND_BAND_HEIGHT + 10);
                const groundMax = Math.max(groundMin + 1, maxY - 5);
                return { minY: groundMin, maxY: groundMax };
            }
            return { minY: 50, maxY: BASE_HEIGHT - 150 };
        }

        function getAppleCapForLevel() {
            if (currentLevel === 4) {
                return 3;
            }
            return Number.POSITIVE_INFINITY;
        }

        function spawnApple() {
            const maxApples = getAppleCapForLevel();
            if (apples.length >= maxApples) {
                return;
            }
            let attempts = 0;
            const maxAttempts = 25;
            while (attempts < maxAttempts) {
                const size = currentLevel === 7 ? 32 : 25;
                const { minY: appleMinY, maxY: appleMaxY } = getAppleSpawnRange();
                const yRange = Math.max(1, appleMaxY - appleMinY);
                const candidate = {
                    x: Math.random() * (BASE_WIDTH - 100) + 50,
                    y: appleMinY + Math.random() * yRange,
                    size,
                    rotation: Math.random() * Math.PI * 2,
                    bobOffset: Math.random() * Math.PI * 2
                };
                if (!isInsideSolidBarrier(candidate.x, candidate.y, size)) {
                    apples.push(candidate);
                    return;
                }
                attempts++;
            }
        }

        function spawnParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 8 + 4,
                    color: color,
                    life: 1
                });
            }
        }

        function spawnRoamingAuroras(count = 8) {
            for (let i = 0; i < count; i++) {
                const fromLeft = Math.random() > 0.5;
                const hue = 180 + Math.random() * 90;
                roamingAuroras.push({
                    x: fromLeft ? -120 - Math.random() * 80 : BASE_WIDTH + 120 + Math.random() * 80,
                    y: Math.random() * (BASE_HEIGHT * 0.6) + 40,
                    radius: 80 + Math.random() * 70,
                    driftSpeed: 0.15 + Math.random() * 0.2,
                    wobbleOffset: Math.random() * Math.PI * 2,
                    innerColor: `hsla(${hue}, 90%, 80%, 0.85)`,
                    outerColor: `hsla(${hue}, 80%, 55%, 0.12)`
                });
            }
        }

        function ensureAuroraAmbience(forceReset = false) {
            if (forceReset) {
                roamingAuroras = [];
            }
            if (roamingAuroras.length === 0) {
                spawnRoamingAuroras(10);
            }
        }

        function triggerAuroraEnergyBlast() {
            if (!boss) return;
            const blastRadius = Math.max(BASE_WIDTH, BASE_HEIGHT) + 400;
            auroraBlasts.push({
                x: boss.x,
                y: boss.y,
                radius: boss.radius,
                maxRadius: blastRadius,
                alpha: 1,
                speed: 9,
                fade: 0.012
            });

            const unsafeRadius = boss.radius + 120;
            const distanceToTurkey = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            if (distanceToTurkey <= unsafeRadius) {
                handleTurkeyDamage('The aurora blast consumed you up close!');
            }

            const novaCount = 18;
            for (let i = 0; i < novaCount; i++) {
                const angle = (Math.PI * 2 * i) / novaCount;
                bossProjectiles.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * 5.5,
                    vy: Math.sin(angle) * 5.5,
                    size: 24,
                    type: 'auroraNova',
                    life: 150,
                    onHitMessage: 'The aurora blast vaporized you!'
                });
            }

            spawnParticles(boss.x, boss.y, '#d4fff9', 30);
            spawnParticles(boss.x, boss.y, '#a855ff', 20);
            auroraWaves.push({
                x: boss.x,
                y: boss.y,
                radius: boss.radius,
                maxRadius: boss.radius + 320,
                alpha: 1
            });
        }

        function updateAuroraBlasts() {
            for (let i = auroraBlasts.length - 1; i >= 0; i--) {
                const blast = auroraBlasts[i];
                blast.radius += blast.speed;
                blast.alpha = Math.max(0, blast.alpha - blast.fade);

                if (blast.radius >= blast.maxRadius || blast.alpha <= 0.02) {
                    auroraBlasts.splice(i, 1);
                }
            }
        }

        function gainLeftoverScraps(amount = LEFTOVER_CONFIG.scrapsPerFruit) {
            leftoverBuffs.scraps += amount;
            updateLeftoverUI('Scraps collected!');
        }

        function canUseLeftover(buffKey) {
            const config = LEFTOVER_CONFIG[buffKey];
            const buffState = leftoverBuffs[buffKey];
            if (!config || !buffState) return false;
            if (!isAbilityEnabled(buffKey)) return false;
            const affordable = leftoverBuffs.scraps >= config.cost;
            const ready = buffState.activeTimer <= 0 && buffState.cooldownTimer <= 0;
            return affordable && ready;
        }

        function craftCranberryDash() {
            if (!canUseLeftover('cranberry')) {
                updateLeftoverUI('Need more scraps or cooldown!');
                return;
            }
            leftoverBuffs.scraps -= LEFTOVER_CONFIG.cranberry.cost;
            leftoverBuffs.cranberry.activeTimer = LEFTOVER_CONFIG.cranberry.duration;
            leftoverBuffs.cranberry.cooldownTimer = LEFTOVER_CONFIG.cranberry.duration + LEFTOVER_CONFIG.cranberry.cooldown;
            spawnParticles(turkey.x, turkey.y, '#b11226', 18);
            updateLeftoverUI('Cranberry dash brewed!');
        }

        function activateContextAbility() {
            craftCranberryDash();
        }

        function updateLeftoverUI(statusMessage = null) {
            if (!leftoverScrapsEl) return;
            leftoverScrapsEl.textContent = leftoverBuffs.scraps;

            if (craftCranberryBtn) {
                craftCranberryBtn.style.display = '';
                craftCranberryBtn.disabled = !canUseLeftover('cranberry');
                craftCranberryBtn.textContent = `‚ö° Speed Boost (${LEFTOVER_CONFIG.cranberry.cost})`;
            }

            if (!statusMessage) {
                const abilityState = leftoverBuffs.cranberry;
                const abilityConfig = LEFTOVER_CONFIG.cranberry;
                const abilityEmoji = '‚ö°';
                const abilityName = 'Speed Boost';
                if (abilityState.activeTimer > 0) {
                    statusMessage = `${abilityEmoji} ${abilityName} active!`;
                } else if (abilityState.cooldownTimer > 0) {
                    statusMessage = `${abilityEmoji} ${abilityName} cooling down...`;
                } else if (leftoverBuffs.scraps >= abilityConfig.cost) {
                    statusMessage = `${abilityEmoji} ${abilityName} ready!`;
                } else {
                    statusMessage = `Collect treats for ${abilityName}!`;
                }
            }
            if (leftoverStatusEl) {
                leftoverStatusEl.textContent = statusMessage;
            }
        }

        function handleTurkeyDamage(reason) {
            gameOver(reason);
            return true;
        }

        function resetLeftovers() {
            leftoverBuffs.scraps = 0;
            leftoverBuffs.cranberry.activeTimer = 0;
            leftoverBuffs.cranberry.cooldownTimer = 0;
            updateLeftoverUI('Leftovers reset. Start cooking!');
        }

        function enforceSolidBarriers() {
            let adjusted = false;
            barriers.forEach(barrier => {
                if (!barrier.solid) return;
                const halfW = barrier.width / 2;
                const halfH = barrier.height / 2;
                const dx = turkey.x - barrier.x;
                const dy = turkey.y - barrier.y;
                const overlapX = turkey.width / 2 + halfW - Math.abs(dx);
                const overlapY = turkey.height / 2 + halfH - Math.abs(dy);
                if (overlapX > 0 && overlapY > 0) {
                    adjusted = true;
                    if (overlapX < overlapY) {
                        turkey.x += dx > 0 ? overlapX : -overlapX;
                    } else {
                        turkey.y += dy > 0 ? overlapY : -overlapY;
                    }
                }
            });
            if (adjusted) {
                turkey.x = Math.max(turkey.width / 2, Math.min(BASE_WIDTH - turkey.width / 2, turkey.x));
                turkey.y = Math.max(turkey.height / 2, Math.min(BASE_HEIGHT - turkey.height / 2 - 30, turkey.y));
            }
        }

        function isInsideSolidBarrier(x, y, padding = 0) {
            return barriers.some(barrier => {
                if (!barrier.solid) return false;
                return (
                    x > barrier.x - barrier.width / 2 - padding &&
                    x < barrier.x + barrier.width / 2 + padding &&
                    y > barrier.y - barrier.height / 2 - padding &&
                    y < barrier.y + barrier.height / 2 + padding
                );
            });
        }

        function updateRoamingAuroras() {
            if (!roamingAuroras.length) return;
            const time = Date.now() * 0.001;
            roamingAuroras.forEach(sprite => {
                const angle = Math.atan2(turkey.y - sprite.y, turkey.x - sprite.x);
                sprite.x += Math.cos(angle) * sprite.driftSpeed;
                sprite.y += Math.sin(angle) * sprite.driftSpeed * 0.6;
                sprite.y += Math.sin(time + sprite.wobbleOffset) * 0.4;

                const distanceToTurkey = Math.hypot(turkey.x - sprite.x, turkey.y - sprite.y);
                if (distanceToTurkey < 60) {
                    sprite.x += Math.cos(angle + Math.PI) * 30;
                    sprite.y += Math.sin(angle + Math.PI) * 30;
                }

                if (sprite.x < -200 || sprite.x > BASE_WIDTH + 200 || sprite.y < -200 || sprite.y > BASE_HEIGHT + 200) {
                    sprite.x = Math.random() > 0.5 ? -120 : BASE_WIDTH + 120;
                    sprite.y = Math.random() * (BASE_HEIGHT * 0.6) + 40;
                }
            });
        }

        function updateUI() {
            if (gameState === 'win' || !levels[currentLevel]) return;
            
            let scoreIcon = 'üçé';
            if (currentLevel === 5) {
                scoreIcon = 'üçç';
            } else if (currentLevel === 6) {
                scoreIcon = 'üåΩ';
            } else if (currentLevel === 7) {
                scoreIcon = 'üé™';
            }
            scoreIconEl.textContent = scoreIcon;
            let levelLabel = `Level ${currentLevel}: ${levels[currentLevel].name}`;
            if (currentLevel === 7 && paradeFloat) {
                levelLabel += ` ¬∑ ${paradeFloat.stageLabels[paradeFloat.stage]}`;
            }
            document.getElementById('levelDisplay').textContent = levelLabel;
            document.getElementById('scoreDisplay').textContent = score;

            let filled = xp;
            let needed = xpNeeded;
            let label = 'XP';

            if (currentLevel === 4) {
                filled = bomberRoundsSurvived;
                needed = (bomber && bomber.roundsToSurvive) || xpNeeded;
                label = 'Rounds Survived';
            } else if (currentLevel === 5 && boss && boss.type === BOSS_TYPES.AURORA) {
                filled = Math.max(0, boss.health);
                needed = boss.maxHealth;
                label = 'Boss HP';
            } else if (currentLevel === 6) {
                label = 'Maze XP';
            } else if (currentLevel === 7 && paradeFloat) {
                filled = paradeFloat.partsBuilt;
                needed = paradeFloat.partsRequired;
                label = 'Float Parts';
            }

            const xpPercent = needed > 0 ? Math.min(100, (filled / needed) * 100) : 0;
            document.getElementById('xpBar').style.width = xpPercent + '%';
            const displayValue = Math.max(0, Math.round(filled));
            document.getElementById('xpText').textContent = `${label}: ${displayValue} / ${needed}`;
        }

        function update() {
            if (gameState !== 'playing' && gameState !== 'boss') return;

            // Update peck cooldowns
            if (peckCooldown > 0) peckCooldown--;
            if (peckAnimTimer > 0) {
                peckAnimTimer--;
            } else {
                isPecking = false;
            }

            // Update leftover timers
            if (leftoverBuffs.cranberry.activeTimer > 0) leftoverBuffs.cranberry.activeTimer--;
            if (leftoverBuffs.cranberry.cooldownTimer > 0) leftoverBuffs.cranberry.cooldownTimer--;
            leftoverUIFrame++;
            if (leftoverUIFrame % 12 === 0) {
                updateLeftoverUI();
            }

            // Move turkey
            let keyboardDx = 0;
            let keyboardDy = 0;
            let moveDx = 0;
            let moveDy = 0;
            let speedMultiplier = 1;
            const cranberryBoost = leftoverBuffs.cranberry.activeTimer > 0 ? LEFTOVER_CONFIG.cranberry.speedBoost : 1;
            const isCornMazeLevel = currentLevel === 6;
            const levelSpeedModifier = isCornMazeLevel ? CORN_MAZE_SPEED_MODIFIER : 1;
            
            const keyLeft = keys['arrowleft'] || keys['a'] || keys['ArrowLeft'];
            const keyRight = keys['arrowright'] || keys['d'] || keys['ArrowRight'];
            const keyUp = keys['arrowup'] || keys['w'] || keys['ArrowUp'];
            const keyDown = keys['arrowdown'] || keys['s'] || keys['ArrowDown'];

            if (keyLeft) keyboardDx -= 1;
            if (keyRight) keyboardDx += 1;
            if (keyUp) keyboardDy -= 1;
            if (keyDown) keyboardDy += 1;

            moveDx = keyboardDx;
            moveDy = keyboardDy;

            if (touchActive && touchTarget) {
                const toTargetX = touchTarget.x - turkey.x;
                const toTargetY = touchTarget.y - turkey.y;
                const distToTarget = Math.hypot(toTargetX, toTargetY);

                if (distToTarget > 6) {
                    moveDx = toTargetX / distToTarget;
                    moveDy = toTargetY / distToTarget;
                    speedMultiplier = Math.min(1 + distToTarget / 200, 2);
                } else if (!keyboardDx && !keyboardDy) {
                    moveDx = 0;
                    moveDy = 0;
                }
            }

            const strideSpeed = turkey.speed * speedMultiplier * cranberryBoost * levelSpeedModifier;
            const isMoving = moveDx !== 0 || moveDy !== 0;
            if (isMoving) {
                const len = Math.hypot(moveDx, moveDy);
                moveDx /= len;
                moveDy /= len;
                turkey.x += moveDx * strideSpeed;
                turkey.y += moveDy * strideSpeed;
                turkey.direction = moveDx >= 0 ? 1 : -1;
                
                if (leftoverBuffs.cranberry.activeTimer > 0 && leftoverBuffs.cranberry.activeTimer % 5 === 0) {
                    spawnParticles(turkey.x - moveDx * 20, turkey.y - moveDy * 20, '#b11226', 2);
                }
            }

            if (isMoving) {
                const phaseStep = Math.min(0.4, Math.max(0.08, strideSpeed * 0.04));
                turkey.legPhase = (turkey.legPhase + phaseStep) % (Math.PI * 2);
                turkey.legSwingAmount = Math.min(1, turkey.legSwingAmount + 0.08);
            } else {
                turkey.legPhase = (turkey.legPhase + 0.01) % (Math.PI * 2);
                turkey.legSwingAmount = Math.max(0, turkey.legSwingAmount - 0.05);
            }

            if (currentLevel === 5 || (boss && boss.type === BOSS_TYPES.AURORA) || nextBossType === BOSS_TYPES.AURORA) {
                updateRoamingAuroras();
            }

            // Animate mouth
            turkey.mouthOpen = Math.sin(Date.now() / 100) * 0.3 + 0.3;

            // Clamp position
            clampTurkeyToBounds();
            enforceSolidBarriers();

            if (gameState === 'boss' && boss && peckCooldown === 0) {
                const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
                const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
                const canAutoPeck = boss.type !== BOSS_TYPES.AURORA || isAuroraBossVulnerable();
                if (distToBoss < PECK_RANGE + bossRadius && canAutoPeck) {
                    tryPeckAttack();
                }
            }

            // Check apple collisions
            for (let i = apples.length - 1; i >= 0; i--) {
                const apple = apples[i];
                const dist = Math.hypot(turkey.x - apple.x, turkey.y - apple.y);
                if (dist < turkey.width / 2 + apple.size / 2) {
                    const isPineappleRound = currentLevel === 5;
                    const fruitColor = isPineappleRound ? '#FFA500' : '#FF0000';
                    const leafColor = isPineappleRound ? '#2E8B57' : '#00FF00';
                    spawnParticles(apple.x, apple.y, fruitColor, 8);
                    spawnParticles(apple.x, apple.y, leafColor, 4);
                    apples.splice(i, 1);
                    score++;
                    gainLeftoverScraps();
                    
                    if (gameState === 'boss' && boss) {
                        if (boss.type !== BOSS_TYPES.AURORA) {
                            boss.health -= 1;
                            spawnParticles(boss.x, boss.y, '#FF7518', 15);
                            if (boss.health <= 0) {
                                spawnParticles(boss.x, boss.y, '#FFD700', 30);
                                boss = null;
                                levelUp();
                            }
                        }
                    } else if (currentLevel === 7 && paradeFloat && gameState !== 'boss') {
                        incrementParadeFloat();
                        xp = paradeFloat.partsBuilt;
                        if (xp >= xpNeeded) {
                            levelUp();
                        }
                    } else if (currentLevel !== 4 && gameState !== 'boss') {
                        xp++;
                        if (xp >= xpNeeded) {
                            if (currentLevel === 1) {
                                queueBossFight(BOSS_TYPES.PUMPKIN);
                            } else {
                                levelUp();
                            }
                        }
                    }
                    
                    spawnApple();
                    updateUI();
                }
            }

            // Update boss
            if (gameState === 'boss' && boss) {
                if (boss.type === BOSS_TYPES.AURORA) {
                    updateAuroraBoss();
                } else {
                    updatePumpkinBoss();
                }
            }

            // Update hunter (level 3) - Hunter stays in center but still shoots
            if (hunter && gameState === 'playing') {
                // Hunter stays in place - no movement code

                // Grace period at the start - hunter doesn't shoot immediately
                if (hunter.graceTimer > 0) {
                    hunter.graceTimer--;
                } else if (hunter.isReloading) {
                    // Hunter is reloading - 10 seconds worth of frames
                    hunter.reloadTimer++;
                    updateHunterPatrol();
                    if (hunter.reloadTimer >= HUNTER_RELOAD_FRAMES) {
                        hunter.isReloading = false;
                        hunter.reloadTimer = 0;
                        hunter.shotsFired = 0;
                    }
                } else {
                    // Hunter can shoot - fires 3 shots then reloads
                    hunter.shootTimer++;
                    if (hunter.shootTimer > 60) { // Slightly faster between shots in burst
                        hunter.shootTimer = 0;
                        const angle = Math.atan2(turkey.y - hunter.y, turkey.x - hunter.x);
                        bossProjectiles.push({
                            x: hunter.x,
                            y: hunter.y,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            size: 15,
                            isHunter: true,
                            type: 'bullet',
                            onHitMessage: 'You got shot!'
                        });
                        
                        hunter.shotsFired++;
                        if (hunter.shotsFired >= 3) {
                            // Start reloading after 3 shots
                            beginHunterReload();
                        }
                    }
                }

            }

            if (currentLevel === 4 && gameState === 'playing') {
                updateBomber();
                updateBomberBombs();
            }

            // Update projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const proj = bossProjectiles[i];
                if (typeof proj.life === 'number') {
                    proj.life--;
                    if (proj.life <= 0) {
                        bossProjectiles.splice(i, 1);
                        continue;
                    }
                }
                proj.x += proj.vx;
                proj.y += proj.vy;
                if (proj.type === 'auroraStreak') {
                    proj.trailLength = Math.max(60, (proj.trailLength || 140) * 0.99);
                }

                // Check collision with turkey
                const dist = Math.hypot(turkey.x - proj.x, turkey.y - proj.y);
                if (dist < turkey.width / 2 + proj.size / 2) {
                    const message = proj.onHitMessage || (proj.isHunter ? 'You got shot!' : 'You were blasted!');
                    if (handleTurkeyDamage(message)) {
                        return;
                    }
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with barriers (projectiles get blocked)
                let hitBarrier = false;
                for (const barrier of barriers) {
                    if (proj.x > barrier.x - barrier.width / 2 &&
                        proj.x < barrier.x + barrier.width / 2 &&
                        proj.y > barrier.y - barrier.height / 2 &&
                        proj.y < barrier.y + barrier.height / 2) {
                        // Projectile hit barrier - destroy it with particles
                        const impactColor = proj.type === 'aurora' ? '#7FFFD4' : (proj.isHunter ? '#555' : '#FF7518');
                        spawnParticles(proj.x, proj.y, impactColor, 6);
                        bossProjectiles.splice(i, 1);
                        hitBarrier = true;
                        break;
                    }
                }
                if (hitBarrier) continue;

                // Remove off-screen
                if (proj.x < -50 || proj.x > canvas.width + 50 || proj.y < -50 || proj.y > canvas.height + 50) {
                    bossProjectiles.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            for (let i = auroraWaves.length - 1; i >= 0; i--) {
                const wave = auroraWaves[i];
                wave.radius += 3;
                wave.alpha -= 0.01;
                if (wave.alpha <= 0 || wave.radius >= wave.maxRadius) {
                    auroraWaves.splice(i, 1);
                }
            }

            updateAuroraBlasts();

            updateParadeConfetti();
        }

        function finishPumpkinBoss(options = {}) {
            if (!boss || boss.type !== BOSS_TYPES.PUMPKIN) return;
            const { scoreBonus = 0, bursts } = options;
            const burstConfig = bursts || [
                { color: '#FFD700', count: 30 },
                { color: '#FF7518', count: 20 },
                { color: '#FFFAF0', count: 15 }
            ];
            burstConfig.forEach(({ color, count }) => {
                spawnParticles(boss.x, boss.y, color, count);
            });
            if (scoreBonus) {
                score += scoreBonus;
            }
            boss = null;
            levelUp();
            updateUI();
        }

        function updatePumpkinBoss() {
            boss.x += boss.speed * boss.direction;
            if (boss.x < 100 || boss.x > BASE_WIDTH - 100) {
                boss.direction *= -1;
            }

            boss.attackTimer++;
            if (boss.attackTimer >= PUMPKIN_ATTACK_INTERVAL_FRAMES) {
                boss.attackTimer = 0;
                
                const sliceIndex = boss.shotsThrown % PUMPKIN_SLICE_COUNT;
                const sliceAngleStep = (Math.PI * 2) / PUMPKIN_SLICE_COUNT;
                const sliceAngle = sliceIndex * sliceAngleStep;
                const alreadyMissing = boss.missingSlices.some(missAngle => Math.abs(missAngle - sliceAngle) < 0.01);
                if (!alreadyMissing) {
                    boss.missingSlices.push(sliceAngle);
                }
                const noSlicesLeft = boss.missingSlices.length >= PUMPKIN_SLICE_COUNT;
                
                const throwOffsetX = Math.cos(sliceAngle + Math.PI / 8) * (boss.width / 2 * boss.currentScale);
                const throwOffsetY = Math.sin(sliceAngle + Math.PI / 8) * (boss.height / 2 * boss.currentScale);
                
                bossProjectiles.push({
                    x: boss.x + throwOffsetX,
                    y: boss.y + throwOffsetY,
                    vx: (Math.random() - 0.5) * 4 + throwOffsetX * 0.05,
                    vy: 6,
                    size: 20,
                    type: 'pie',
                    onHitMessage: 'The pie got you!'
                });
                
                boss.shotsThrown++;

                if (noSlicesLeft) {
                    finishPumpkinBoss();
                    return;
                }

                boss.health -= 0.3;
                boss.currentScale = Math.max(0.4, 1 - (boss.shotsThrown * 0.06));
                boss.opacity = Math.max(0.3, 1 - (boss.shotsThrown * 0.03));
                
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FF7518', 10);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#DEB887', 6);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FFFAF0', 4);
                
                if (boss.health <= 0) {
                    finishPumpkinBoss();
                    return;
                }
                
                updateUI();
            }

            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const eatRange = turkey.width / 2 + boss.width / 2 - 10;
            
            if (distToBoss < eatRange) {
                boss.eatCooldown = boss.eatCooldown || 0;
                boss.eatCooldown--;
                
                if (boss.eatCooldown <= 0) {
                    boss.eatCooldown = 20;
                    boss.health -= 2;
                    
                    turkey.mouthOpen = 1;
                    spawnParticles(boss.x, boss.y, '#FF7518', 15);
                    spawnParticles(boss.x, boss.y, '#DEB887', 8);
                    spawnParticles(turkey.x + turkey.direction * 30, turkey.y, '#FFD700', 5);
                    
                    const pushDir = boss.x > turkey.x ? 1 : -1;
                    boss.x += pushDir * 15;
                    
                    if (boss.health <= 0) {
                        finishPumpkinBoss({
                            scoreBonus: 5,
                            bursts: [
                                { color: '#FFD700', count: 40 },
                                { color: '#FF7518', count: 30 },
                                { color: '#FFFAF0', count: 20 }
                            ]
                        });
                        return;
                    }
                    
                    updateUI();
                }
            }
        }

        function updateAuroraBoss() {
            boss.pulse += 0.02;

            if (boss.graceTimer > 0) {
                boss.graceTimer--;
                boss.attackTimer = 0;
                return;
            }

            if (boss.isRecharging) {
                boss.rechargeTimer--;
                if (boss.rechargeTimer <= 0) {
                    boss.isRecharging = false;
                    boss.attackTimer = 0;
                    triggerAuroraEnergyBlast();
                }
                return;
            }

            boss.attackTimer++;

            if (boss.attackTimer % 45 === 0) {
                const volley = 3;
                const baseAngle = Math.atan2(turkey.y - boss.y, turkey.x - boss.x);
                for (let i = 0; i < volley; i++) {
                    const offset = (i - 1) * 0.2;
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(baseAngle + offset) * 4.5,
                        vy: Math.sin(baseAngle + offset) * 4.5,
                        size: 22,
                        type: 'aurora',
                        color: `hsl(${180 + i * 40}, 80%, 70%)`,
                        onHitMessage: 'The northern lights consumed you!'
                    });
                }
                spawnParticles(boss.x, boss.y, '#7FFFD4', 12);
            }

            if (boss.attackTimer % 120 === 0) {
                const streaks = 2;
                const baseAngle = Math.atan2(turkey.y - boss.y, turkey.x - boss.x);
                for (let i = 0; i < streaks; i++) {
                    const offset = (i - (streaks - 1) / 2) * 0.25;
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(baseAngle + offset) * 6.5,
                        vy: Math.sin(baseAngle + offset) * 6.5,
                        size: 14,
                        type: 'auroraStreak',
                        trailLength: 170,
                        life: 240,
                        color: `hsl(${200 + i * 35}, 90%, 70%)`,
                        onHitMessage: 'A light streak vaporized you!'
                    });
                }
                spawnParticles(boss.x, boss.y, '#a855ff', 18);
            }

            if (boss.attackTimer % 180 === 0) {
                auroraWaves.push({
                    x: boss.x,
                    y: boss.y,
                    radius: boss.radius,
                    maxRadius: boss.radius + 260,
                    alpha: 0.7
                });
            }

            if (boss.attackTimer >= AURORA_ATTACK_WINDOW_FRAMES) {
                boss.isRecharging = true;
                boss.rechargeTimer = AURORA_RECHARGE_FRAMES;
                spawnParticles(boss.x, boss.y, '#d4fff9', 18);
            }
        }
        function levelUp() {
            currentLevel++;
            turkey.evolution++;
            
            if (currentLevel > MAX_LEVEL) {
                gameState = 'win';
                document.getElementById('winScore').textContent = score;
                document.getElementById('winScreen').classList.remove('hidden');
                return;
            }

            gameState = 'levelup';
            const nextLevel = levels[currentLevel] || { name: 'Unknown', description: '' };
            document.getElementById('newLevelName').textContent = `Level ${currentLevel}: ${nextLevel.name}`;
            document.getElementById('levelDescription').textContent = nextLevel.description;
            document.getElementById('levelUpScreen').classList.remove('hidden');
            startLevelCountdown();
            updateUI();
        }

        function gameOver(message) {
            gameState = 'gameover';
            document.getElementById('deathMessage').textContent = message;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const isPumpkinBossField = boss && boss.type === BOSS_TYPES.PUMPKIN && currentLevel === 1;
            const isAuroraBattle = boss && boss.type === BOSS_TYPES.AURORA;
            const backdropLevel = isAuroraBattle ? 5 : (isPumpkinBossField ? 2 : currentLevel);
            
            switch (backdropLevel) {
                case 1: {
                    gradient.addColorStop(0, '#8B4513');
                    gradient.addColorStop(1, '#5D3A1A');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#4A2C17';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < canvas.width; i += 60) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, canvas.height);
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = '#DAA520';
                    const haySpacing = 25;
                    const hayCount = Math.ceil(canvas.width / haySpacing) + 5;
                    for (let i = 0; i < hayCount; i++) {
                        ctx.beginPath();
                        const x = (i * haySpacing) % canvas.width;
                        const waveOffset = Math.sin(i * 0.5) * 10;
                        ctx.ellipse(
                            x,
                            canvas.height - 30 + waveOffset,
                            20,
                            8,
                            0,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                }
                case 2: {
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(0.6, '#FDB347');
                    gradient.addColorStop(1, '#228B22');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    
                    const canopyColors = ['#FF6347', '#FF8C00', '#FFD700', '#DC143C'];
                    const groveCount = Math.max(4, Math.ceil(canvas.width / 160));
                    const groveSpacing = canvas.width / groveCount;
                    for (let i = 0; i < groveCount; i++) {
                        const tx = groveSpacing * i + groveSpacing / 2;
                        ctx.fillStyle = '#5D3A1A';
                        ctx.fillRect(tx - 10, canvas.height - 180, 20, 100);
                        ctx.beginPath();
                        ctx.fillStyle = canopyColors[i % canopyColors.length];
                        ctx.arc(tx, canvas.height - 200, 50, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                }
                case 4: {
                    gradient.addColorStop(0, '#030711');
                    gradient.addColorStop(1, '#0f1a2b');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff22';
                    const starCount = Math.max(80, Math.ceil(canvas.width / 10));
                    for (let i = 0; i < starCount; i++) {
                        ctx.beginPath();
                        const x = (i * 53) % canvas.width;
                        const y = (i * 97) % 200;
                        const radius = (i % 3) * 0.6 + 0.5;
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    const groundHeight = Math.max(60, canvas.height * 0.1);
                    ctx.fillStyle = '#1a3a1a';
                    ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
                    break;
                }
                case 5: {
                    gradient.addColorStop(0, '#05030f');
                    gradient.addColorStop(0.5, '#112144');
                    gradient.addColorStop(1, '#04121f');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const auroraColors = ['#5ef1ff', '#a855ff', '#5ef179', '#ffd15e'];
                    auroraColors.forEach((color, index) => {
                        ctx.beginPath();
                        ctx.moveTo(0, 200 + index * 30);
                        for (let x = 0; x <= canvas.width; x += 20) {
                            const y = 200 + index * 30 + Math.sin((x / canvas.width) * Math.PI * 2 + index) * 40;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.lineTo(0, canvas.height);
                        ctx.closePath();
                        ctx.fillStyle = color + '33';
                        ctx.fill();
                    });
                    
                    ctx.fillStyle = '#0b1d2c';
                    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                    break;
                }
                case 6: {
                    gradient.addColorStop(0, '#1b1206');
                    gradient.addColorStop(0.4, '#3b240b');
                    gradient.addColorStop(1, '#1f1506');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#f2c94c22';
                    for (let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        const x = (i * 70 + (Date.now() / 50)) % (canvas.width + 100) - 50;
                        const y = 80 + (i % 5) * 60;
                        ctx.ellipse(x, y, 40, 14, Math.sin(i) * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#362003';
                    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                    ctx.fillStyle = '#6f4c1b';
                    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                    break;
                }
                case 7: {
                    gradient.addColorStop(0, '#1a0633');
                    gradient.addColorStop(0.5, '#2f0d2a');
                    gradient.addColorStop(1, '#000000');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // city skyline
                    ctx.fillStyle = '#0d0314';
                    for (let i = 0; i < 8; i++) {
                        const width = 50 + (i * 13 % 50);
                        const height = 120 + (i * 37 % 90);
                        ctx.fillRect(i * 80, canvas.height - 120 - height, width, height);
                        ctx.fillStyle = '#14041f';
                    }
                    
                    // spotlight beams
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height);
                    ctx.lineTo(canvas.width / 2 - 30, canvas.height - 300);
                    ctx.lineTo(canvas.width / 2 + 40, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.fillStyle = '#2b0b1d';
                    ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
                    break;
                }
                default: {
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#16213e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#FFFACD';
                    ctx.beginPath();
                    const sunX = canvas.width * 0.65;
                    const sunRadius = Math.max(40, canvas.width * 0.04);
                    ctx.arc(sunX, 80, sunRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0f0f23';
                    const mountainCount = Math.max(6, Math.ceil(canvas.width / 120));
                    const mountainWidth = canvas.width / mountainCount;
                    for (let i = 0; i < mountainCount; i++) {
                        const tx = i * mountainWidth;
                        const peakHeight = 200 + Math.sin(i * 0.8) * 60;
                        ctx.beginPath();
                        ctx.moveTo(tx, canvas.height);
                        ctx.lineTo(tx + mountainWidth / 2, canvas.height - peakHeight);
                        ctx.lineTo(tx + mountainWidth, canvas.height);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#2d4a3e';
                    const meadowHeight = Math.max(60, canvas.height * 0.08);
                    ctx.fillRect(0, canvas.height - meadowHeight, canvas.width, meadowHeight);
                }
            }
        }

        function drawTurkey() {
            ctx.save();
            ctx.translate(turkey.x, turkey.y);
            ctx.scale(turkey.direction, 1);
            
            const scale = 1 + (turkey.evolution - 1) * 0.2;
            ctx.scale(scale, scale);
            
            // Peck animation - lunge forward
            const peckLunge = isPecking ? Math.sin((peckAnimTimer / 15) * Math.PI) * 20 : 0;
            ctx.translate(peckLunge, 0);
            
            // Tail feathers
            const tailColors = ['#8B0000', '#FF4500', '#FFD700', '#8B4513', '#FF6347'];
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = tailColors[i];
                ctx.beginPath();
                const angle = (i - 2) * 0.4 - Math.PI / 2;
                ctx.ellipse(
                    Math.cos(angle) * 25 - 10 - peckLunge, // Tail stays back during peck
                    Math.sin(angle) * 25 - 5,
                    12, 30,
                    angle + Math.PI / 2,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Body
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(0, 5, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head - move forward extra during peck
            const headExtend = isPecking ? 10 : 0;
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(20 + headExtend, -5, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Wattle (red thing under beak)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(28 + headExtend, 5, 5, 10, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Snood (red thing on top)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(25 + headExtend, -15, 4, 8, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // BIG MOUTH / Beak - extra extended during peck
            const beakExtend = isPecking ? 25 : 0;
            ctx.fillStyle = isPecking ? '#FF6600' : '#FFA500'; // Brighter orange when pecking
            ctx.beginPath();
            const mouthOpenAmount = isPecking ? 8 : turkey.mouthOpen * 15; // Closed beak during peck for sharp hit
            // Upper beak
            ctx.moveTo(30 + headExtend, -8);
            ctx.lineTo(55 + headExtend + beakExtend, -5 - mouthOpenAmount);
            ctx.lineTo(30 + headExtend, -2);
            ctx.fill();
            // Lower beak
            ctx.beginPath();
            ctx.moveTo(30 + headExtend, -2);
            ctx.lineTo(55 + headExtend + beakExtend, 5 + mouthOpenAmount);
            ctx.lineTo(30 + headExtend, 2);
            ctx.fill();
            
            // Peck impact effect
            if (isPecking && peckAnimTimer > 10) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                // Impact lines
                for (let i = 0; i < 4; i++) {
                    const angle = (i - 1.5) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(60 + headExtend + beakExtend, -2);
                    ctx.lineTo(75 + headExtend + beakExtend + Math.cos(angle) * 15, -2 + Math.sin(angle) * 15);
                    ctx.stroke();
                }
            }
            
            // Eye - angry during peck
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(25 + headExtend, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(26 + headExtend, -9, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyebrow during peck
            if (isPecking) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20 + headExtend, -15);
                ctx.lineTo(30 + headExtend, -13);
                ctx.stroke();
            }
            
            // Legs with simple stride animation
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            const legBaseY = 22;
            const hipOffsets = [-6, 6];
            const swingAmp = 8 * turkey.legSwingAmount;
            const liftAmp = 6 * turkey.legSwingAmount;
            const drawAnimatedLeg = (hipX, phaseOffset) => {
                const phase = turkey.legPhase + phaseOffset;
                const swing = Math.sin(phase) * swingAmp;
                const lift = Math.max(0, Math.cos(phase)) * liftAmp;
                const kneeX = hipX + swing * 0.4;
                const kneeY = legBaseY + 8 - lift;
                const footX = hipX + swing;
                const footY = legBaseY + 20;
                
                ctx.beginPath();
                ctx.moveTo(hipX, legBaseY - 2);
                ctx.lineTo(kneeX, kneeY);
                ctx.lineTo(footX, footY);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX - 6, footY + 5);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX + 4, footY + 6);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX + 8, footY + 2);
                ctx.stroke();
            };
            drawAnimatedLeg(hipOffsets[0], 0);
            drawAnimatedLeg(hipOffsets[1], Math.PI);
            
            ctx.restore();
        }

        function drawApple(apple) {
            ctx.save();
            ctx.translate(apple.x, apple.y + Math.sin(Date.now() / 300 + apple.bobOffset) * 5);
            
            if (currentLevel === 5) {
                // Pineapple body
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.ellipse(0, 0, apple.size / 2.2, apple.size / 1.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#D67A00';
                ctx.lineWidth = 2;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, apple.size / 2.5, apple.size / 1.8, i * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Leaves
                ctx.fillStyle = '#1f8a5c';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse((i - 1.5) * 5, -apple.size / 1.4 - i * 2, 6, 16, (i - 1.5) * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                return;
            } else if (currentLevel === 6) {
                ctx.fillStyle = '#f2c94c';
                ctx.beginPath();
                ctx.ellipse(0, 0, apple.size / 2.4, apple.size / 1.2, 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#d18e00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -apple.size / 2);
                ctx.lineTo(0, apple.size / 2);
                ctx.moveTo(-apple.size / 4, -apple.size / 2);
                ctx.lineTo(-apple.size / 4, apple.size / 2);
                ctx.moveTo(apple.size / 4, -apple.size / 2);
                ctx.lineTo(apple.size / 4, apple.size / 2);
                ctx.stroke();
                ctx.fillStyle = '#2d6a4f';
                ctx.beginPath();
                ctx.ellipse(-apple.size / 3, -apple.size / 2, 8, 18, -0.5, 0, Math.PI * 2);
                ctx.ellipse(apple.size / 3, -apple.size / 2, 8, 18, 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                return;
            } else if (currentLevel === 7) {
                ctx.fillStyle = '#ff8fb1';
                ctx.fillRect(-apple.size / 2, -apple.size / 2, apple.size, apple.size);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(-apple.size / 2, -apple.size / 2, apple.size, apple.size);
                ctx.strokeStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(-apple.size / 2, 0);
                ctx.lineTo(apple.size / 2, 0);
                ctx.moveTo(0, -apple.size / 2);
                ctx.lineTo(0, apple.size / 2);
                ctx.stroke();
                ctx.restore();
                return;
            }
            
            // Apple body
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(0, 0, apple.size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(-5, -5, apple.size / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Stem
            ctx.strokeStyle = '#5D3A1A';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -apple.size / 2);
            ctx.lineTo(2, -apple.size / 2 - 8);
            ctx.stroke();
            
            // Leaf
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(6, -apple.size / 2 - 5, 6, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPeckIndicator() {
            if (gameState !== 'boss' || !boss) return;
            
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const inRange = distToBoss < PECK_RANGE + bossRadius;
            
            // Draw range circle around turkey
            ctx.save();
            ctx.translate(turkey.x, turkey.y);
            
            // Range indicator
            ctx.strokeStyle = inRange ? 'rgba(255, 215, 0, 0.6)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = inRange ? 3 : 1;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.arc(0, 0, PECK_RANGE, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Cooldown indicator (arc that fills up as cooldown resets)
            if (peckCooldown > 0) {
                const cooldownPercent = peckCooldown / PECK_COOLDOWN_MAX;
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 35, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownPercent) * Math.PI * 2);
                ctx.stroke();
            } else if (inRange) {
                // Ready to peck indicator
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('PECK!', 0, -45);
            }
            
            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            if (boss.type === BOSS_TYPES.AURORA) {
                drawAuroraBossSprite();
            } else {
                drawPumpkinBossSprite();
            }
        }

        function drawPumpkinBossSprite() {
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            // Apply fading opacity - boss fades as it throws more pies
            ctx.globalAlpha = boss.opacity;
            
            // Apply shrinking scale
            const scale = boss.currentScale;
            ctx.scale(scale, scale);
            
            // Pie dish (also shrinks)
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(0, boss.height / 2 - 10, boss.width / 2 + 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pie with missing slices
            const sliceCount = 8;
            const sliceAngle = Math.PI * 2 / sliceCount;
            
            for (let i = 0; i < sliceCount; i++) {
                const startAngle = i * sliceAngle;
                const endAngle = startAngle + sliceAngle - 0.05; // Small gap between slices
                
                // Check if this slice is missing
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - startAngle) < 0.1;
                });
                
                if (!isMissing) {
                    // Draw pie filling slice
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw crust edge on this slice
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, boss.width / 2 - 2, startAngle, endAngle);
                    ctx.stroke();
                } else {
                    // Draw empty/bitten area where slice was
                    ctx.fillStyle = 'rgba(139, 90, 43, 0.3)'; // Dark inner pie color
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2 - 15, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Whipped cream swirls (only on remaining slices)
            ctx.fillStyle = '#FFFAF0';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const sliceIndex = Math.floor(angle / sliceAngle);
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - sliceIndex * sliceAngle) < 0.1;
                });
                
                if (!isMissing) {
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(angle) * 25,
                        Math.sin(angle) * 25,
                        10, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Center cream dollop (gets smaller as more slices are gone)
            const centerSize = Math.max(5, 15 - boss.missingSlices.length);
            ctx.beginPath();
            ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil face (shrinks with the pie)
            ctx.fillStyle = '#000';
            // Eyes
            ctx.beginPath();
            ctx.arc(-15, -5, 6, 0, Math.PI * 2);
            ctx.arc(15, -5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil eyebrows - get more distressed as health drops
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const eyebrowLift = boss.missingSlices.length * 2;
            ctx.moveTo(-25, -15 - eyebrowLift);
            ctx.lineTo(-8, -12);
            ctx.moveTo(25, -15 - eyebrowLift);
            ctx.lineTo(8, -12);
            ctx.stroke();
            
            // Evil smile (becomes worried frown as health drops)
            ctx.beginPath();
            if (boss.missingSlices.length > 4) {
                // Worried frown
                ctx.arc(0, 20, 12, Math.PI + 0.3, -0.3);
            } else {
                // Evil smile
                ctx.arc(0, 10, 15, 0.2, Math.PI - 0.2);
            }
            ctx.stroke();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for health bar
            
            // Health bar - always fully visible even when boss is fading
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#333';
            ctx.fillRect(boss.x - 40, boss.y - boss.height / 2 - 20, 80, 10);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(boss.x - 38, boss.y - boss.height / 2 - 18, 76 * Math.max(0, boss.health / boss.maxHealth), 6);
            
            ctx.restore();
        }

        function drawAuroraBossSprite() {
            if (!boss) return;
            const auroraVulnerable = isAuroraBossVulnerable();
            ctx.save();
            ctx.translate(boss.x, boss.y);
            const pulse = 0.95 + Math.sin(boss.pulse) * (auroraVulnerable ? 0.2 : 0.12);
            const twist = Math.sin(boss.pulse * 0.8) * 0.25;
            ctx.rotate(twist);

            const outerGradient = ctx.createRadialGradient(0, 0, boss.radius * 0.35, 0, 0, boss.radius * 1.35);
            outerGradient.addColorStop(0, 'rgba(8, 12, 26, 0.95)');
            outerGradient.addColorStop(0.4, 'rgba(9, 51, 89, 0.85)');
            outerGradient.addColorStop(0.75, 'rgba(64, 255, 196, 0.25)');
            outerGradient.addColorStop(1, 'rgba(2, 4, 10, 0.05)');
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * 1.3 * pulse, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowColor = '#7fffd4';
            ctx.shadowBlur = 35;
            ctx.strokeStyle = 'rgba(127, 255, 212, 0.85)';
            ctx.lineWidth = 3;
            const spikes = 18;
            ctx.beginPath();
            for (let i = 0; i <= spikes; i++) {
                const angle = (i / spikes) * Math.PI * 2;
                const wobble = Math.sin(boss.pulse * 4 + i * 1.3) * 0.18;
                const radius = boss.radius * (1.05 + wobble);
                const spikeRadius = radius + Math.sin(boss.pulse * 6 + i) * 18;
                const spikeX = Math.cos(angle) * spikeRadius;
                const spikeY = Math.sin(angle) * spikeRadius;
                if (i === 0) {
                    ctx.moveTo(spikeX, spikeY);
                } else {
                    ctx.lineTo(spikeX, spikeY);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;

            const innerGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, boss.radius * 0.9);
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.95)');
            innerGradient.addColorStop(0.25, 'rgba(111,255,255,0.8)');
            innerGradient.addColorStop(0.6, 'rgba(66, 208, 255, 0.5)');
            innerGradient.addColorStop(1, 'rgba(7, 11, 25, 0.9)');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * 0.95 * pulse, 0, Math.PI * 2);
            ctx.fill();

            if (auroraVulnerable) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.85)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(0, 0, boss.radius * 1.45, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            ctx.strokeStyle = 'rgba(94, 241, 255, 0.45)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const angle = i * (Math.PI / 3) + boss.pulse * 0.4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const bend = Math.sin(boss.pulse * 3 + i) * 0.5;
                ctx.quadraticCurveTo(
                    Math.cos(angle) * boss.radius * 0.4,
                    Math.sin(angle) * boss.radius * 0.4,
                    Math.cos(angle + bend) * boss.radius * 0.85,
                    Math.sin(angle + bend) * boss.radius * 0.85
                );
                ctx.stroke();
            }

            const eyeGlow = 0.7 + Math.sin(boss.pulse * 2) * 0.3;
            const eyeOffsets = [-26, 0, 26];
            eyeOffsets.forEach((offset, index) => {
                ctx.save();
                ctx.translate(offset, -12 + Math.sin(boss.pulse + index) * 4);
                ctx.rotate(Math.sin(boss.pulse * 1.5 + index) * 0.2);
                ctx.fillStyle = 'rgba(5, 10, 18, 0.95)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 11, 24, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(148, 255, 246, ${eyeGlow})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 7, 16, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#03131f';
                ctx.beginPath();
                ctx.ellipse(Math.sin(boss.pulse * 3 + index) * 2, 0, 3, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            ctx.strokeStyle = '#7fffd4';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#03070f';
            ctx.beginPath();
            ctx.moveTo(-32, 28);
            for (let i = 0; i <= 6; i++) {
                const x = -32 + i * 10;
                const y = 28 + (i % 2 === 0 ? 18 : 6);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(32, 28);
            ctx.stroke();
            ctx.fill();

            ctx.fillStyle = '#d4fff9';
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                const x = -27 + i * 10;
                const height = i % 2 === 0 ? 18 : 12;
                ctx.moveTo(x, 28);
                ctx.lineTo(x + 5, 28 + height);
                ctx.lineTo(x + 10, 28);
                ctx.closePath();
                ctx.fill();
            }

            ctx.strokeStyle = 'rgba(148, 255, 246, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-12, 40);
            ctx.quadraticCurveTo(-8, 56 + Math.sin(boss.pulse * 5) * 6, -20, 78);
            ctx.moveTo(15, 42);
            ctx.quadraticCurveTo(22, 60 + Math.cos(boss.pulse * 4) * 6, 6, 82);
            ctx.stroke();

            ctx.restore();

            ctx.save();
            ctx.fillStyle = '#03060d';
            ctx.fillRect(boss.x - 60, boss.y - boss.radius - 30, 120, 12);
            ctx.fillStyle = '#7fffd4';
            const healthPercent = Math.max(0, boss.health / boss.maxHealth);
            ctx.fillRect(boss.x - 58, boss.y - boss.radius - 28, 116 * healthPercent, 8);

            if (boss.graceTimer > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '18px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(boss.graceTimer / 60);
                ctx.fillText(`Aurora charging... ${secondsLeft}s`, boss.x, boss.y - boss.radius - 50);
            } else if (auroraVulnerable) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '18px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('Aurora recharging - peck now!', boss.x, boss.y - boss.radius - 50);
            }
            ctx.restore();
        }

        function drawHunter() {
            if (!hunter) return;
            
            ctx.save();
            ctx.translate(hunter.x, hunter.y);
            
            // Body
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(-15, -20, 30, 40);
            
            // Head
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(0, -30, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Hunter hat
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(-18, -45, 36, 10);
            ctx.fillRect(-12, -55, 24, 12);
            
            // Gun
            ctx.fillStyle = '#333';
            ctx.fillRect(-30, -5, 25, 6);
            ctx.fillRect(-35, -8, 8, 12);
            
            // Legs
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-12, 20, 10, 25);
            ctx.fillRect(2, 20, 10, 25);
            
            // Angry eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -32, 3, 0, Math.PI * 2);
            ctx.arc(5, -32, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Show grace period indicator with countdown
            if (hunter.graceTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(hunter.graceTimer / 60);
                ctx.fillText('üí§ ' + secondsLeft + 's', 0, -70);
                
                // Warning text for player
                ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                ctx.font = 'bold 18px Fraunces';
                ctx.fillText('FIND COVER!', 0, 80);
            } else if (hunter.isReloading) {
                // Show reloading indicator
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil((HUNTER_RELOAD_FRAMES - hunter.reloadTimer) / 60);
                ctx.fillText('üîÑ RELOADING ' + secondsLeft + 's', 0, -70);
                
                // Reload progress bar
                ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                ctx.fillRect(-30, -60, 60, 8);
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.fillRect(-30, -60, 60 * (hunter.reloadTimer / HUNTER_RELOAD_FRAMES), 8);
            } else {
                // Show shots remaining
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.font = 'bold 12px Fraunces';
                ctx.textAlign = 'center';
                const shotsLeft = 3 - hunter.shotsFired;
                ctx.fillText('üéØ ' + shotsLeft + ' shots', 0, -70);
            }
            
            ctx.restore();
        }
        
        function drawBarriers() {
            barriers.forEach(barrier => {
                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                
                if (barrier.type === 'haybale') {
                    // Draw hay bale
                    ctx.fillStyle = '#DAA520';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, barrier.width / 2, barrier.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hay texture lines
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    for (let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * 10 - 5, -barrier.height / 2 + 5);
                        ctx.lineTo(i * 10 + 5, barrier.height / 2 - 5);
                        ctx.stroke();
                    }
                    
                    // Binding ropes
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, -barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(0, barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (barrier.type === 'rock') {
                    // Draw rock
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 2, barrier.height / 4);
                    ctx.lineTo(-barrier.width / 3, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 4, -barrier.height / 2 + 5);
                    ctx.lineTo(barrier.width / 2, -barrier.height / 4);
                    ctx.lineTo(barrier.width / 2 - 5, barrier.height / 2);
                    ctx.lineTo(-barrier.width / 3, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Rock highlights
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 4, -barrier.height / 3);
                    ctx.lineTo(0, -barrier.height / 4);
                    ctx.lineTo(-barrier.width / 6, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (barrier.type === 'tree') {
                    // Draw tree stump/trunk
                    ctx.fillStyle = '#4A3728';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 4, barrier.width, barrier.height * 0.75);
                    
                    // Tree top (dark pine)
                    ctx.fillStyle = '#1a3a1a';
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 30);
                    ctx.lineTo(-barrier.width - 10, -barrier.height / 4);
                    ctx.lineTo(barrier.width + 10, -barrier.height / 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Second layer
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 10);
                    ctx.lineTo(-barrier.width - 5, 0);
                    ctx.lineTo(barrier.width + 5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bark texture
                    ctx.strokeStyle = '#3D2914';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-5, barrier.height / 2);
                    ctx.moveTo(5, -5);
                    ctx.lineTo(5, barrier.height / 2 - 10);
                    ctx.stroke();
                } else if (barrier.type === 'bunker') {
                    ctx.fillStyle = '#4c5c68';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.fillStyle = '#2f3941';
                    ctx.fillRect(-barrier.width / 2 + 10, -barrier.height / 2 + 10, barrier.width - 20, barrier.height - 20);
                    ctx.fillStyle = '#b0c4de';
                    ctx.beginPath();
                    ctx.arc(0, -barrier.height / 2 + 10, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (barrier.type === 'auroraTree') {
                    const gradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    gradient.addColorStop(0, '#5ef1ff');
                    gradient.addColorStop(1, '#5ef179');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2);
                    ctx.lineTo(-barrier.width / 2, barrier.height / 2);
                    ctx.lineTo(barrier.width / 2, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#2a3b4f';
                    ctx.fillRect(-8, barrier.height / 2, 16, 30);
                } else if (barrier.type === 'iceWall') {
                    const iceGradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    iceGradient.addColorStop(0, '#c8f3ff');
                    iceGradient.addColorStop(1, '#5ed0ff');
                    ctx.fillStyle = iceGradient;
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                } else if (barrier.type === 'cornWall') {
                    const time = Date.now() * 0.002;
                    const sway = Math.sin(time + (barrier.waveOffset || 0)) * 5;
                    ctx.fillStyle = '#f4d03f';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 2, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 2, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 2 + sway, barrier.height / 2);
                    ctx.lineTo(-barrier.width / 2 + sway, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#8e6b1a';
                    ctx.lineWidth = 2;
                    for (let stalkX = -barrier.width / 2 + 10; stalkX < barrier.width / 2; stalkX += 15) {
                        ctx.beginPath();
                        ctx.moveTo(stalkX, -barrier.height / 2);
                        ctx.lineTo(stalkX + sway * 0.2, barrier.height / 2);
                        ctx.stroke();
                    }
                } else if (barrier.type === 'floatStage') {
                    ctx.fillStyle = '#4c1b2f';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.fillStyle = '#ffefc1';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2 - 14, barrier.width, 14);
                } else if (barrier.type === 'balloonStack') {
                    const colors = ['#ff8fb1', '#ffd166', '#7df9ff'];
                    for (let b = 0; b < 3; b++) {
                        ctx.fillStyle = colors[b % colors.length];
                        ctx.beginPath();
                        ctx.arc((b - 1) * 12, -barrier.height / 2 + b * 28, 24, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-3, -barrier.height / 2, 6, barrier.height);
                } else if (barrier.type === 'workshopRail') {
                    const wobble = Math.sin(Date.now() * 0.003 + (barrier.waveOffset || 0)) * 4;
                    ctx.fillStyle = '#ff8fb1';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2 + wobble, barrier.width, barrier.height);
                }
                
                ctx.restore();
            });
        }

        function drawBomber() {
            if (!bomber) return;
            ctx.save();
            ctx.translate(bomber.x, bomber.y);
            ctx.fillStyle = '#2b3e4f';
            ctx.beginPath();
            ctx.moveTo(-bomber.width / 2, bomber.height / 2);
            ctx.lineTo(0, -bomber.height / 2);
            ctx.lineTo(bomber.width / 2, bomber.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#1b2a35';
            ctx.fillRect(-20, -10, 40, 20);
            
            const glow = 0.5 + Math.sin(bomber.stealthPulse) * 0.4;
            ctx.strokeStyle = `rgba(173,216,230,${glow})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, bomber.width / 2, Math.PI, 0);
            ctx.stroke();
            ctx.restore();

            // Status text
            ctx.save();
            ctx.fillStyle = '#DAA520';
            ctx.font = '16px Fraunces';
            ctx.textAlign = 'center';
            if (bomber.graceTimer > 0) {
                ctx.fillText('Stealth bomber incoming...', bomber.x, bomber.y - 60);
            } else if (bomber.isReloading) {
                const secondsLeft = Math.ceil((bomber.reloadFrames - bomber.reloadTimer) / 60);
                ctx.fillText(`Reloading bomb bay: ${secondsLeft}s`, bomber.x, bomber.y - 60);
            } else if (!bomber.activeBomb) {
                ctx.fillText('Bomb bay ready!', bomber.x, bomber.y - 60);
            }
            ctx.restore();
        }

        function drawBomberBombs() {
            bomberBombs.forEach(bomb => {
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#888';
                ctx.beginPath();
                ctx.moveTo(-5, -15);
                ctx.lineTo(-5, 15);
                ctx.moveTo(5, -15);
                ctx.lineTo(5, 15);
                ctx.stroke();
                ctx.restore();
                
                if (!bomb.exploded) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,69,0,0.2)';
                    ctx.setLineDash([6, 10]);
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, bomb.explosionRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function drawAuroraWaves() {
            auroraWaves.forEach(wave => {
                ctx.save();
                ctx.strokeStyle = `rgba(126,255,212,${wave.alpha})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 12]);
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            ctx.setLineDash([]);
        }

        function drawAuroraBlasts() {
            auroraBlasts.forEach(blast => {
                ctx.save();
                const innerRadius = Math.max(10, blast.radius - 40);
                const outerRadius = blast.radius + 80;
                const gradient = ctx.createRadialGradient(
                    blast.x,
                    blast.y,
                    innerRadius,
                    blast.x,
                    blast.y,
                    outerRadius
                );
                gradient.addColorStop(0, `rgba(94,241,255,${blast.alpha * 0.4})`);
                gradient.addColorStop(0.5, `rgba(168,85,255,${blast.alpha * 0.6})`);
                gradient.addColorStop(1, 'rgba(8,17,32,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(blast.x, blast.y, outerRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(212,255,249,${blast.alpha})`;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(blast.x, blast.y, blast.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawRoamingAuroras() {
            if (!roamingAuroras.length) return;
            const time = Date.now() * 0.0005;
            roamingAuroras.forEach(sprite => {
                const gradient = ctx.createRadialGradient(
                    sprite.x,
                    sprite.y,
                    sprite.radius * 0.2,
                    sprite.x,
                    sprite.y,
                    sprite.radius
                );
                gradient.addColorStop(0, sprite.innerColor);
                gradient.addColorStop(1, sprite.outerColor);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    sprite.x,
                    sprite.y,
                    sprite.radius * 0.8,
                    sprite.radius,
                    Math.sin(time + sprite.wobbleOffset) * 0.4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
        }

        function drawProjectiles() {
            bossProjectiles.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                
                if (proj.type === 'bullet' || proj.isHunter) {
                    // Hunter bullet rendered as a glowing flare round
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const flicker = 1 + Math.sin((Date.now() + proj.x + proj.y) * 0.02) * 0.15;
                    const tailLength = Math.max(45, proj.size * 4) * flicker;
                    ctx.rotate(angle);
                    
                    // Bright tail streak
                    ctx.globalCompositeOperation = 'lighter';
                    const tailGradient = ctx.createLinearGradient(0, 0, -tailLength, 0);
                    tailGradient.addColorStop(0, 'rgba(255,240,200,0.95)');
                    tailGradient.addColorStop(0.4, 'rgba(255,130,70,0.8)');
                    tailGradient.addColorStop(1, 'rgba(120,30,0,0)');
                    ctx.strokeStyle = tailGradient;
                    ctx.lineWidth = Math.max(3, proj.size * 0.7);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-tailLength, 0);
                    ctx.stroke();
                    
                    // Flare core
                    ctx.shadowColor = 'rgba(255,160,80,0.8)';
                    ctx.shadowBlur = 12;
                    const flareGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, proj.size * 1.2);
                    flareGradient.addColorStop(0, 'rgba(255,255,255,0.95)');
                    flareGradient.addColorStop(0.3, 'rgba(255,230,180,0.9)');
                    flareGradient.addColorStop(0.9, 'rgba(255,90,20,0.2)');
                    ctx.fillStyle = flareGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, proj.size * 1.2, proj.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nose cone glint
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-proj.size * 0.2, -proj.size * 0.35);
                    ctx.lineTo(proj.size * 0.8, 0);
                    ctx.lineTo(-proj.size * 0.2, proj.size * 0.35);
                    ctx.stroke();
                } else if (proj.type === 'auroraStreak') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const tailLength = proj.trailLength || 140;
                    ctx.rotate(angle);
                    ctx.lineWidth = 6;
                    const gradient = ctx.createLinearGradient(0, 0, -tailLength, 0);
                    gradient.addColorStop(0, proj.color || '#7FFFD4');
                    gradient.addColorStop(0.7, 'rgba(168,85,255,0.6)');
                    gradient.addColorStop(1, 'rgba(8,16,32,0)');
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-tailLength, 0);
                    ctx.stroke();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'aurora') {
                    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, proj.size);
                    gradient.addColorStop(0, proj.color || '#7FFFD4');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'auroraNova') {
                    const pulse = 1 + Math.sin(Date.now() * 0.01 + proj.life * 0.05) * 0.15;
                    const radius = proj.size * pulse;
                    const gradient = ctx.createRadialGradient(0, 0, radius * 0.4, 0, 0, radius);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                    gradient.addColorStop(0.5, proj.color || 'rgba(126,255,212,0.8)');
                    gradient.addColorStop(1, 'rgba(8,17,32,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Pie slice projectile
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, proj.size, 0, Math.PI / 3);
                    ctx.fill();
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawParadeConfetti() {
            paradeConfetti.forEach(piece => {
                ctx.globalAlpha = Math.max(0, piece.life);
                ctx.fillStyle = piece.color;
                ctx.fillRect(piece.x, piece.y, 4, 4);
            });
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            if (roamingAuroras.length) {
                drawRoamingAuroras();
            }
            
            if (gameState === 'playing' || gameState === 'boss') {
                drawBarriers(); // Draw barriers behind other elements
                apples.forEach(drawApple);
                if (currentLevel === 4) {
                    drawBomberBombs();
                }
                drawProjectiles();
                if (auroraBlasts.length) {
                    drawAuroraBlasts();
                }
                if (auroraWaves.length) {
                    drawAuroraWaves();
                }
                drawPeckIndicator(); // Draw peck range indicator behind turkey
                drawTurkey();
                if (boss) drawBoss();
                if (hunter) drawHunter();
                if (currentLevel === 4 && bomber) {
                    drawBomber();
                }
                drawParticles();
                drawParadeConfetti();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        updateLeftoverUI();
        updateUI();
        draw();
    </script>
</body>
</html>
