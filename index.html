<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turkey Evolution - Thanksgiving Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;700;900&family=Caveat:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --autumn-orange: #D2691E;
            --harvest-gold: #DAA520;
            --pumpkin: #FF7518;
            --cranberry: #9F1D35;
            --turkey-brown: #8B4513;
            --sage-green: #9DC183;
            --cream: #FFFDD0;
            --bark: #3D2914;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Fraunces', serif;
            background: linear-gradient(135deg, #2D1B0E 0%, #4A2C17 50%, #1A0F05 100%);
            min-height: 100vh;
            min-height: 100dvh;
            margin: 0;
            display: block;
            overflow: hidden;
        }

        .game-container {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: linear-gradient(180deg, #87CEEB 0%, #FDB347 30%, #D2691E 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .level-display {
            font-family: 'Caveat', cursive;
            font-size: 28px;
            color: var(--cream);
            text-shadow: 3px 3px 0 var(--bark), -1px -1px 0 var(--bark);
            background: linear-gradient(135deg, var(--cranberry), var(--turkey-brown));
            padding: 8px 20px;
            border-radius: 30px;
            border: 3px solid var(--harvest-gold);
        }

        .score-display {
            font-size: 22px;
            color: var(--harvest-gold);
            text-shadow: 2px 2px 0 var(--bark);
        }

        .speed-boost-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(61, 41, 20, 0.85);
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid var(--harvest-gold);
            font-size: 16px;
            color: var(--cream);
            transition: all 0.3s ease;
        }

        .speed-boost-indicator.ready {
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.7), 0 0 24px rgba(255, 165, 0, 0.5), inset 0 0 8px rgba(255, 215, 0, 0.3);
            animation: speed-ready-pulse 1.2s ease-in-out infinite;
        }

        .speed-boost-indicator.active {
            border-color: #b11226;
            background: linear-gradient(135deg, rgba(177, 18, 38, 0.9), rgba(139, 0, 0, 0.8));
            box-shadow: 0 0 16px rgba(255, 50, 50, 0.8), 0 0 32px rgba(177, 18, 38, 0.5);
            animation: speed-active-glow 0.4s ease-in-out infinite alternate;
        }

        .speed-boost-indicator.cooldown {
            opacity: 0.6;
            border-color: #666;
        }

        @keyframes speed-ready-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 12px rgba(255, 215, 0, 0.7), 0 0 24px rgba(255, 165, 0, 0.5);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.9), 0 0 40px rgba(255, 165, 0, 0.7);
            }
        }

        @keyframes speed-active-glow {
            0% {
                box-shadow: 0 0 16px rgba(255, 50, 50, 0.8), 0 0 32px rgba(177, 18, 38, 0.5);
            }
            100% {
                box-shadow: 0 0 24px rgba(255, 100, 100, 1), 0 0 48px rgba(177, 18, 38, 0.8);
            }
        }

        .speed-icon {
            font-size: 18px;
        }

        .speed-count {
            font-weight: 700;
            letter-spacing: 0.05em;
        }

        .xp-bar-container {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            max-width: 80%;
            height: 25px;
            background: var(--bark);
            border-radius: 15px;
            border: 3px solid var(--harvest-gold);
            overflow: hidden;
            box-shadow: inset 0 3px 10px rgba(0,0,0,0.5);
        }

        .xp-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--sage-green), var(--pumpkin), var(--cranberry));
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--pumpkin);
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            color: var(--cream);
            text-shadow: 1px 1px 2px var(--bark);
        }

        /* Mobile UI adjustments */
        @media (max-width: 600px) {
            .ui-overlay {
                padding: 8px 12px;
            }
            
            .level-display {
                font-size: 18px;
                padding: 5px 12px;
                border-width: 2px;
            }
            
            .score-display {
                font-size: 18px;
            }

            .speed-boost-indicator {
                padding: 4px 10px;
                font-size: 14px;
            }

            .speed-icon {
                font-size: 14px;
            }
            
            .xp-bar-container {
                height: 20px;
                bottom: 10px;
            }
            
            .xp-text {
                font-size: 11px;
            }
        }

        .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(29, 15, 5, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: safe center;
            z-index: 100;
            overflow-y: auto;
            padding: 20px 10px;
            -webkit-overflow-scrolling: touch;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-family: 'Caveat', cursive;
            font-size: 64px;
            color: var(--pumpkin);
            text-shadow: 4px 4px 0 var(--cranberry), 8px 8px 0 var(--bark);
            margin-bottom: 20px;
            animation: wobble 2s ease-in-out infinite;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }

        .subtitle {
            font-size: 24px;
            color: var(--harvest-gold);
            margin-bottom: 30px;
        }

        .version-badge {
            font-size: 14px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--cream);
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px 14px;
            border-radius: 999px;
            margin-bottom: 22px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .instructions {
            color: var(--cream);
            font-size: 18px;
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
            margin-bottom: 30px;
            padding: 0 15px;
        }

        .btn {
            font-family: 'Fraunces', serif;
            font-size: 24px;
            font-weight: 700;
            padding: 15px 50px;
            background: linear-gradient(135deg, var(--pumpkin), var(--autumn-orange));
            color: var(--cream);
            border: 4px solid var(--harvest-gold);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 2px 2px 0 var(--bark);
            box-shadow: 0 6px 0 var(--bark), 0 10px 20px rgba(0,0,0,0.3);
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 var(--bark), 0 15px 30px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 var(--bark), 0 5px 10px rgba(0,0,0,0.3);
        }

        .level-name {
            font-family: 'Caveat', cursive;
            font-size: 48px;
            color: var(--sage-green);
            text-shadow: 3px 3px 0 var(--bark);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .boss-name {
            color: var(--cranberry);
            font-size: 56px;
        }

        .turkey-emoji {
            font-size: 80px;
            animation: bounce 0.5s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--harvest-gold);
            font-size: 14px;
            opacity: 0.8;
        }

        /* Touch indicator for mobile */
        .touch-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid var(--harvest-gold);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 50;
            background: radial-gradient(circle, rgba(218,165,32,0.3) 0%, transparent 70%);
        }

        .touch-indicator.visible {
            opacity: 1;
        }

        .touch-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: var(--harvest-gold);
            border-radius: 50%;
        }

        /* Mobile screen adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 36px;
                text-shadow: 2px 2px 0 var(--cranberry), 4px 4px 0 var(--bark);
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .version-badge {
                font-size: 12px;
                margin-bottom: 16px;
            }

            .instructions {
                font-size: 14px;
                line-height: 1.5;
                margin-bottom: 20px;
                max-width: 90%;
            }

            .btn {
                font-size: 18px;
                padding: 12px 35px;
                border-width: 3px;
            }

            .level-name {
                font-size: 32px;
            }

            .boss-name {
                font-size: 36px;
            }

            .turkey-emoji {
                font-size: 50px;
            }

            .touch-indicator {
                width: 60px;
                height: 60px;
                border-width: 3px;
            }

            .touch-indicator::after {
                width: 14px;
                height: 14px;
            }
        }

        @media (max-height: 500px) {
            h1 {
                font-size: 28px;
                margin-bottom: 8px;
            }

            .subtitle {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .instructions {
                font-size: 12px;
                margin-bottom: 12px;
            }

            .turkey-emoji {
                font-size: 40px;
            }

            .btn {
                font-size: 16px;
                padding: 10px 30px;
            }
        }

        /* Extra small height screens (small phones in landscape or very compact screens) */
        @media (max-height: 400px) {
            .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
                justify-content: flex-start;
                padding-top: 10px;
            }

            h1 {
                font-size: 24px;
                margin-bottom: 5px;
            }

            .subtitle {
                font-size: 12px;
                margin-bottom: 8px;
            }

            .instructions {
                font-size: 11px;
                margin-bottom: 10px;
                line-height: 1.3;
            }

            .turkey-emoji {
                font-size: 30px;
            }

            .btn {
                font-size: 14px;
                padding: 8px 25px;
                margin-bottom: 10px;
            }
        }

        /* Ensure button is always tappable and visible */
        .btn {
            min-height: 44px;
            min-width: 120px;
            flex-shrink: 0;
        }

        /* Show/hide controls based on device */
        .mobile-controls {
            display: none;
        }

        .desktop-controls {
            display: inline;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: inline;
            }

            .desktop-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
        
        <!-- Touch indicator for mobile -->
        <div class="touch-indicator" id="touchIndicator"></div>
        
        <div class="ui-overlay">
            <div class="level-display" id="levelDisplay">Level 1: Barn Turkey</div>
            <div class="speed-boost-indicator" id="speedBoostIndicator">
                <span class="speed-icon">‚ö°</span>
                <span class="speed-count" id="speedBoostCount">0/10</span>
            </div>
            <div class="score-display"><span id="scoreIcon" aria-hidden="true">üçé</span> <span id="scoreDisplay">0</span></div>
        </div>
        
        <div class="xp-bar-container">
            <div class="xp-bar" id="xpBar" style="width: 0%"></div>
            <div class="xp-text" id="xpText">0 / 10 XP</div>
        </div>


        <div class="start-screen" id="startScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Turkey Evolution</h1>
            <p class="subtitle">A Thanksgiving Adventure</p>
            <div class="version-badge" id="versionBadge" aria-live="polite"></div>
            <div class="instructions">
                Gobble treats, dodge kitchen chaos, and evolve before dinner.
            </div>
            <button class="btn" onclick="startGame()">Start Gobbling!</button>
        </div>

        <div class="level-up-screen hidden" id="levelUpScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Level Up!</h1>
            <p class="level-name" id="newLevelName">Corn Labyrinth</p>
            <p class="instructions" id="levelDescription">Navigate the twisting corn stalks and find the exit!</p>
            <p class="instructions" id="levelCountdown" aria-live="polite" style="display: none;">Press SPACE or wait 10s for the next level.</p>
            <button class="btn" onclick="continueGame()">Continue</button>
        </div>

        <div class="boss-screen hidden" id="bossScreen">
            <div style="font-size: 80px;" id="bossEmoji">ü•ß</div>
            <h1>Boss Fight!</h1>
            <p class="boss-name" id="bossName">Pumpkin Pie</p>
            <p class="instructions" id="bossInstructions">The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck automatically when you get close enough<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!</p>
            <button class="btn" onclick="startBossFight()">Fight!</button>
        </div>

        <div class="game-over-screen hidden" id="gameOverScreen">
            <div style="font-size: 80px;">üíÄ</div>
            <h1>Game Over!</h1>
            <p class="subtitle" id="deathMessage">The turkey has been caught!</p>
            <p class="instructions">Final Score: <span id="finalScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Try Again</button>
        </div>

        <div class="win-screen hidden" id="winScreen">
            <div style="font-size: 80px;">üèÜ</div>
            <h1>Victory!</h1>
            <p class="level-name">The Turkey Survives Thanksgiving!</p>
            <p class="instructions">You've evolved from a barn turkey to a legendary survivor!<br><br>Final Score: <span id="winScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const touchIndicator = document.getElementById('touchIndicator');
        const gameContainer = document.querySelector('.game-container');
        const bossEmojiEl = document.getElementById('bossEmoji');
        const bossNameEl = document.getElementById('bossName');
        const bossInstructionsEl = document.getElementById('bossInstructions');
        const scoreIconEl = document.getElementById('scoreIcon');
        const levelCountdownEl = document.getElementById('levelCountdown');
        const versionBadgeEl = document.getElementById('versionBadge');
        const speedBoostIndicatorEl = document.getElementById('speedBoostIndicator');
        const speedBoostCountEl = document.getElementById('speedBoostCount');

        const VERSION = Object.freeze({
            major: 1,
            minor: 1,
            patch: 0,
            codename: 'Harvest Escape',
            toString() {
                return `${this.major}.${this.minor}.${this.patch}`;
            }
        });

        function formatVersionLabel() {
            const base = `v${VERSION.toString()}`;
            return VERSION.codename ? `${base} ¬∑ ${VERSION.codename}` : base;
        }

        if (versionBadgeEl) {
            versionBadgeEl.textContent = formatVersionLabel();
            versionBadgeEl.setAttribute('aria-label', `Game version ${VERSION.toString()}`);
        }

        window.TURKEY_EVOLUTION_VERSION = VERSION;

        // Base canvas dimensions (used for game logic)
        let BASE_WIDTH = window.innerWidth || 600;
        let BASE_HEIGHT = window.innerHeight || 800;
        const FLOOR_PADDING = 30;
        const BOMBER_GROUND_BAND_HEIGHT = 140;
        const TEN_SECOND_FRAMES = 10 * 60;
        const HUNTER_RELOAD_FRAMES = TEN_SECOND_FRAMES;
        const BOMBER_RELOAD_FRAMES = TEN_SECOND_FRAMES;
        const PUMPKIN_ATTACK_INTERVAL_FRAMES = 120; // ~2 seconds between pie throws
        const PUMPKIN_SLICE_COUNT = 8;

        const BOSS_TYPES = {
            PUMPKIN: 'pumpkinPie',
            AURORA: 'auroraSpirit'
        };
        const LEVEL_IDS = Object.freeze({
            BARN_TURKEY: 1,
            CORN_MAZE: 2,
            PUMPKIN_PIE_BOSS: 3,
            BARN_ESCAPE: 4,
            HUNTER_SIEGE: 5,
            WOOD_ESCAPE: 6,
            STEALTH_BOMBER: 7,
            SPACE_ESCAPE: 8,
            NORTHERN_LIGHTS_BOSS: 9,
            PARADE: 10
        });
        const AURORA_ATTACK_WINDOW_FRAMES = 360;
        const AURORA_RECHARGE_FRAMES = 10 * 60;

        // Game State
        let gameState = 'start'; // start, playing, levelup, boss, gameover, win
        let currentLevel = 1;
        let score = 0;
        let xp = 0;
        let xpNeeded = 10;
        let nextBossType = null;
        let levelCountdownInterval = null;
        let levelCountdownRemaining = 0;

        // Pointer/touch state
        let touchActive = false;
        let touchTarget = null;
        let pointerIndicatorVisible = false;
        let canvasScale = 1;

        // Peck attack state
        let peckCooldown = 0;
        const PECK_COOLDOWN_MAX = 30; // frames between pecks
        const PECK_RANGE = 100; // distance to peck the boss
        const PECK_DAMAGE = 1;
        let isPecking = false;
        let peckAnimTimer = 0;

        // Level definitions
        const levels = {
            [LEVEL_IDS.BARN_TURKEY]: { name: 'Barn Turkey', xpNeeded: 10, bgColor: '#8B4513', description: 'Eat apples in the cozy barn!' },
            [LEVEL_IDS.CORN_MAZE]: { name: 'Corn Labyrinth', xpNeeded: 20, bgColor: '#6b3e12', description: 'Navigate the twisting corn stalks and collect enough treats to complete the level!', isLabyrinth: true },
            [LEVEL_IDS.PUMPKIN_PIE_BOSS]: { name: 'Pumpkin Pie Boss', xpNeeded: 0, bgColor: '#5D3A1A', description: 'Face the pumpkin pie boss and gobble your way to freedom!' },
            [LEVEL_IDS.BARN_ESCAPE]: { name: 'Barn Labyrinth', xpNeeded: 20, bgColor: '#228B22', description: 'Find your way through the haybale maze and collect enough treats to complete the level!', isLabyrinth: true },
            [LEVEL_IDS.HUNTER_SIEGE]: { name: 'Hunter Boss', xpNeeded: 20, bgColor: '#2F4F4F', description: 'Dodge bullets from the hunter AND nets from his wife! Get trapped and peck to escape! Hide behind barriers!' },
            [LEVEL_IDS.WOOD_ESCAPE]: { name: 'Forest Labyrinth', xpNeeded: 20, bgColor: '#1f2a1c', description: 'The dark woods twist and turn. Collect enough treats to escape!', isLabyrinth: true },
            [LEVEL_IDS.STEALTH_BOMBER]: { name: 'Stealth Bomber Boss', xpNeeded: 3, bgColor: '#0f1a2b', description: 'The runway is exposed. Survive three bombing runs.' },
            [LEVEL_IDS.SPACE_ESCAPE]: { name: 'Space Labyrinth', xpNeeded: 20, bgColor: '#040c2c', description: 'Navigate through the cosmic maze and collect enough treats to warp home!', isLabyrinth: true },
            [LEVEL_IDS.NORTHERN_LIGHTS_BOSS]: { name: 'Northern Lights Boss', xpNeeded: 1, bgColor: '#082137', description: 'The aurora beast awakens. Pineapples fuel your survival.' },
            [LEVEL_IDS.PARADE]: { name: 'Victory Parade', xpNeeded: 6, bgColor: '#320b28', description: 'Run through the Thanksgiving parade! Collect treats from the cheering crowd!' }
        };
        const MAX_LEVEL = Object.keys(levels).length;

        const LEFTOVER_CONFIG = Object.freeze({
            scrapsPerFruit: 1,
            cranberry: {
                cost: 10,
                duration: 6 * 60,
                cooldown: 8 * 60,
                speedBoost: 1.6
            }
        });

        const TURKEY_SIZE_PRESETS = Object.freeze({
            default: { width: 60, height: 50 }
        });

        // Turkey
        const turkey = {
            x: BASE_WIDTH / 2,
            y: BASE_HEIGHT / 2,
            width: TURKEY_SIZE_PRESETS.default.width,
            height: TURKEY_SIZE_PRESETS.default.height,
            speed: 5,
            mouthOpen: 0,
            direction: 1,
            evolution: 1,
            legPhase: 0,
            legSwingAmount: 0
        };

        function applyTurkeySizeForLevel(levelOverride = currentLevel) {
            const preset = TURKEY_SIZE_PRESETS.default;
            turkey.width = preset.width;
            turkey.height = preset.height;
        }

        function getTurkeyVerticalBounds() {
            const minY = turkey.height / 2;
            const maxY = BASE_HEIGHT - turkey.height / 2 - FLOOR_PADDING;
            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER && gameState === 'playing') {
                const groundTop = Math.max(minY, BASE_HEIGHT - BOMBER_GROUND_BAND_HEIGHT);
                return { minY: groundTop, maxY };
            }
            return { minY, maxY };
        }

        function clampTurkeyToBounds() {
            const horizontalMin = turkey.width / 2;
            const horizontalMax = BASE_WIDTH - turkey.width / 2;
            turkey.x = Math.max(horizontalMin, Math.min(horizontalMax, turkey.x));
            const { minY, maxY } = getTurkeyVerticalBounds();
            turkey.y = Math.max(minY, Math.min(maxY, turkey.y));
        }

        function placeTurkeyOnGroundBand() {
            const { minY, maxY } = getTurkeyVerticalBounds();
            turkey.y = (minY + maxY) / 2;
        }

        // Apples
        let apples = [];

        // Boss
        let boss = null;
        let bossProjectiles = [];

        function isAuroraBossVulnerable() {
            return (
                boss &&
                boss.type === BOSS_TYPES.AURORA &&
                boss.isRecharging &&
                boss.graceTimer <= 0
            );
        }

        // Hunter (Level 3)
        let hunter = null;
        let hunterWife = null;
        let thrownNets = [];
        let thrownAxes = [];
        
        // Net trap state
        const netTrap = {
            isTrapped: false,
            trapTimer: 0,
            trapDuration: 5 * 60, // 5 seconds at 60fps
            trapX: 0,
            trapY: 0,
            axeThrown: false
        };

        // Bomber (Level 4)
        let bomber = null;
        let bomberBombs = [];
        let bomberRoundsSurvived = 0;
        
        // Maze treat spawn timer
        let mazeTreatSpawnTimer = 0;
        const MAZE_TREAT_SPAWN_INTERVAL = 90; // Spawn new treat every 1.5 seconds in maze levels

        // Northern lights effects
        let auroraWaves = [];
        let auroraBlasts = [];
        let roamingAuroras = [];

        // Barriers for hiding
        let barriers = [];

        // Particles
        let particles = [];
        let paradeFloat = null;
        let paradeConfetti = [];

        const leftoverBuffs = {
            scraps: 0,
            cranberry: { activeTimer: 0, cooldownTimer: 0 }
        };
        function isBossFightActive() {
            return gameState === 'boss';
        }
        function isAbilityEnabled(buffKey) {
            return buffKey === 'cranberry';
        }
        let leftoverUIFrame = 0;

        // Input
        const keys = {};

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;

            if (e.code === 'Space') {
                if (gameState === 'levelup') {
                    e.preventDefault();
                    continueGame();
                    return;
                }

                if (gameState === 'boss' || gameState === 'playing') {
                    e.preventDefault();
                    activateContextAbility();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });
        
        // Peck attack function
        function tryPeckAttack() {
            if (peckCooldown > 0) return;
            if (gameState !== 'boss' || !boss) return;
            if (boss.type === BOSS_TYPES.AURORA && !isAuroraBossVulnerable()) return;
            
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            
            if (distToBoss < PECK_RANGE + bossRadius) {
                // Successful peck!
                isPecking = true;
                peckAnimTimer = 15;
                peckCooldown = PECK_COOLDOWN_MAX;
                
                // Damage boss
                const damage = boss.type === BOSS_TYPES.AURORA ? PECK_DAMAGE + 1 : PECK_DAMAGE;
                boss.health -= damage;
                
                // Visual feedback
                const hitColor = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FF7518';
                spawnParticles(boss.x, boss.y, hitColor, 12);
                spawnParticles(turkey.x + turkey.direction * 30, turkey.y - 10, '#FFD700', 8);
                
                // Knockback effect on boss
                if (boss.type !== BOSS_TYPES.AURORA) {
                    boss.x += (boss.x - turkey.x) * 0.1;
                }
                
                if (boss.health <= 0) {
                    const primaryBurst = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FFD700';
                    const secondaryBurst = boss.type === BOSS_TYPES.AURORA ? '#a855ff' : '#FF7518';
                    spawnParticles(boss.x, boss.y, primaryBurst, 30);
                    spawnParticles(boss.x, boss.y, secondaryBurst, 20);
                    if (boss.type !== BOSS_TYPES.AURORA) {
                        spawnParticles(boss.x, boss.y, '#FFFAF0', 15);
                    }
                    boss = null;
                    levelUp();
                }
                
                updateUI();
            } else {
                // Out of range - still show peck animation but no damage
                isPecking = true;
                peckAnimTimer = 10;
                peckCooldown = PECK_COOLDOWN_MAX / 2; // Shorter cooldown for missed peck
                spawnParticles(turkey.x + turkey.direction * 40, turkey.y - 5, '#FFA500', 3);
            }
        }

        // Pointer/touch helpers
        function getPointerPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (clientX - rect.left) / canvasScale,
                y: (clientY - rect.top) / canvasScale
            };
        }

        function updateTouchIndicator(clientX, clientY) {
            const rect = gameContainer.getBoundingClientRect();
            const indicatorSize = touchIndicator.offsetWidth || 80;
            const offset = indicatorSize / 2;
            touchIndicator.style.left = (clientX - rect.left - offset) + 'px';
            touchIndicator.style.top = (clientY - rect.top - offset) + 'px';
        }

        function startPointerControl(clientX, clientY, showIndicator = false) {
            touchActive = true;
            touchTarget = getPointerPos(clientX, clientY);
            pointerIndicatorVisible = showIndicator;
            if (showIndicator) {
                touchIndicator.classList.add('visible');
                updateTouchIndicator(clientX, clientY);
            }
        }

        function movePointerControl(clientX, clientY, showIndicator = false) {
            if (!touchActive) return;
            touchTarget = getPointerPos(clientX, clientY);
            if (showIndicator || pointerIndicatorVisible) {
                pointerIndicatorVisible = true;
                touchIndicator.classList.add('visible');
                updateTouchIndicator(clientX, clientY);
            }
        }

        function endPointerControl() {
            touchActive = false;
            touchTarget = null;
            if (pointerIndicatorVisible) {
                pointerIndicatorVisible = false;
                touchIndicator.classList.remove('visible');
            }
        }

        // Double-press detection for ability activation
        let lastTapTime = 0;
        const DOUBLE_TAP_DELAY = 300; // ms

        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (gameState !== 'playing' && gameState !== 'boss') return;
            activateContextAbility();
        });

        // Touch events for guiding movement
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'playing' && gameState !== 'boss') return;
            
            const touch = e.touches[0];
            const currentTime = Date.now();
            
            // Check for double-tap
            if (currentTime - lastTapTime < DOUBLE_TAP_DELAY) {
                activateContextAbility();
                lastTapTime = 0; // Reset to prevent triple-tap triggering
            } else {
                lastTapTime = currentTime;
            }
            
            startPointerControl(touch.clientX, touch.clientY, true);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive) return;
            
            const touch = e.touches[0];
            movePointerControl(touch.clientX, touch.clientY, true);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                movePointerControl(touch.clientX, touch.clientY, true);
                return;
            }
            endPointerControl();
        }, { passive: false });

        canvas.addEventListener('touchcancel', () => {
            endPointerControl();
        });

        const mouseMoveHandler = (event) => {
            movePointerControl(event.clientX, event.clientY);
        };

        const mouseUpHandler = () => {
            endPointerControl();
            window.removeEventListener('mousemove', mouseMoveHandler);
            window.removeEventListener('mouseup', mouseUpHandler);
        };

        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (gameState !== 'playing' && gameState !== 'boss') return;
            e.preventDefault();
            startPointerControl(e.clientX, e.clientY);
            window.addEventListener('mousemove', mouseMoveHandler);
            window.addEventListener('mouseup', mouseUpHandler);
        });

        // Handle window resize for responsive canvas
        function resizeCanvas() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            gameContainer.style.width = viewportWidth + 'px';
            gameContainer.style.height = viewportHeight + 'px';
            
            BASE_WIDTH = viewportWidth;
            BASE_HEIGHT = viewportHeight;
            canvas.width = viewportWidth;
            canvas.height = viewportHeight;
            canvas.style.width = viewportWidth + 'px';
            canvas.style.height = viewportHeight + 'px';
            canvasScale = 1;

            // Ensure turkey stays in bounds after resize
            clampTurkeyToBounds();
            if (hunter) {
                hunter.patrolBounds = getHunterPatrolBounds();
            }

            if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS || (boss && boss.type === BOSS_TYPES.AURORA) || nextBossType === BOSS_TYPES.AURORA) {
                ensureAuroraAmbience(true);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function configureBossScreen(type) {
            if (type === BOSS_TYPES.AURORA) {
                bossEmojiEl.textContent = 'üåå';
                bossNameEl.textContent = 'Northern Light Monster';
                bossInstructionsEl.innerHTML = 'The Aurora Beast awakens!<br>üåå Dodge aurora volleys when it attacks<br>üå≤ Hide behind the glowing trees<br>üçç Pineapples fuel scraps but can\'t hurt it<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>üí• It unleashes a mega blast after recharging ‚Äî stay mobile!';
            } else {
                bossEmojiEl.textContent = 'ü•ß';
                bossNameEl.textContent = 'Pumpkin Pie';
                bossInstructionsEl.innerHTML = 'The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck automatically when you get close enough<br>‚ö° Trigger your Speed Boost with <span class="desktop-controls">SPACE or double-click</span><span class="mobile-controls">double-tap</span><br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!';
            }
        }

        function queueBossFight(type) {
            nextBossType = type;
            configureBossScreen(type);
            if (type === BOSS_TYPES.AURORA) {
                ensureAuroraAmbience();
            }
            document.getElementById('bossScreen').classList.remove('hidden');
            gameState = 'boss'; // boss intro state
        }

        function clearLevelCountdown() {
            if (levelCountdownInterval !== null) {
                clearInterval(levelCountdownInterval);
                levelCountdownInterval = null;
            }
            levelCountdownRemaining = 0;
            if (levelCountdownEl) {
                levelCountdownEl.style.display = 'none';
            }
        }

        function startLevelCountdown() {
            if (!levelCountdownEl) return;
            clearLevelCountdown();
            levelCountdownRemaining = 10;
            levelCountdownEl.style.display = 'block';
            levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
            levelCountdownInterval = setInterval(() => {
                if (gameState !== 'levelup') {
                    clearLevelCountdown();
                    return;
                }
                levelCountdownRemaining--;
                if (levelCountdownRemaining <= 0) {
                    clearInterval(levelCountdownInterval);
                    levelCountdownInterval = null;
                    levelCountdownEl.textContent = 'Starting next level...';
                    if (gameState === 'levelup') {
                        continueGame();
                    }
                } else {
                    levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
                }
            }, 1000);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            resetLeftovers();
            gameState = 'playing';
            resetLevel();
            gameLoop();
        }

        function continueGame() {
            if (gameState !== 'levelup') return;
            clearLevelCountdown();
            document.getElementById('levelUpScreen').classList.add('hidden');
            gameState = 'playing';
            resetLevel();
        }

        function startBossFight() {
            document.getElementById('bossScreen').classList.add('hidden');
            initBoss(nextBossType || BOSS_TYPES.PUMPKIN);
            nextBossType = null;
            gameState = 'boss';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            clearLevelCountdown();
            currentLevel = 1;
            score = 0;
            xp = 0;
            turkey.evolution = 1;
            turkey.x = 300;
            turkey.y = 400;
            gameState = 'playing';
            resetLeftovers();
            resetLevel();
        }

        function resetLevel() {
            apples = [];
            particles = [];
            paradeConfetti = [];
            paradeFloats = [];
            paradeBalloons = [];
            paradeSpectators = [];
            bossProjectiles = [];
            bomberBombs = [];
            auroraWaves = [];
            auroraBlasts = [];
            roamingAuroras = [];
            boss = null;
            hunter = null;
            hunterWife = null;
            thrownNets = [];
            thrownAxes = [];
            netTrap.isTrapped = false;
            netTrap.trapTimer = 0;
            netTrap.axeThrown = false;
            bomber = null;
            barriers = [];
            window.mazePaths = []; // Clear maze paths from previous level
            mazeTreatSpawnTimer = 0; // Reset treat spawn timer
            labyrinthExit = null; // Clear labyrinth exit from previous level
            paradeFloat = null;
            xp = 0;
            bomberRoundsSurvived = 0;
            resetLeftovers(); // Reset energy (scraps) at the start of each level
            xpNeeded = (levels[currentLevel] && levels[currentLevel].xpNeeded) || 10;
            turkey.x = 300;
            turkey.y = 400;
            applyTurkeySizeForLevel();
            
            const isBossLevel = currentLevel === LEVEL_IDS.PUMPKIN_PIE_BOSS || currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS;
            const shouldSpawnCollectibles = !isBossLevel;
            let initialCollectibles = 5;
            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                initialCollectibles = 6;
            } else if (currentLevel === LEVEL_IDS.PARADE) {
                initialCollectibles = 4;
            }
            if (shouldSpawnCollectibles) {
                for (let i = 0; i < initialCollectibles; i++) {
                    spawnApple();
                }
            }

            if (currentLevel === LEVEL_IDS.PUMPKIN_PIE_BOSS) {
                queueBossFight(BOSS_TYPES.PUMPKIN);
            } else if (currentLevel === LEVEL_IDS.HUNTER_SIEGE) {
                initHunterEncounter();
            } else if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                spawnBarriersForLevel(LEVEL_IDS.STEALTH_BOMBER);
                initBomberLevel();
                placeTurkeyOnGroundBand();
            } else if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS) {
                spawnBarriersForLevel(LEVEL_IDS.NORTHERN_LIGHTS_BOSS);
                queueBossFight(BOSS_TYPES.AURORA);
                ensureAuroraAmbience(true);
            } else if (currentLevel === LEVEL_IDS.CORN_MAZE) {
                spawnBarriersForLevel(LEVEL_IDS.CORN_MAZE);
                // Position turkey on a path cell (row 12 is center of path row in 25-row maze)
                const cellHeight = BASE_HEIGHT / 25;
                turkey.y = cellHeight * 12 + cellHeight / 2;
            } else if (currentLevel === LEVEL_IDS.PARADE) {
                spawnParadeWorkshop();
                initParadeFloatBuilder();
            } else if (currentLevel === LEVEL_IDS.BARN_ESCAPE) {
                spawnBarriersForLevel(LEVEL_IDS.BARN_ESCAPE);
                // Position turkey on a path cell (row 12 is center of path row in 25-row maze)
                const cellHeight = BASE_HEIGHT / 25;
                turkey.y = cellHeight * 12 + cellHeight / 2;
            } else if (currentLevel === LEVEL_IDS.WOOD_ESCAPE) {
                spawnBarriersForLevel(LEVEL_IDS.WOOD_ESCAPE);
                // Position turkey on a path cell (row 12 is center of path row in 25-row maze)
                const cellHeight = BASE_HEIGHT / 25;
                turkey.y = cellHeight * 12 + cellHeight / 2;
            } else if (currentLevel === LEVEL_IDS.SPACE_ESCAPE) {
                spawnBarriersForLevel(LEVEL_IDS.SPACE_ESCAPE);
                // Position turkey on a path cell (row 12 is center of path row in 25-row maze)
                const cellHeight = BASE_HEIGHT / 25;
                turkey.y = cellHeight * 12 + cellHeight / 2;
            }

            updateUI();
        }
        
        function initHunterEncounter() {
            // Hunter on the left side
            hunter = {
                x: 100,
                y: BASE_HEIGHT / 2,
                width: 50,
                height: 70,
                speed: 0,
                shootTimer: 0,
                graceTimer: 180,
                shotsFired: 0,
                reloadTimer: 0,
                isReloading: false,
                walkSpeed: 1.2,
                patrolDirection: 1,
                wanderAxis: 'y',
                patrolBounds: getHunterPatrolBounds(),
                muzzleFlash: 0,
                animPhase: 0,
                breathePhase: 0,
                lastGunShotTime: 0, // Track when gun was last fired
                lastAxeThrowTime: 0 // Track when axe was last thrown
            };
            
            // Wife on the right side with a net
            hunterWife = {
                x: BASE_WIDTH - 100,
                y: BASE_HEIGHT / 2,
                width: 45,
                height: 65,
                graceTimer: 240, // Slightly longer grace for wife
                throwTimer: 0,
                throwCooldown: 180, // 3 seconds between throws
                isWindingUp: false,
                windupTimer: 0,
                walkSpeed: 0.9,
                patrolDirection: -1,
                wanderAxis: 'y',
                animPhase: Math.PI, // Offset animation from hunter
                breathePhase: 0,
                armSwing: 0
            };
            
            thrownNets = [];
            
            spawnBarriersForLevel(LEVEL_IDS.HUNTER_SIEGE);
            
            // Turkey starts in the middle
            turkey.x = BASE_WIDTH / 2;
            turkey.y = BASE_HEIGHT / 2 + 50;
        }

        function getHunterPatrolBounds() {
            const marginX = Math.max(80, BASE_WIDTH * 0.15);
            const minX = marginX;
            const maxX = Math.max(minX + 40, BASE_WIDTH - marginX);
            const bandY = Math.max(100, BASE_HEIGHT * 0.15);
            const minY = Math.max(120, BASE_HEIGHT / 2 - bandY);
            const maxY = Math.max(minY + 40, Math.min(BASE_HEIGHT - 160, BASE_HEIGHT / 2 + bandY));
            return { minX, maxX, minY, maxY };
        }

        // Calculate obstacle density in a given direction from a point
        function countObstaclesInDirection(fromX, fromY, direction, checkRadius = 150) {
            let count = 0;
            const dirVectors = {
                left: { x: -1, y: 0 },
                right: { x: 1, y: 0 },
                up: { x: 0, y: -1 },
                down: { x: 0, y: 1 }
            };
            const vec = dirVectors[direction];
            if (!vec) return 0;
            
            barriers.forEach(barrier => {
                const dx = barrier.x - fromX;
                const dy = barrier.y - fromY;
                const dist = Math.hypot(dx, dy);
                
                // Check if barrier is in the direction we're looking
                if (dist < checkRadius && dist > 10) {
                    const dotProduct = (dx * vec.x + dy * vec.y) / dist;
                    // Count if the barrier is mostly in this direction (dot product > 0.3)
                    if (dotProduct > 0.3) {
                        count += 1 / (dist / 50 + 0.5); // Closer obstacles count more
                    }
                }
            });
            return count;
        }
        
        // Find the direction with fewest obstacles
        function findLeastObstructedDirection(fromX, fromY) {
            const directions = [
                { axis: 'x', dir: 1, name: 'right' },
                { axis: 'x', dir: -1, name: 'left' },
                { axis: 'y', dir: 1, name: 'down' },
                { axis: 'y', dir: -1, name: 'up' }
            ];
            
            let bestDir = directions[0];
            let lowestCount = Infinity;
            
            directions.forEach(d => {
                const count = countObstaclesInDirection(fromX, fromY, d.name);
                if (count < lowestCount) {
                    lowestCount = count;
                    bestDir = d;
                }
            });
            
            return bestDir;
        }
        
        function beginHunterReload() {
            if (!hunter) return;
            hunter.isReloading = true;
            hunter.reloadTimer = 0;
            hunter.patrolBounds = getHunterPatrolBounds();
            
            // Find direction with least obstacles
            const bestDir = findLeastObstructedDirection(hunter.x, hunter.y);
            hunter.wanderAxis = bestDir.axis;
            hunter.patrolDirection = bestDir.dir;
        }

        function updateHunterPatrol() {
            if (!hunter || !hunter.isReloading) return;
            // Hunter patrols vertically on left side
            const minY = 120;
            const maxY = BASE_HEIGHT - 160;
            const speed = hunter.walkSpeed || 1.2;
            
            hunter.y += speed * hunter.patrolDirection;
            if (hunter.y < minY || hunter.y > maxY) {
                hunter.y = Math.max(minY, Math.min(maxY, hunter.y));
                hunter.patrolDirection *= -1;
            }
            
            // Update animation
            hunter.animPhase += 0.1;
        }
        
        function updateHunterWife() {
            if (!hunterWife || currentLevel !== LEVEL_IDS.HUNTER_SIEGE || gameState !== 'playing') return;
            
            // Wife patrols vertically on right side
            const minY = 120;
            const maxY = BASE_HEIGHT - 160;
            const speed = hunterWife.walkSpeed || 0.9;
            
            hunterWife.y += speed * hunterWife.patrolDirection;
            if (hunterWife.y < minY || hunterWife.y > maxY) {
                hunterWife.y = Math.max(minY, Math.min(maxY, hunterWife.y));
                hunterWife.patrolDirection *= -1;
            }
            
            // Update animation
            hunterWife.animPhase += 0.08;
            hunterWife.breathePhase += 0.03;
            
            // Grace period countdown
            if (hunterWife.graceTimer > 0) {
                hunterWife.graceTimer--;
                return;
            }
            
            // Net throwing logic
            if (hunterWife.isWindingUp) {
                hunterWife.windupTimer++;
                hunterWife.armSwing = Math.min(1, hunterWife.windupTimer / 45);
                
                if (hunterWife.windupTimer >= 60) {
                    // Throw the net!
                    throwNet();
                    hunterWife.isWindingUp = false;
                    hunterWife.windupTimer = 0;
                    hunterWife.armSwing = 0;
                    hunterWife.throwTimer = 0;
                }
            } else {
                hunterWife.throwTimer++;
                if (hunterWife.throwTimer >= hunterWife.throwCooldown) {
                    hunterWife.isWindingUp = true;
                    hunterWife.windupTimer = 0;
                }
            }
        }
        
        function throwNet() {
            if (!hunterWife) return;
            
            // Calculate trajectory to turkey with some lead
            const dx = turkey.x - hunterWife.x;
            const dy = turkey.y - hunterWife.y;
            const dist = Math.hypot(dx, dy);
            const speed = 4;
            
            thrownNets.push({
                x: hunterWife.x - 30,
                y: hunterWife.y,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                rotation: 0,
                rotationSpeed: 0.15,
                size: 50,
                expanding: false,
                expandTimer: 0,
                life: 1
            });
            
            // Visual feedback - spawn particles
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: hunterWife.x - 30,
                    y: hunterWife.y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 1,
                    color: '#8B4513',
                    size: 3
                });
            }
        }
        
        function updateThrownNets() {
            for (let i = thrownNets.length - 1; i >= 0; i--) {
                const net = thrownNets[i];
                
                net.x += net.vx;
                net.y += net.vy;
                net.rotation += net.rotationSpeed;
                
                // Check if net is close to turkey - then expand
                const distToTurkey = Math.hypot(net.x - turkey.x, net.y - turkey.y);
                if (distToTurkey < 100 && !net.expanding) {
                    net.expanding = true;
                    net.vx *= 0.3;
                    net.vy *= 0.3;
                }
                
                if (net.expanding) {
                    net.expandTimer++;
                    net.size = 50 + net.expandTimer * 2;
                    net.life -= 0.01;
                }
                
                // Remove if off screen or expired
                if (net.x < -100 || net.x > BASE_WIDTH + 100 || 
                    net.y < -100 || net.y > BASE_HEIGHT + 100 || net.life <= 0) {
                    thrownNets.splice(i, 1);
                }
            }
        }
        
        function updateNetTrap() {
            if (!netTrap.isTrapped) return;
            
            // Keep turkey trapped in position
            turkey.x = netTrap.trapX;
            turkey.y = netTrap.trapY;
            
            // Throw axe after a longer delay (3 seconds) - gives turkey time to escape
            if (!netTrap.axeThrown && netTrap.trapTimer <= netTrap.trapDuration - 180) {
                throwAxeAtTurkey();
                netTrap.axeThrown = true;
            }
            
            // Update thrown axes
            updateThrownAxes();
            
            // Count down trap timer
            netTrap.trapTimer--;
            
            // Release turkey when timer expires - it pecked through the net!
            if (netTrap.trapTimer <= 0) {
                netTrap.isTrapped = false;
                netTrap.axeThrown = false;
                spawnParticles(turkey.x, turkey.y, '#9DC183', 15); // Green particles for escape
            }
        }
        
        function throwAxeAtTurkey() {
            if (!hunter) return;
            
            // Check if enough time has passed since last gun shot (5 seconds = 300 frames)
            const currentTime = Date.now();
            const timeSinceGunShot = currentTime - hunter.lastGunShotTime;
            if (timeSinceGunShot < 5000) return; // Must wait 5 seconds after gun shot
            
            // Record axe throw time
            hunter.lastAxeThrowTime = currentTime;
            
            // Calculate trajectory to trapped turkey
            const dx = turkey.x - hunter.x;
            const dy = turkey.y - hunter.y;
            const dist = Math.hypot(dx, dy);
            const speed = 6;
            
            thrownAxes.push({
                x: hunter.x + 35,
                y: hunter.y,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                rotation: 0,
                rotationSpeed: 0.3,
                size: 30
            });
            
            // Visual feedback - spawn particles
            for (let i = 0; i < 6; i++) {
                particles.push({
                    x: hunter.x + 35,
                    y: hunter.y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 0.6,
                    decay: 0.03,
                    color: '#8B4513'
                });
            }
        }
        
        function checkAxePathBlocked(axe) {
            // Check if any barrier is between the axe and the turkey
            const axeToTurkeyDx = turkey.x - axe.x;
            const axeToTurkeyDy = turkey.y - axe.y;
            const axeToTurkeyDist = Math.hypot(axeToTurkeyDx, axeToTurkeyDy);
            
            if (axeToTurkeyDist < 1) return false;
            
            // Normalize direction
            const dirX = axeToTurkeyDx / axeToTurkeyDist;
            const dirY = axeToTurkeyDy / axeToTurkeyDist;
            
            // Check each barrier
            for (const barrier of barriers) {
                const barrierDx = barrier.x - axe.x;
                const barrierDy = barrier.y - axe.y;
                const barrierDist = Math.hypot(barrierDx, barrierDy);
                
                // Skip if barrier is further than turkey
                if (barrierDist > axeToTurkeyDist) continue;
                
                // Calculate how close the path passes to the barrier center
                const dot = barrierDx * dirX + barrierDy * dirY;
                if (dot < 0) continue; // Barrier is behind axe
                
                const closestX = axe.x + dirX * dot;
                const closestY = axe.y + dirY * dot;
                
                // Check if the closest point is within the barrier bounds
                const halfW = barrier.width / 2;
                const halfH = barrier.height / 2;
                
                if (closestX > barrier.x - halfW && closestX < barrier.x + halfW &&
                    closestY > barrier.y - halfH && closestY < barrier.y + halfH) {
                    return true; // Path is blocked
                }
            }
            return false;
        }
        
        function updateThrownAxes() {
            for (let i = thrownAxes.length - 1; i >= 0; i--) {
                const axe = thrownAxes[i];
                
                axe.x += axe.vx;
                axe.y += axe.vy;
                axe.rotation += axe.rotationSpeed;
                
                // Check collision with barriers
                let hitBarrier = false;
                for (const barrier of barriers) {
                    if (axe.x > barrier.x - barrier.width / 2 &&
                        axe.x < barrier.x + barrier.width / 2 &&
                        axe.y > barrier.y - barrier.height / 2 &&
                        axe.y < barrier.y + barrier.height / 2) {
                        // Axe hit barrier - blocked!
                        spawnParticles(axe.x, axe.y, '#8B4513', 8);
                        thrownAxes.splice(i, 1);
                        hitBarrier = true;
                        break;
                    }
                }
                if (hitBarrier) continue;
                
                // Check collision with turkey
                const dist = Math.hypot(turkey.x - axe.x, turkey.y - axe.y);
                if (dist < turkey.width / 2 + axe.size / 2) {
                    // Axe hit the trapped turkey!
                    if (handleTurkeyDamage('Hit by an axe!')) {
                        return;
                    }
                    thrownAxes.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (axe.x < -100 || axe.x > BASE_WIDTH + 100 || 
                    axe.y < -100 || axe.y > BASE_HEIGHT + 100) {
                    thrownAxes.splice(i, 1);
                }
            }
        }

        function spawnBarriersForLevel(level) {
            barriers = [];
            if (level === LEVEL_IDS.HUNTER_SIEGE) {
                const hayColumns = [0.18, 0.5, 0.82];
                const hayRows = [0.32, 0.68];
                hayRows.forEach(rowRatio => {
                    hayColumns.forEach(colRatio => {
                        barriers.push({
                            x: BASE_WIDTH * colRatio,
                            y: BASE_HEIGHT * rowRatio,
                            width: 70,
                            height: 45,
                            type: 'haybale'
                        });
                    });
                });

                const rockPositions = [
                    { x: BASE_WIDTH * 0.25, y: BASE_HEIGHT * 0.48 },
                    { x: BASE_WIDTH * 0.75, y: BASE_HEIGHT * 0.48 },
                    { x: BASE_WIDTH * 0.22, y: BASE_HEIGHT * 0.82 },
                    { x: BASE_WIDTH * 0.78, y: BASE_HEIGHT * 0.82 }
                ];
                rockPositions.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: 70,
                        height: 50,
                        type: 'rock'
                    });
                });

            } else if (level === LEVEL_IDS.STEALTH_BOMBER) {
                // Barriers positioned MUCH higher - in the sky area above the turkey's ground band
                // Turkey moves in the bottom ground band, barriers are visual obstacles high above
                const barrierBaseY = BASE_HEIGHT * 0.15; // Very high up - top 15% of screen
                
                // Row of hay bales floating high above
                const hayColumns = [0.12, 0.28, 0.44, 0.60, 0.76, 0.88];
                hayColumns.forEach((ratio, index) => {
                    barriers.push({
                        x: BASE_WIDTH * ratio,
                        y: barrierBaseY + (index % 3) * 50,
                        width: 80,
                        height: 50,
                        type: 'haybale'
                    });
                });

                // Row of rocks/bunkers even higher
                const rockRowY = barrierBaseY + 160;
                const rockColumns = [0.2, 0.4, 0.6, 0.8];
                rockColumns.forEach((ratio, index) => {
                    barriers.push({
                        x: BASE_WIDTH * ratio,
                        y: rockRowY + (index % 2) * 40,
                        width: 90,
                        height: 60,
                        type: 'bunker'
                    });
                });
                
                // Third row of obstacles
                const thirdRowY = barrierBaseY + 280;
                const thirdColumns = [0.15, 0.35, 0.55, 0.75, 0.95];
                thirdColumns.forEach((ratio, index) => {
                    barriers.push({
                        x: BASE_WIDTH * ratio,
                        y: thirdRowY + (index % 2) * 35,
                        width: 70,
                        height: 45,
                        type: index % 2 === 0 ? 'haybale' : 'rock'
                    });
                });

            } else if (level === LEVEL_IDS.NORTHERN_LIGHTS_BOSS) {
                // glowing pine obstacles
                const crystalRings = [
                    { x: BASE_WIDTH / 2 - 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 + 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 - 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 + 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 - 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' },
                    { x: BASE_WIDTH / 2 + 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' }
                ];
                crystalRings.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.type === 'iceWall' ? 70 : 50,
                        height: pos.type === 'iceWall' ? 120 : 100,
                        type: pos.type
                    });
                });
            } else if (level === LEVEL_IDS.CORN_MAZE) {
                // Corn maze with corn stalk walls
                generateEscapeMaze('cornWall', 0.3);
            } else if (level === LEVEL_IDS.BARN_ESCAPE) {
                // Barn escape maze with haybale walls and random door openings
                generateEscapeMaze('haybale', 0.3);
            } else if (level === LEVEL_IDS.WOOD_ESCAPE) {
                // Wood escape maze with tree-like walls and random door openings
                generateEscapeMaze('rock', 0.35);
            } else if (level === LEVEL_IDS.SPACE_ESCAPE) {
                // Space escape maze with rock walls and random door openings
                generateEscapeMaze('rock', 0.4);
            }
        }

        // Labyrinth exit zone for escape levels
        let labyrinthExit = null;

        // Generate labyrinth maze for escape levels - collect treats to complete, no exit
        function generateEscapeMaze(wallType, doorChance = 0.35) {
            barriers = [];
            labyrinthExit = null; // No exit - level completes by collecting treats
            
            // Labyrinth pattern with wider horizontal paths (3 cells tall) to match vertical paths (2 cells wide)
            // 19 columns x 25 rows for better aspect ratio balance
            const mazePattern = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1],
                [1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1],
                [1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1],
                [1,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];
            
            const patternRows = mazePattern.length;
            const patternCols = mazePattern[0].length;
            
            // Full screen scale
            const cellWidth = BASE_WIDTH / patternCols;
            const cellHeight = BASE_HEIGHT / patternRows;
            
            for (let row = 0; row < patternRows; row++) {
                for (let col = 0; col < patternCols; col++) {
                    if (mazePattern[row][col] === 1) {
                        barriers.push({
                            x: col * cellWidth + cellWidth / 2,
                            y: row * cellHeight + cellHeight / 2,
                            width: cellWidth + 2,
                            height: cellHeight + 2,
                            type: wallType,
                            solid: true,
                            waveOffset: (row + col) * 0.15
                        });
                    } else if (mazePattern[row][col] === 2) {
                        // Exit zone at top center
                        labyrinthExit = {
                            x: col * cellWidth + cellWidth / 2,
                            y: row * cellHeight + cellHeight / 2,
                            width: cellWidth * 1.5,
                            height: cellHeight * 1.5,
                            pulsePhase: 0
                        };
                    }
                }
            }
            
            // Store maze paths for apple spawning - only include cells far from walls
            window.mazePaths = [];
            for (let row = 0; row < patternRows; row++) {
                for (let col = 0; col < patternCols; col++) {
                    if (mazePattern[row][col] === 0) {
                        // Check if this cell is surrounded by open paths (not adjacent to walls)
                        // This ensures treats spawn in the center of corridors, not near edges
                        let adjacentWalls = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = row + dr;
                                const nc = col + dc;
                                if (nr < 0 || nr >= patternRows || nc < 0 || nc >= patternCols) {
                                    adjacentWalls++;
                                } else if (mazePattern[nr][nc] === 1) {
                                    adjacentWalls++;
                                }
                            }
                        }
                        // Only include cells with at most 2 adjacent walls (well within open paths)
                        if (adjacentWalls <= 2) {
                            window.mazePaths.push({
                                x: col * cellWidth + cellWidth / 2,
                                y: row * cellHeight + cellHeight / 2
                            });
                        }
                    }
                }
            }
        }

        // Check if turkey reached the labyrinth exit
        function checkLabyrinthExit() {
            if (!labyrinthExit) return false;
            
            const dist = Math.hypot(turkey.x - labyrinthExit.x, turkey.y - labyrinthExit.y);
            return dist < labyrinthExit.width / 2 + turkey.width / 3;
        }

        // Check if current level is a labyrinth level
        function isLabyrinthLevel() {
            const levelData = levels[currentLevel];
            return levelData && levelData.isLabyrinth === true;
        }

        // Parade level state
        let paradeFloats = [];
        let paradeBalloons = [];
        let paradeSpectators = [];
        
        function initParadeFloatBuilder() {
            paradeFloat = {
                partsBuilt: 0,
                partsRequired: levels[LEVEL_IDS.PARADE].xpNeeded,
                stage: 0,
                stageLabels: ['üé∫ Drum Major', 'üé∑ Brass Section', 'ü•Å Percussion', 'üé≠ Dance Troupe', 'üé™ Grand Finale', 'üèÜ VICTORY!'],
                status: 'The crowd goes wild! Collect celebration treats!'
            };
            paradeConfetti = [];
            
            // Initialize parade floats moving across screen
            paradeFloats = [
                { x: -100, y: BASE_HEIGHT - 180, type: 'turkeyFloat', speed: 0.8, width: 120, height: 100 },
                { x: BASE_WIDTH + 200, y: BASE_HEIGHT - 160, type: 'pilgrimFloat', speed: -0.6, width: 100, height: 80 }
            ];
            
            // Initialize floating balloons
            paradeBalloons = [];
            for (let i = 0; i < 8; i++) {
                paradeBalloons.push({
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * BASE_HEIGHT * 0.6 + 50,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -0.3 - Math.random() * 0.3,
                    size: 25 + Math.random() * 20,
                    color: ['#FF6B6B', '#4ECDC4', '#FFE66D', '#95E1D3', '#F38181', '#AA96DA'][i % 6],
                    wobble: Math.random() * Math.PI * 2
                });
            }
            
            // Initialize cheering spectators on sides
            paradeSpectators = [];
            for (let i = 0; i < 12; i++) {
                // Left side spectators
                paradeSpectators.push({
                    x: 30 + Math.random() * 60,
                    y: 150 + i * 50,
                    armPhase: Math.random() * Math.PI * 2,
                    color: ['#FF6347', '#4169E1', '#32CD32', '#FFD700', '#FF69B4'][i % 5]
                });
                // Right side spectators
                paradeSpectators.push({
                    x: BASE_WIDTH - 30 - Math.random() * 60,
                    y: 150 + i * 50,
                    armPhase: Math.random() * Math.PI * 2 + Math.PI,
                    color: ['#FF6347', '#4169E1', '#32CD32', '#FFD700', '#FF69B4'][(i + 2) % 5]
                });
            }
            
            // Spawn confetti continuously
            for (let i = 0; i < 30; i++) {
                spawnConfettiBurst(Math.random() * BASE_WIDTH, -20);
            }
        }

        function incrementParadeFloat() {
            if (!paradeFloat) return;
            paradeFloat.partsBuilt++;
            paradeFloat.stage = Math.min(paradeFloat.stageLabels.length - 1, paradeFloat.partsBuilt);
            const remaining = Math.max(0, paradeFloat.partsRequired - paradeFloat.partsBuilt);
            paradeFloat.status = remaining > 0
                ? `${paradeFloat.stageLabels[paradeFloat.stage]} - ${remaining} more treats!`
                : 'üèÜ PARADE CHAMPION! üèÜ';
            
            // Big celebration burst
            spawnConfettiBurst(turkey.x, turkey.y);
            spawnConfettiBurst(turkey.x - 50, turkey.y - 30);
            spawnConfettiBurst(turkey.x + 50, turkey.y - 30);
        }

        function spawnConfettiBurst(x, y) {
            const colors = ['#ff69b4', '#ffd700', '#7fffd4', '#ff7f50', '#00ff7f', '#ff1493', '#00bfff', '#ff4500'];
            for (let i = 0; i < 15; i++) {
                paradeConfetti.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 5 - 1,
                    life: 1,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3,
                    size: 4 + Math.random() * 4
                });
            }
        }

        function updateParadeConfetti() {
            // Update existing confetti
            for (let i = paradeConfetti.length - 1; i >= 0; i--) {
                const confetti = paradeConfetti[i];
                confetti.x += confetti.vx;
                confetti.y += confetti.vy;
                confetti.vy += 0.08;
                confetti.vx *= 0.99;
                confetti.rotation = (confetti.rotation || 0) + (confetti.rotSpeed || 0);
                confetti.life -= 0.008;
                if (confetti.life <= 0 || confetti.y > BASE_HEIGHT + 50) {
                    paradeConfetti.splice(i, 1);
                }
            }
            
            // Only spawn new confetti if we're in the parade level
            if (currentLevel === LEVEL_IDS.PARADE && gameState === 'playing') {
                // Continuously spawn confetti from top
                if (Math.random() < 0.15) {
                    spawnConfettiBurst(Math.random() * BASE_WIDTH, -10);
                }
                
                // Update parade floats
                paradeFloats.forEach(float => {
                    float.x += float.speed;
                    // Wrap around
                    if (float.speed > 0 && float.x > BASE_WIDTH + 150) {
                        float.x = -150;
                    } else if (float.speed < 0 && float.x < -150) {
                        float.x = BASE_WIDTH + 150;
                    }
                });
                
                // Update balloons
                paradeBalloons.forEach(balloon => {
                    balloon.x += balloon.vx + Math.sin(balloon.wobble) * 0.3;
                    balloon.y += balloon.vy;
                    balloon.wobble += 0.03;
                    
                    // Wrap around
                    if (balloon.y < -50) {
                        balloon.y = BASE_HEIGHT + 50;
                        balloon.x = Math.random() * BASE_WIDTH;
                    }
                    if (balloon.x < -50) balloon.x = BASE_WIDTH + 50;
                    if (balloon.x > BASE_WIDTH + 50) balloon.x = -50;
                });
                
                // Update spectators (waving arms)
                paradeSpectators.forEach(spec => {
                    spec.armPhase += 0.1;
                });
            }
        }

        function spawnParadeWorkshop() {
            barriers = [];
            // No solid barriers in parade - it's an open celebration!
            // The parade route is clear for running
        }

        function initBomberLevel() {
            bomber = {
                x: BASE_WIDTH / 2,
                y: 230, // Slightly lower so it clears the UI overlay
                width: 160,
                height: 50,
                direction: 1,
                speed: 1.5,
                stealthPulse: 0,
                graceTimer: 180,
                isReloading: false,
                reloadTimer: 0,
                reloadFrames: BOMBER_RELOAD_FRAMES, // 10 seconds at ~60fps
                activeBomb: null,
                roundsToSurvive: 3
            };
        }

        function dropBomberBomb() {
            if (!bomber) return;
            const targetX = turkey.x + (Math.random() - 0.5) * 120;
            const bomb = {
                x: bomber.x,
                y: bomber.y + 30,
                vx: (targetX - bomber.x) / 120,
                vy: 1.5,
                gravity: 0.08,
                exploded: false,
                explosionRadius: 120,
                trailTimer: 0
            };
            bomberBombs.push(bomb);
            bomber.activeBomb = bomb;
            bomber.isReloading = true;
            bomber.reloadTimer = 0;
        }

        function updateBomber() {
            if (!bomber || currentLevel !== LEVEL_IDS.STEALTH_BOMBER || gameState !== 'playing') return;
            
            bomber.stealthPulse += 0.02;
            bomber.x += bomber.speed * bomber.direction;
            if (bomber.x < 80 || bomber.x > BASE_WIDTH - 80) {
                bomber.direction *= -1;
            }

            if (bomber.graceTimer > 0) {
                bomber.graceTimer--;
                return;
            }

            if (!bomber.activeBomb && !bomber.isReloading && bomberRoundsSurvived < bomber.roundsToSurvive) {
                dropBomberBomb();
            }

            if (bomber.isReloading) {
                bomber.reloadTimer++;
                if (bomber.reloadTimer >= bomber.reloadFrames) {
                    bomber.isReloading = false;
                    bomber.reloadTimer = 0;
                    bomber.activeBomb = null;
                }
            }
        }

        function resolveBombExplosion(bomb) {
            spawnParticles(bomb.x, bomb.y, '#FFA500', 20);
            spawnParticles(bomb.x, bomb.y, '#FF4500', 20);
            const dist = Math.hypot(turkey.x - bomb.x, turkey.y - bomb.y);
            if (dist < bomb.explosionRadius) {
                const didFail = handleTurkeyDamage('The stealth bomber roasted you!');
                return didFail;
            }
            bomberRoundsSurvived++;
            xp = bomberRoundsSurvived;
            bomber.activeBomb = null;
            if (bomberRoundsSurvived >= bomber.roundsToSurvive) {
                levelUp();
            }
            updateUI();
            return false;
        }

        function updateBomberBombs() {
            if (!bomber || currentLevel !== LEVEL_IDS.STEALTH_BOMBER) return;
            for (let i = bomberBombs.length - 1; i >= 0; i--) {
                const bomb = bomberBombs[i];
                if (!bomb.exploded) {
                    bomb.vy += bomb.gravity;
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    
                    bomb.trailTimer++;
                    if (bomb.trailTimer % 5 === 0) {
                        spawnParticles(bomb.x, bomb.y, '#B0C4DE', 2);
                    }

                    // Barrier collision
                    for (let j = 0; j < barriers.length; j++) {
                        const barrier = barriers[j];
                        if (bomb.x > barrier.x - barrier.width / 2 &&
                            bomb.x < barrier.x + barrier.width / 2 &&
                            bomb.y > barrier.y - barrier.height / 2 &&
                            bomb.y < barrier.y + barrier.height / 2) {
                            bomb.exploded = true;
                            barriers.splice(j, 1);
                            if (resolveBombExplosion(bomb)) return;
                            bomberBombs.splice(i, 1);
                            break;
                        }
                    }

                    if (bomb.y >= BASE_HEIGHT - 80) {
                        bomb.exploded = true;
                        if (resolveBombExplosion(bomb)) return;
                        bomberBombs.splice(i, 1);
                        continue;
                    }
                }
            }
        }

        function initBoss(type = BOSS_TYPES.PUMPKIN) {
            if (type === BOSS_TYPES.AURORA) {
                boss = {
                    type,
                    x: BASE_WIDTH / 2,
                    y: BASE_HEIGHT / 2 - 120,
                    radius: 90,
                    health: 30,
                    maxHealth: 30,
                    attackTimer: 0,
                    graceTimer: 240,
                    pulse: 0,
                    isRecharging: false,
                    rechargeTimer: 0
                };
                ensureAuroraAmbience();
            } else {
                boss = {
                    type: BOSS_TYPES.PUMPKIN,
                    x: 300,
                    y: 150,
                    width: 100,
                    height: 100,
                    health: 16,
                    maxHealth: 16,
                    speed: 2,
                    direction: 1,
                    attackTimer: 0,
                    opacity: 1,
                    shotsThrown: 0,
                    missingSlices: [],
                    currentScale: 1
                };
            }
            
            const corners = [
                { x: 80, y: BASE_HEIGHT - 150 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 150 },
                { x: 80, y: BASE_HEIGHT - 300 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 300 }
            ];
            const randomCorner = corners[Math.floor(Math.random() * corners.length)];
            turkey.x = randomCorner.x;
            turkey.y = randomCorner.y;
            
            apples = [];
            const initialDrops = type === BOSS_TYPES.AURORA ? 6 : 3;
            for (let i = 0; i < initialDrops; i++) {
                spawnApple();
            }
        }

        function getAppleSpawnRange() {
            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                const { minY, maxY } = getTurkeyVerticalBounds();
                const padding = 20;
                const groundMin = Math.max(minY + padding, BASE_HEIGHT - BOMBER_GROUND_BAND_HEIGHT + 10);
                const groundMax = Math.max(groundMin + 1, maxY - 5);
                return { minY: groundMin, maxY: groundMax };
            }
            return { minY: 50, maxY: BASE_HEIGHT - 150 };
        }

        function getAppleCapForLevel() {
            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                return 3;
            }
            return Number.POSITIVE_INFINITY;
        }

        function spawnApple() {
            const maxApples = getAppleCapForLevel();
            if (apples.length >= maxApples) {
                return;
            }
            const size = currentLevel === LEVEL_IDS.PARADE ? 38 : 32;
            
            // Check if we're on a maze level with stored paths
            const isMazeLevel = currentLevel === LEVEL_IDS.CORN_MAZE || 
                               currentLevel === LEVEL_IDS.BARN_ESCAPE || 
                               currentLevel === LEVEL_IDS.WOOD_ESCAPE || 
                               currentLevel === LEVEL_IDS.SPACE_ESCAPE;
            
            // Special handling for stealth bomber - spawn on turkey's horizontal path
            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                const { minY, maxY } = getTurkeyVerticalBounds();
                const turkeyY = (minY + maxY) / 2;
                const candidate = {
                    x: Math.random() * (BASE_WIDTH - 100) + 50,
                    y: turkeyY + (Math.random() - 0.5) * 30, // Small variance around turkey's Y
                    size,
                    rotation: Math.random() * Math.PI * 2,
                    bobOffset: Math.random() * Math.PI * 2
                };
                apples.push(candidate);
                return;
            }
            
            // For maze levels, spawn on paths - only at exact cell centers
            if (isMazeLevel && window.mazePaths && window.mazePaths.length > 0) {
                // Pick a random path location
                let attempts = 0;
                const maxAttempts = 20;
                while (attempts < maxAttempts) {
                    const pathIndex = Math.floor(Math.random() * window.mazePaths.length);
                    const pathCell = window.mazePaths[pathIndex];
                    // Check that no apple is too close to this path cell
                    const tooClose = apples.some(a => Math.hypot(a.x - pathCell.x, a.y - pathCell.y) < 60);
                    if (!tooClose) {
                        apples.push({
                            x: pathCell.x,
                            y: pathCell.y,
                            size,
                            rotation: Math.random() * Math.PI * 2,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                        return;
                    }
                    attempts++;
                }
                // Fallback if we can't find a good spot
                const pathIndex = Math.floor(Math.random() * window.mazePaths.length);
                const pathCell = window.mazePaths[pathIndex];
                apples.push({
                    x: pathCell.x,
                    y: pathCell.y,
                    size,
                    rotation: Math.random() * Math.PI * 2,
                    bobOffset: Math.random() * Math.PI * 2
                });
                return;
            }
            
            // Default spawning for non-maze levels
            let attempts = 0;
            const maxAttempts = 25;
            while (attempts < maxAttempts) {
                const { minY: appleMinY, maxY: appleMaxY } = getAppleSpawnRange();
                const yRange = Math.max(1, appleMaxY - appleMinY);
                const candidate = {
                    x: Math.random() * (BASE_WIDTH - 100) + 50,
                    y: appleMinY + Math.random() * yRange,
                    size,
                    rotation: Math.random() * Math.PI * 2,
                    bobOffset: Math.random() * Math.PI * 2
                };
                if (!isInsideSolidBarrier(candidate.x, candidate.y, size)) {
                    apples.push(candidate);
                    return;
                }
                attempts++;
            }
        }

        function spawnParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 8 + 4,
                    color: color,
                    life: 1
                });
            }
        }

        function spawnRoamingAuroras(count = 8) {
            for (let i = 0; i < count; i++) {
                const fromLeft = Math.random() > 0.5;
                const hue = 180 + Math.random() * 90;
                roamingAuroras.push({
                    x: fromLeft ? -120 - Math.random() * 80 : BASE_WIDTH + 120 + Math.random() * 80,
                    y: Math.random() * (BASE_HEIGHT * 0.6) + 40,
                    radius: 80 + Math.random() * 70,
                    driftSpeed: 0.15 + Math.random() * 0.2,
                    wobbleOffset: Math.random() * Math.PI * 2,
                    innerColor: `hsla(${hue}, 90%, 80%, 0.85)`,
                    outerColor: `hsla(${hue}, 80%, 55%, 0.12)`
                });
            }
        }

        function ensureAuroraAmbience(forceReset = false) {
            if (forceReset) {
                roamingAuroras = [];
            }
            if (roamingAuroras.length === 0) {
                spawnRoamingAuroras(10);
            }
        }

        function triggerAuroraEnergyBlast() {
            if (!boss) return;
            const blastRadius = Math.max(BASE_WIDTH, BASE_HEIGHT) + 400;
            auroraBlasts.push({
                x: boss.x,
                y: boss.y,
                radius: boss.radius,
                maxRadius: blastRadius,
                alpha: 1,
                speed: 9,
                fade: 0.012
            });

            const unsafeRadius = boss.radius + 120;
            const distanceToTurkey = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            if (distanceToTurkey <= unsafeRadius) {
                handleTurkeyDamage('The aurora blast consumed you up close!');
            }

            const novaCount = 18;
            for (let i = 0; i < novaCount; i++) {
                const angle = (Math.PI * 2 * i) / novaCount;
                bossProjectiles.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * 5.5,
                    vy: Math.sin(angle) * 5.5,
                    size: 24,
                    type: 'auroraNova',
                    life: 150,
                    onHitMessage: 'The aurora blast vaporized you!'
                });
            }

            spawnParticles(boss.x, boss.y, '#d4fff9', 30);
            spawnParticles(boss.x, boss.y, '#a855ff', 20);
            auroraWaves.push({
                x: boss.x,
                y: boss.y,
                radius: boss.radius,
                maxRadius: boss.radius + 320,
                alpha: 1
            });
        }

        function updateAuroraBlasts() {
            for (let i = auroraBlasts.length - 1; i >= 0; i--) {
                const blast = auroraBlasts[i];
                blast.radius += blast.speed;
                blast.alpha = Math.max(0, blast.alpha - blast.fade);

                if (blast.radius >= blast.maxRadius || blast.alpha <= 0.02) {
                    auroraBlasts.splice(i, 1);
                }
            }
        }

        function gainLeftoverScraps(amount = LEFTOVER_CONFIG.scrapsPerFruit) {
            leftoverBuffs.scraps += amount;
            updateLeftoverUI();
        }

        function canUseLeftover(buffKey) {
            const config = LEFTOVER_CONFIG[buffKey];
            const buffState = leftoverBuffs[buffKey];
            if (!config || !buffState) return false;
            if (!isAbilityEnabled(buffKey)) return false;
            const affordable = leftoverBuffs.scraps >= config.cost;
            const ready = buffState.activeTimer <= 0 && buffState.cooldownTimer <= 0;
            return affordable && ready;
        }

        function craftCranberryDash() {
            if (!canUseLeftover('cranberry')) {
                return;
            }
            leftoverBuffs.scraps -= LEFTOVER_CONFIG.cranberry.cost;
            leftoverBuffs.cranberry.activeTimer = LEFTOVER_CONFIG.cranberry.duration;
            leftoverBuffs.cranberry.cooldownTimer = LEFTOVER_CONFIG.cranberry.duration + LEFTOVER_CONFIG.cranberry.cooldown;
            spawnParticles(turkey.x, turkey.y, '#b11226', 18);
            updateLeftoverUI();
        }

        function activateContextAbility() {
            // If trapped in net, peck to escape faster
            if (netTrap.isTrapped) {
                peckThroughNet();
                return;
            }
            craftCranberryDash();
        }
        
        function peckThroughNet() {
            if (!netTrap.isTrapped) return;
            
            // Peck animation
            isPecking = true;
            peckAnimTimer = 15;
            
            // Each peck reduces trap time significantly (about 1 second worth)
            netTrap.trapTimer -= 60;
            spawnParticles(turkey.x, turkey.y, '#9DC183', 8); // Green particles for progress
            
            // Check if escaped
            if (netTrap.trapTimer <= 0) {
                netTrap.isTrapped = false;
                netTrap.axeThrown = false;
                spawnParticles(turkey.x, turkey.y, '#9DC183', 20); // Big burst for escape
            }
        }

        function updateLeftoverUI(statusMessage = null) {
            if (!speedBoostIndicatorEl || !speedBoostCountEl) return;
            
            // Hide speed boost indicator on the first level (not possible to earn enough scraps)
            if (currentLevel === LEVEL_IDS.BARN_TURKEY) {
                speedBoostIndicatorEl.style.display = 'none';
                return;
            } else {
                speedBoostIndicatorEl.style.display = 'flex';
            }
            
            const abilityState = leftoverBuffs.cranberry;
            const abilityConfig = LEFTOVER_CONFIG.cranberry;
            const cost = abilityConfig.cost;
            
            // Update the counter display
            speedBoostCountEl.textContent = `${leftoverBuffs.scraps}/${cost}`;
            
            // Update visual state classes
            speedBoostIndicatorEl.classList.remove('ready', 'active', 'cooldown');
            
            if (abilityState.activeTimer > 0) {
                // Speed boost is currently active
                speedBoostIndicatorEl.classList.add('active');
            } else if (abilityState.cooldownTimer > 0) {
                // On cooldown
                speedBoostIndicatorEl.classList.add('cooldown');
            } else if (leftoverBuffs.scraps >= cost) {
                // Ready to use - add pulsing glow effect
                speedBoostIndicatorEl.classList.add('ready');
            }
        }

        function handleTurkeyDamage(reason) {
            gameOver(reason);
            return true;
        }

        function resetLeftovers() {
            leftoverBuffs.scraps = 0;
            leftoverBuffs.cranberry.activeTimer = 0;
            leftoverBuffs.cranberry.cooldownTimer = 0;
            updateLeftoverUI();
        }

        function enforceSolidBarriers() {
            let adjusted = false;
            barriers.forEach(barrier => {
                if (!barrier.solid) return;
                const halfW = barrier.width / 2;
                const halfH = barrier.height / 2;
                const dx = turkey.x - barrier.x;
                const dy = turkey.y - barrier.y;
                const overlapX = turkey.width / 2 + halfW - Math.abs(dx);
                const overlapY = turkey.height / 2 + halfH - Math.abs(dy);
                if (overlapX > 0 && overlapY > 0) {
                    adjusted = true;
                    if (overlapX < overlapY) {
                        turkey.x += dx > 0 ? overlapX : -overlapX;
                    } else {
                        turkey.y += dy > 0 ? overlapY : -overlapY;
                    }
                }
            });
            if (adjusted) {
                turkey.x = Math.max(turkey.width / 2, Math.min(BASE_WIDTH - turkey.width / 2, turkey.x));
                turkey.y = Math.max(turkey.height / 2, Math.min(BASE_HEIGHT - turkey.height / 2 - 30, turkey.y));
            }
        }

        function isInsideSolidBarrier(x, y, padding = 0) {
            return barriers.some(barrier => {
                if (!barrier.solid) return false;
                return (
                    x > barrier.x - barrier.width / 2 - padding &&
                    x < barrier.x + barrier.width / 2 + padding &&
                    y > barrier.y - barrier.height / 2 - padding &&
                    y < barrier.y + barrier.height / 2 + padding
                );
            });
        }

        function updateRoamingAuroras() {
            if (!roamingAuroras.length) return;
            const time = Date.now() * 0.001;
            roamingAuroras.forEach(sprite => {
                const angle = Math.atan2(turkey.y - sprite.y, turkey.x - sprite.x);
                sprite.x += Math.cos(angle) * sprite.driftSpeed;
                sprite.y += Math.sin(angle) * sprite.driftSpeed * 0.6;
                sprite.y += Math.sin(time + sprite.wobbleOffset) * 0.4;

                const distanceToTurkey = Math.hypot(turkey.x - sprite.x, turkey.y - sprite.y);
                if (distanceToTurkey < 60) {
                    sprite.x += Math.cos(angle + Math.PI) * 30;
                    sprite.y += Math.sin(angle + Math.PI) * 30;
                }

                if (sprite.x < -200 || sprite.x > BASE_WIDTH + 200 || sprite.y < -200 || sprite.y > BASE_HEIGHT + 200) {
                    sprite.x = Math.random() > 0.5 ? -120 : BASE_WIDTH + 120;
                    sprite.y = Math.random() * (BASE_HEIGHT * 0.6) + 40;
                }
            });
        }

        function updateUI() {
            if (gameState === 'win' || !levels[currentLevel]) return;
            
            let scoreIcon = 'üçé';
            if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS) {
                scoreIcon = 'üçç';
            } else if (currentLevel === LEVEL_IDS.PARADE) {
                scoreIcon = 'üé™';
            }
            scoreIconEl.textContent = scoreIcon;
            let levelLabel = `Level ${currentLevel}: ${levels[currentLevel].name}`;
            if (currentLevel === LEVEL_IDS.PARADE && paradeFloat) {
                levelLabel += ` ¬∑ ${paradeFloat.stageLabels[paradeFloat.stage]}`;
            }
            document.getElementById('levelDisplay').textContent = levelLabel;
            document.getElementById('scoreDisplay').textContent = score;

            let filled = xp;
            let needed = xpNeeded;
            let label = 'XP';

            // Labyrinth levels show treat collection progress
            if (isLabyrinthLevel()) {
                document.getElementById('xpBar').style.background = 'linear-gradient(90deg, #00ff96, #00d4ff, #00ff96)';
                const treatPercent = xpNeeded > 0 ? Math.min(100, (xp / xpNeeded) * 100) : 0;
                document.getElementById('xpBar').style.width = treatPercent + '%';
                document.getElementById('xpText').textContent = `üç¨ Treats: ${xp} / ${xpNeeded} üç¨`;
                return;
            } else {
                // Reset bar color for non-labyrinth levels
                document.getElementById('xpBar').style.background = '';
            }

            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                filled = bomberRoundsSurvived;
                needed = (bomber && bomber.roundsToSurvive) || xpNeeded;
                label = 'Rounds Survived';
            } else if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS && boss && boss.type === BOSS_TYPES.AURORA) {
                filled = Math.max(0, boss.health);
                needed = boss.maxHealth;
                label = 'Boss HP';
            } else if (currentLevel === LEVEL_IDS.PARADE && paradeFloat) {
                filled = paradeFloat.partsBuilt;
                needed = paradeFloat.partsRequired;
                label = 'Float Parts';
            }

            const xpPercent = needed > 0 ? Math.min(100, (filled / needed) * 100) : 0;
            document.getElementById('xpBar').style.width = xpPercent + '%';
            const displayValue = Math.max(0, Math.round(filled));
            document.getElementById('xpText').textContent = `${label}: ${displayValue} / ${needed}`;
        }

        function update() {
            if (gameState !== 'playing' && gameState !== 'boss') return;

            // Update peck cooldowns
            if (peckCooldown > 0) peckCooldown--;
            if (peckAnimTimer > 0) {
                peckAnimTimer--;
            } else {
                isPecking = false;
            }

            // Update leftover timers
            if (leftoverBuffs.cranberry.activeTimer > 0) leftoverBuffs.cranberry.activeTimer--;
            if (leftoverBuffs.cranberry.cooldownTimer > 0) leftoverBuffs.cranberry.cooldownTimer--;
            leftoverUIFrame++;
            if (leftoverUIFrame % 12 === 0) {
                updateLeftoverUI();
            }

            // Move turkey (skip if trapped in net)
            if (netTrap.isTrapped) {
                // Turkey is trapped - keep in place
                turkey.x = netTrap.trapX;
                turkey.y = netTrap.trapY;
            }
            let keyboardDx = 0;
            let keyboardDy = 0;
            let moveDx = 0;
            let moveDy = 0;
            let speedMultiplier = 1;
            const cranberryBoost = leftoverBuffs.cranberry.activeTimer > 0 ? LEFTOVER_CONFIG.cranberry.speedBoost : 1;
            
            const keyLeft = keys['arrowleft'] || keys['a'] || keys['ArrowLeft'];
            const keyRight = keys['arrowright'] || keys['d'] || keys['ArrowRight'];
            const keyUp = keys['arrowup'] || keys['w'] || keys['ArrowUp'];
            const keyDown = keys['arrowdown'] || keys['s'] || keys['ArrowDown'];
            
            // Stealth bomber level: turkey can only move side to side
            const isBomberLevel = currentLevel === LEVEL_IDS.STEALTH_BOMBER && gameState === 'playing';

            if (keyLeft) keyboardDx -= 1;
            if (keyRight) keyboardDx += 1;
            if (!isBomberLevel) {
                if (keyUp) keyboardDy -= 1;
                if (keyDown) keyboardDy += 1;
            }

            moveDx = keyboardDx;
            moveDy = isBomberLevel ? 0 : keyboardDy;

            if (touchActive && touchTarget) {
                const toTargetX = touchTarget.x - turkey.x;
                const toTargetY = touchTarget.y - turkey.y;
                const distToTarget = Math.hypot(toTargetX, toTargetY);

                if (distToTarget > 6) {
                    moveDx = toTargetX / distToTarget;
                    // For bomber level, only allow horizontal movement
                    moveDy = isBomberLevel ? 0 : (toTargetY / distToTarget);
                    // Use same speed as keyboard for consistent movement
                    speedMultiplier = 1;
                } else if (!keyboardDx && !keyboardDy) {
                    moveDx = 0;
                    moveDy = 0;
                }
            }

            const strideSpeed = turkey.speed * speedMultiplier * cranberryBoost;
            const isMoving = moveDx !== 0 || moveDy !== 0;
            if (isMoving) {
                const len = Math.hypot(moveDx, moveDy);
                moveDx /= len;
                moveDy /= len;
                turkey.x += moveDx * strideSpeed;
                turkey.y += moveDy * strideSpeed;
                turkey.direction = moveDx >= 0 ? 1 : -1;
                
                if (leftoverBuffs.cranberry.activeTimer > 0 && leftoverBuffs.cranberry.activeTimer % 5 === 0) {
                    spawnParticles(turkey.x - moveDx * 20, turkey.y - moveDy * 20, '#b11226', 2);
                }
            }

            if (isMoving) {
                const phaseStep = Math.min(0.4, Math.max(0.08, strideSpeed * 0.04));
                turkey.legPhase = (turkey.legPhase + phaseStep) % (Math.PI * 2);
                turkey.legSwingAmount = Math.min(1, turkey.legSwingAmount + 0.08);
            } else {
                turkey.legPhase = (turkey.legPhase + 0.01) % (Math.PI * 2);
                turkey.legSwingAmount = Math.max(0, turkey.legSwingAmount - 0.05);
            }

            if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS || (boss && boss.type === BOSS_TYPES.AURORA) || nextBossType === BOSS_TYPES.AURORA) {
                updateRoamingAuroras();
            }

            // Animate mouth
            turkey.mouthOpen = Math.sin(Date.now() / 100) * 0.3 + 0.3;

            // Clamp position
            clampTurkeyToBounds();
            enforceSolidBarriers();

            // Labyrinth levels now complete when enough treats are collected (handled in apple collision)
            // No exit to find - just collect treats!
            
            // Periodic treat spawning for maze levels
            if (isLabyrinthLevel() && gameState === 'playing') {
                mazeTreatSpawnTimer++;
                if (mazeTreatSpawnTimer >= MAZE_TREAT_SPAWN_INTERVAL) {
                    mazeTreatSpawnTimer = 0;
                    // Spawn a treat if under reasonable limit
                    if (apples.length < 8) {
                        spawnApple();
                    }
                }
            }

            if (gameState === 'boss' && boss && peckCooldown === 0) {
                const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
                const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
                const canAutoPeck = boss.type !== BOSS_TYPES.AURORA || isAuroraBossVulnerable();
                if (distToBoss < PECK_RANGE + bossRadius && canAutoPeck) {
                    tryPeckAttack();
                }
            }

            // Check apple collisions
            for (let i = apples.length - 1; i >= 0; i--) {
                const apple = apples[i];
                const dist = Math.hypot(turkey.x - apple.x, turkey.y - apple.y);
                if (dist < turkey.width / 2 + apple.size / 2) {
                    const isPineappleRound = currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS;
                    const fruitColor = isPineappleRound ? '#FFA500' : '#FF0000';
                    const leafColor = isPineappleRound ? '#2E8B57' : '#00FF00';
                    spawnParticles(apple.x, apple.y, fruitColor, 8);
                    spawnParticles(apple.x, apple.y, leafColor, 4);
                    apples.splice(i, 1);
                    score++;
                    gainLeftoverScraps();
                    
                    if (gameState === 'boss' && boss) {
                        if (boss.type !== BOSS_TYPES.AURORA) {
                            boss.health -= 1;
                            spawnParticles(boss.x, boss.y, '#FF7518', 15);
                            if (boss.health <= 0) {
                                spawnParticles(boss.x, boss.y, '#FFD700', 30);
                                boss = null;
                                levelUp();
                            }
                        }
                    } else if (currentLevel === LEVEL_IDS.PARADE && paradeFloat && gameState !== 'boss') {
                        incrementParadeFloat();
                        xp = paradeFloat.partsBuilt;
                        if (xp >= xpNeeded) {
                            levelUp();
                        }
                    } else if (currentLevel !== LEVEL_IDS.STEALTH_BOMBER && gameState !== 'boss') {
                        xp++;
                        if (xp >= xpNeeded) {
                            levelUp();
                        }
                    }
                    
                    spawnApple();
                    updateUI();
                }
            }

            // Update boss
            if (gameState === 'boss' && boss) {
                if (boss.type === BOSS_TYPES.AURORA) {
                    updateAuroraBoss();
                } else {
                    updatePumpkinBoss();
                }
            }

            // Update hunter (level 3) - Hunter on left side shoots at turkey
            if (hunter && gameState === 'playing') {
                // Update animations
                hunter.breathePhase += 0.03;
                hunter.animPhase += 0.05;
                if (hunter.muzzleFlash > 0) hunter.muzzleFlash--;

                // Grace period at the start - hunter doesn't shoot immediately
                if (hunter.graceTimer > 0) {
                    hunter.graceTimer--;
                } else if (hunter.isReloading) {
                    // Hunter is reloading - 10 seconds worth of frames
                    hunter.reloadTimer++;
                    updateHunterPatrol();
                    if (hunter.reloadTimer >= HUNTER_RELOAD_FRAMES) {
                        hunter.isReloading = false;
                        hunter.reloadTimer = 0;
                        hunter.shotsFired = 0;
                    }
                } else {
                    // Check if enough time has passed since last axe throw (5 seconds)
                    const currentTime = Date.now();
                    const timeSinceAxeThrow = currentTime - hunter.lastAxeThrowTime;
                    const canShoot = timeSinceAxeThrow >= 5000; // Must wait 5 seconds after axe throw
                    
                    if (canShoot) {
                        // Hunter can shoot - fires 3 shots then reloads
                        hunter.shootTimer++;
                        if (hunter.shootTimer > 50) { // Slightly faster between shots in burst
                            hunter.shootTimer = 0;
                            const angle = Math.atan2(turkey.y - hunter.y, turkey.x - hunter.x);
                            
                            // Record gun shot time
                            hunter.lastGunShotTime = currentTime;
                            
                            // Muzzle flash effect
                            hunter.muzzleFlash = 10;
                            
                            // Spawn muzzle particles
                            for (let p = 0; p < 5; p++) {
                                particles.push({
                                    x: hunter.x + 35,
                                    y: hunter.y - 5,
                                    vx: Math.cos(angle) * (3 + Math.random() * 2) + (Math.random() - 0.5),
                                    vy: Math.sin(angle) * (3 + Math.random() * 2) + (Math.random() - 0.5),
                                    life: 0.5,
                                    color: ['#FF4500', '#FFD700', '#FF6347'][p % 3],
                                    size: 4 + Math.random() * 3
                                });
                            }
                            
                            bossProjectiles.push({
                                x: hunter.x + 35,
                                y: hunter.y - 5,
                                vx: Math.cos(angle) * 8,
                                vy: Math.sin(angle) * 8,
                                size: 12,
                                isHunter: true,
                                type: 'bullet',
                                onHitMessage: 'You got shot!'
                            });
                            
                            hunter.shotsFired++;
                            if (hunter.shotsFired >= 3) {
                                // Start reloading after 3 shots
                                beginHunterReload();
                            }
                        }
                    }
                }
            }
            
            // Update hunter's wife and thrown nets
            if (hunterWife && currentLevel === LEVEL_IDS.HUNTER_SIEGE && gameState === 'playing') {
                updateHunterWife();
                updateThrownNets();
                
                // Check net collisions with turkey
                for (let i = thrownNets.length - 1; i >= 0; i--) {
                    const net = thrownNets[i];
                    const dist = Math.hypot(turkey.x - net.x, turkey.y - net.y);
                    if (dist < turkey.width / 2 + net.size / 3) {
                        // Trap the turkey instead of killing immediately
                        if (!netTrap.isTrapped) {
                            netTrap.isTrapped = true;
                            netTrap.trapTimer = netTrap.trapDuration;
                            netTrap.trapX = turkey.x;
                            netTrap.trapY = turkey.y;
                            netTrap.axeThrown = false;
                            spawnParticles(turkey.x, turkey.y, '#8B4513', 15);
                            // Wife must wait 5 seconds after catching turkey before throwing again
                            if (hunterWife) {
                                hunterWife.throwTimer = 0;
                                hunterWife.throwCooldown = 300; // 5 seconds
                                hunterWife.isWindingUp = false;
                                hunterWife.windupTimer = 0;
                            }
                        }
                        thrownNets.splice(i, 1);
                    }
                }
                
                // Handle trapped turkey state
                if (netTrap.isTrapped) {
                    updateNetTrap();
                }
            }

            if (currentLevel === LEVEL_IDS.STEALTH_BOMBER && gameState === 'playing') {
                updateBomber();
                updateBomberBombs();
            }

            // Update projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const proj = bossProjectiles[i];
                if (typeof proj.life === 'number') {
                    proj.life--;
                    if (proj.life <= 0) {
                        bossProjectiles.splice(i, 1);
                        continue;
                    }
                }
                proj.x += proj.vx;
                proj.y += proj.vy;
                if (proj.type === 'auroraStreak') {
                    proj.trailLength = Math.max(60, (proj.trailLength || 140) * 0.99);
                }

                // Check collision with turkey
                const dist = Math.hypot(turkey.x - proj.x, turkey.y - proj.y);
                if (dist < turkey.width / 2 + proj.size / 2) {
                    const message = proj.onHitMessage || (proj.isHunter ? 'You got shot!' : 'You were blasted!');
                    if (handleTurkeyDamage(message)) {
                        return;
                    }
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with barriers (projectiles get blocked)
                let hitBarrier = false;
                for (const barrier of barriers) {
                    if (proj.x > barrier.x - barrier.width / 2 &&
                        proj.x < barrier.x + barrier.width / 2 &&
                        proj.y > barrier.y - barrier.height / 2 &&
                        proj.y < barrier.y + barrier.height / 2) {
                        // Projectile hit barrier - destroy it with particles
                        const impactColor = proj.type === 'aurora' ? '#7FFFD4' : (proj.isHunter ? '#555' : '#FF7518');
                        spawnParticles(proj.x, proj.y, impactColor, 6);
                        bossProjectiles.splice(i, 1);
                        hitBarrier = true;
                        break;
                    }
                }
                if (hitBarrier) continue;

                // Remove off-screen
                if (proj.x < -50 || proj.x > canvas.width + 50 || proj.y < -50 || proj.y > canvas.height + 50) {
                    bossProjectiles.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            for (let i = auroraWaves.length - 1; i >= 0; i--) {
                const wave = auroraWaves[i];
                wave.radius += 3;
                wave.alpha -= 0.01;
                if (wave.alpha <= 0 || wave.radius >= wave.maxRadius) {
                    auroraWaves.splice(i, 1);
                }
            }

            updateAuroraBlasts();

            updateParadeConfetti();
        }

        function finishPumpkinBoss(options = {}) {
            if (!boss || boss.type !== BOSS_TYPES.PUMPKIN) return;
            const { scoreBonus = 0, bursts } = options;
            const burstConfig = bursts || [
                { color: '#FFD700', count: 30 },
                { color: '#FF7518', count: 20 },
                { color: '#FFFAF0', count: 15 }
            ];
            burstConfig.forEach(({ color, count }) => {
                spawnParticles(boss.x, boss.y, color, count);
            });
            if (scoreBonus) {
                score += scoreBonus;
            }
            boss = null;
            levelUp();
            updateUI();
        }

        function updatePumpkinBoss() {
            boss.x += boss.speed * boss.direction;
            if (boss.x < 100 || boss.x > BASE_WIDTH - 100) {
                boss.direction *= -1;
            }

            boss.attackTimer++;
            if (boss.attackTimer >= PUMPKIN_ATTACK_INTERVAL_FRAMES) {
                boss.attackTimer = 0;
                
                const sliceIndex = boss.shotsThrown % PUMPKIN_SLICE_COUNT;
                const sliceAngleStep = (Math.PI * 2) / PUMPKIN_SLICE_COUNT;
                const sliceAngle = sliceIndex * sliceAngleStep;
                const alreadyMissing = boss.missingSlices.some(missAngle => Math.abs(missAngle - sliceAngle) < 0.01);
                if (!alreadyMissing) {
                    boss.missingSlices.push(sliceAngle);
                }
                const noSlicesLeft = boss.missingSlices.length >= PUMPKIN_SLICE_COUNT;
                
                const throwOffsetX = Math.cos(sliceAngle + Math.PI / 8) * (boss.width / 2 * boss.currentScale);
                const throwOffsetY = Math.sin(sliceAngle + Math.PI / 8) * (boss.height / 2 * boss.currentScale);
                
                bossProjectiles.push({
                    x: boss.x + throwOffsetX,
                    y: boss.y + throwOffsetY,
                    vx: (Math.random() - 0.5) * 4 + throwOffsetX * 0.05,
                    vy: 6,
                    size: 20,
                    type: 'pie',
                    onHitMessage: 'The pie got you!'
                });
                
                boss.shotsThrown++;

                if (noSlicesLeft) {
                    finishPumpkinBoss();
                    return;
                }

                boss.health -= 0.3;
                boss.currentScale = Math.max(0.4, 1 - (boss.shotsThrown * 0.06));
                boss.opacity = Math.max(0.3, 1 - (boss.shotsThrown * 0.03));
                
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FF7518', 10);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#DEB887', 6);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FFFAF0', 4);
                
                if (boss.health <= 0) {
                    finishPumpkinBoss();
                    return;
                }
                
                updateUI();
            }

            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const eatRange = turkey.width / 2 + boss.width / 2 - 10;
            
            if (distToBoss < eatRange) {
                boss.eatCooldown = boss.eatCooldown || 0;
                boss.eatCooldown--;
                
                if (boss.eatCooldown <= 0) {
                    boss.eatCooldown = 20;
                    boss.health -= 2;
                    
                    turkey.mouthOpen = 1;
                    spawnParticles(boss.x, boss.y, '#FF7518', 15);
                    spawnParticles(boss.x, boss.y, '#DEB887', 8);
                    spawnParticles(turkey.x + turkey.direction * 30, turkey.y, '#FFD700', 5);
                    
                    const pushDir = boss.x > turkey.x ? 1 : -1;
                    boss.x += pushDir * 15;
                    
                    if (boss.health <= 0) {
                        finishPumpkinBoss({
                            scoreBonus: 5,
                            bursts: [
                                { color: '#FFD700', count: 40 },
                                { color: '#FF7518', count: 30 },
                                { color: '#FFFAF0', count: 20 }
                            ]
                        });
                        return;
                    }
                    
                    updateUI();
                }
            }
        }

        function updateAuroraBoss() {
            boss.pulse += 0.02;

            if (boss.graceTimer > 0) {
                boss.graceTimer--;
                boss.attackTimer = 0;
                return;
            }

            if (boss.isRecharging) {
                boss.rechargeTimer--;
                if (boss.rechargeTimer <= 0) {
                    boss.isRecharging = false;
                    boss.attackTimer = 0;
                    triggerAuroraEnergyBlast();
                }
                return;
            }

            boss.attackTimer++;

            if (boss.attackTimer % 45 === 0) {
                const volley = 3;
                const baseAngle = Math.atan2(turkey.y - boss.y, turkey.x - boss.x);
                for (let i = 0; i < volley; i++) {
                    const offset = (i - 1) * 0.2;
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(baseAngle + offset) * 4.5,
                        vy: Math.sin(baseAngle + offset) * 4.5,
                        size: 22,
                        type: 'aurora',
                        color: `hsl(${180 + i * 40}, 80%, 70%)`,
                        onHitMessage: 'The northern lights consumed you!'
                    });
                }
                spawnParticles(boss.x, boss.y, '#7FFFD4', 12);
            }

            if (boss.attackTimer % 120 === 0) {
                const streaks = 2;
                const baseAngle = Math.atan2(turkey.y - boss.y, turkey.x - boss.x);
                for (let i = 0; i < streaks; i++) {
                    const offset = (i - (streaks - 1) / 2) * 0.25;
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(baseAngle + offset) * 6.5,
                        vy: Math.sin(baseAngle + offset) * 6.5,
                        size: 14,
                        type: 'auroraStreak',
                        trailLength: 170,
                        life: 240,
                        color: `hsl(${200 + i * 35}, 90%, 70%)`,
                        onHitMessage: 'A light streak vaporized you!'
                    });
                }
                spawnParticles(boss.x, boss.y, '#a855ff', 18);
            }

            if (boss.attackTimer % 180 === 0) {
                auroraWaves.push({
                    x: boss.x,
                    y: boss.y,
                    radius: boss.radius,
                    maxRadius: boss.radius + 260,
                    alpha: 0.7
                });
            }

            if (boss.attackTimer >= AURORA_ATTACK_WINDOW_FRAMES) {
                boss.isRecharging = true;
                boss.rechargeTimer = AURORA_RECHARGE_FRAMES;
                spawnParticles(boss.x, boss.y, '#d4fff9', 18);
            }
        }
        function levelUp() {
            currentLevel++;
            // Turkey no longer grows - stays the same size every level
            
            if (currentLevel > MAX_LEVEL) {
                gameState = 'win';
                document.getElementById('winScore').textContent = score;
                document.getElementById('winScreen').classList.remove('hidden');
                return;
            }

            gameState = 'levelup';
            const nextLevel = levels[currentLevel] || { name: 'Unknown', description: '' };
            document.getElementById('newLevelName').textContent = `Level ${currentLevel}: ${nextLevel.name}`;
            document.getElementById('levelDescription').textContent = nextLevel.description;
            document.getElementById('levelUpScreen').classList.remove('hidden');
            startLevelCountdown();
            updateUI();
        }

        function gameOver(message) {
            gameState = 'gameover';
            document.getElementById('deathMessage').textContent = message;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const isPumpkinBossField = boss && boss.type === BOSS_TYPES.PUMPKIN;
            const isAuroraBattle = boss && boss.type === BOSS_TYPES.AURORA;
            let backdropLevel = currentLevel;
            if (isAuroraBattle) {
                backdropLevel = LEVEL_IDS.NORTHERN_LIGHTS_BOSS;
            } else if (isPumpkinBossField) {
                backdropLevel = LEVEL_IDS.BARN_ESCAPE;
            }
            
            switch (backdropLevel) {
                case LEVEL_IDS.BARN_TURKEY: {
                    gradient.addColorStop(0, '#8B4513');
                    gradient.addColorStop(1, '#5D3A1A');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#4A2C17';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < canvas.width; i += 60) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, canvas.height);
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = '#DAA520';
                    const haySpacing = 25;
                    const hayCount = Math.ceil(canvas.width / haySpacing) + 5;
                    for (let i = 0; i < hayCount; i++) {
                        ctx.beginPath();
                        const x = (i * haySpacing) % canvas.width;
                        const waveOffset = Math.sin(i * 0.5) * 10;
                        ctx.ellipse(
                            x,
                            canvas.height - 30 + waveOffset,
                            20,
                            8,
                            0,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                }
                case LEVEL_IDS.BARN_ESCAPE:
                case LEVEL_IDS.PUMPKIN_PIE_BOSS: {
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(0.6, '#FDB347');
                    gradient.addColorStop(1, '#228B22');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    
                    const canopyColors = ['#FF6347', '#FF8C00', '#FFD700', '#DC143C'];
                    const groveCount = Math.max(4, Math.ceil(canvas.width / 160));
                    const groveSpacing = canvas.width / groveCount;
                    for (let i = 0; i < groveCount; i++) {
                        const tx = groveSpacing * i + groveSpacing / 2;
                        ctx.fillStyle = '#5D3A1A';
                        ctx.fillRect(tx - 10, canvas.height - 180, 20, 100);
                        ctx.beginPath();
                        ctx.fillStyle = canopyColors[i % canopyColors.length];
                        ctx.arc(tx, canvas.height - 200, 50, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                }
                case LEVEL_IDS.HUNTER_SIEGE: {
                    gradient.addColorStop(0, '#1d1c2c');
                    gradient.addColorStop(0.7, '#0f1a1c');
                    gradient.addColorStop(1, '#08100f');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#162926';
                    const treeCount = Math.max(6, Math.ceil(canvas.width / 140));
                    for (let i = 0; i < treeCount; i++) {
                        const baseX = (i * 137 + 50) % (canvas.width + 80) - 40;
                        ctx.beginPath();
                        ctx.moveTo(baseX, canvas.height);
                        ctx.lineTo(baseX + 25, canvas.height - 180 - (i % 3) * 20);
                        ctx.lineTo(baseX + 50, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#243734';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    break;
                }
                case LEVEL_IDS.WOOD_ESCAPE: {
                    gradient.addColorStop(0, '#120c1f');
                    gradient.addColorStop(0.4, '#1c1a2e');
                    gradient.addColorStop(1, '#1a2a1a');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#0b3d2c55';
                    for (let i = 0; i < canvas.width; i += 50) {
                        ctx.beginPath();
                        ctx.moveTo(i, canvas.height);
                        ctx.lineTo(i + 25, canvas.height - 220 - Math.sin(i * 0.3) * 20);
                        ctx.lineTo(i + 40, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#27402c';
                    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                    ctx.fillStyle = '#152214';
                    ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
                    break;
                }
                case LEVEL_IDS.STEALTH_BOMBER: {
                    gradient.addColorStop(0, '#030711');
                    gradient.addColorStop(1, '#0f1a2b');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff22';
                    const starCount = Math.max(80, Math.ceil(canvas.width / 10));
                    for (let i = 0; i < starCount; i++) {
                        ctx.beginPath();
                        const x = (i * 53) % canvas.width;
                        const y = (i * 97) % 200;
                        const radius = (i % 3) * 0.6 + 0.5;
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    const groundHeight = Math.max(60, canvas.height * 0.1);
                    ctx.fillStyle = '#1a3a1a';
                    ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
                    break;
                }
                case LEVEL_IDS.SPACE_ESCAPE: {
                    gradient.addColorStop(0, '#050714');
                    gradient.addColorStop(0.4, '#040c2c');
                    gradient.addColorStop(1, '#01030a');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff33';
                    const starTotal = Math.max(120, Math.ceil(canvas.width / 5));
                    for (let i = 0; i < starTotal; i++) {
                        const r = (i % 7) * 0.2 + 0.4;
                        ctx.beginPath();
                        ctx.arc((i * 47) % canvas.width, (i * 91) % canvas.height, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#2f87ff44';
                    ctx.beginPath();
                    ctx.ellipse(canvas.width * 0.7, canvas.height * 0.3, 140, 40, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1f1135';
                    ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
                    break;
                }
                case LEVEL_IDS.NORTHERN_LIGHTS_BOSS: {
                    gradient.addColorStop(0, '#05030f');
                    gradient.addColorStop(0.5, '#112144');
                    gradient.addColorStop(1, '#04121f');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const auroraColors = ['#5ef1ff', '#a855ff', '#5ef179', '#ffd15e'];
                    auroraColors.forEach((color, index) => {
                        ctx.beginPath();
                        ctx.moveTo(0, 200 + index * 30);
                        for (let x = 0; x <= canvas.width; x += 20) {
                            const y = 200 + index * 30 + Math.sin((x / canvas.width) * Math.PI * 2 + index) * 40;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.lineTo(0, canvas.height);
                        ctx.closePath();
                        ctx.fillStyle = color + '33';
                        ctx.fill();
                    });
                    
                    ctx.fillStyle = '#0b1d2c';
                    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                    break;
                }
                case LEVEL_IDS.CORN_MAZE: {
                    gradient.addColorStop(0, '#1b1206');
                    gradient.addColorStop(0.4, '#3b240b');
                    gradient.addColorStop(1, '#1f1506');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#f2c94c22';
                    for (let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        const x = (i * 70 + (Date.now() / 50)) % (canvas.width + 100) - 50;
                        const y = 80 + (i % 5) * 60;
                        ctx.ellipse(x, y, 40, 14, Math.sin(i) * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#362003';
                    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                    ctx.fillStyle = '#6f4c1b';
                    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                    break;
                }
                case LEVEL_IDS.PARADE: {
                    // Festive parade sky
                    gradient.addColorStop(0, '#1a237e');
                    gradient.addColorStop(0.3, '#283593');
                    gradient.addColorStop(0.7, '#3949ab');
                    gradient.addColorStop(1, '#5c6bc0');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // City skyline with lit windows
                    const buildings = [
                        { x: 0, w: 60, h: 180 },
                        { x: 55, w: 45, h: 140 },
                        { x: 95, w: 70, h: 220 },
                        { x: canvas.width - 150, w: 50, h: 160 },
                        { x: canvas.width - 105, w: 60, h: 200 },
                        { x: canvas.width - 50, w: 55, h: 170 }
                    ];
                    buildings.forEach(b => {
                        ctx.fillStyle = '#1a1a3e';
                        ctx.fillRect(b.x, canvas.height - b.h - 60, b.w, b.h);
                        // Lit windows
                        ctx.fillStyle = '#FFD700';
                        for (let wy = 0; wy < b.h - 20; wy += 25) {
                            for (let wx = 8; wx < b.w - 8; wx += 15) {
                                if (Math.random() > 0.3) {
                                    ctx.fillRect(b.x + wx, canvas.height - b.h - 60 + wy + 10, 8, 12);
                                }
                            }
                        }
                    });
                    
                    // Multiple spotlight beams sweeping
                    const time = Date.now() * 0.001;
                    for (let s = 0; s < 3; s++) {
                        ctx.globalAlpha = 0.12;
                        ctx.fillStyle = ['#ffd700', '#ff69b4', '#00bfff'][s];
                        ctx.beginPath();
                        const baseX = canvas.width * (0.25 + s * 0.25);
                        const sweep = Math.sin(time + s * 2) * 100;
                        ctx.moveTo(baseX + sweep - 40, canvas.height);
                        ctx.lineTo(baseX, 50);
                        ctx.lineTo(baseX + sweep + 40, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    
                    // Parade route barriers on sides (crowd areas)
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(0, 100, 80, canvas.height - 160);
                    ctx.fillRect(canvas.width - 80, 100, 80, canvas.height - 160);
                    
                    // Parade street
                    ctx.fillStyle = '#2d2d2d';
                    ctx.fillRect(80, canvas.height - 80, canvas.width - 160, 80);
                    
                    // Street markings
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(canvas.width / 2 - 5, canvas.height - 75, 10, 70);
                    
                    // Draw balloons in background
                    if (paradeBalloons) {
                        paradeBalloons.forEach(balloon => {
                            ctx.fillStyle = balloon.color;
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.ellipse(balloon.x, balloon.y, balloon.size * 0.7, balloon.size, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // Balloon string
                            ctx.strokeStyle = '#666';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(balloon.x, balloon.y + balloon.size);
                            ctx.quadraticCurveTo(balloon.x + Math.sin(balloon.wobble) * 10, balloon.y + balloon.size + 30, balloon.x, balloon.y + balloon.size + 50);
                            ctx.stroke();
                            // Balloon shine
                            ctx.fillStyle = 'rgba(255,255,255,0.4)';
                            ctx.beginPath();
                            ctx.ellipse(balloon.x - balloon.size * 0.2, balloon.y - balloon.size * 0.3, balloon.size * 0.15, balloon.size * 0.2, -0.5, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.globalAlpha = 1;
                    }
                    
                    // Draw spectators on the sides
                    if (paradeSpectators) {
                        paradeSpectators.forEach(spec => {
                            ctx.fillStyle = spec.color;
                            // Body
                            ctx.fillRect(spec.x - 8, spec.y, 16, 25);
                            // Head
                            ctx.fillStyle = '#DEB887';
                            ctx.beginPath();
                            ctx.arc(spec.x, spec.y - 8, 10, 0, Math.PI * 2);
                            ctx.fill();
                            // Waving arm
                            ctx.strokeStyle = '#DEB887';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            const armY = spec.y + 5;
                            const armExtend = Math.sin(spec.armPhase) * 15;
                            ctx.moveTo(spec.x, armY);
                            ctx.lineTo(spec.x + (spec.x < canvas.width / 2 ? 15 : -15), armY - 10 + armExtend);
                            ctx.stroke();
                        });
                    }
                    
                    // Draw parade floats in background
                    if (paradeFloats) {
                        paradeFloats.forEach(float => {
                            ctx.save();
                            ctx.translate(float.x, float.y);
                            
                            if (float.type === 'turkeyFloat') {
                                // Float base
                                ctx.fillStyle = '#8B4513';
                                ctx.fillRect(-50, 20, 100, 30);
                                // Wheels
                                ctx.fillStyle = '#333';
                                ctx.beginPath();
                                ctx.arc(-35, 50, 15, 0, Math.PI * 2);
                                ctx.arc(35, 50, 15, 0, Math.PI * 2);
                                ctx.fill();
                                // Giant turkey decoration
                                ctx.fillStyle = '#8B4513';
                                ctx.beginPath();
                                ctx.ellipse(0, -10, 35, 30, 0, 0, Math.PI * 2);
                                ctx.fill();
                                // Tail feathers
                                const featherColors = ['#FF4500', '#FFD700', '#FF6347', '#FFA500', '#DC143C'];
                                for (let f = 0; f < 5; f++) {
                                    ctx.fillStyle = featherColors[f];
                                    ctx.beginPath();
                                    ctx.ellipse(-30 + f * 5, -40 - f * 3, 8, 25, -0.3 + f * 0.15, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            } else {
                                // Pilgrim float
                                ctx.fillStyle = '#654321';
                                ctx.fillRect(-40, 15, 80, 25);
                                ctx.fillStyle = '#333';
                                ctx.beginPath();
                                ctx.arc(-25, 40, 12, 0, Math.PI * 2);
                                ctx.arc(25, 40, 12, 0, Math.PI * 2);
                                ctx.fill();
                                // Pilgrim figure
                                ctx.fillStyle = '#1a1a1a';
                                ctx.fillRect(-15, -30, 30, 45);
                                // Hat
                                ctx.fillRect(-20, -50, 40, 8);
                                ctx.fillRect(-12, -70, 24, 25);
                                ctx.fillStyle = '#FFD700';
                                ctx.fillRect(-8, -55, 16, 5);
                            }
                            
                            ctx.restore();
                        });
                    }
                    
                    break;
                }
                default: {
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#16213e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#FFFACD';
                    ctx.beginPath();
                    const sunX = canvas.width * 0.65;
                    const sunRadius = Math.max(40, canvas.width * 0.04);
                    ctx.arc(sunX, 80, sunRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0f0f23';
                    const mountainCount = Math.max(6, Math.ceil(canvas.width / 120));
                    const mountainWidth = canvas.width / mountainCount;
                    for (let i = 0; i < mountainCount; i++) {
                        const tx = i * mountainWidth;
                        const peakHeight = 200 + Math.sin(i * 0.8) * 60;
                        ctx.beginPath();
                        ctx.moveTo(tx, canvas.height);
                        ctx.lineTo(tx + mountainWidth / 2, canvas.height - peakHeight);
                        ctx.lineTo(tx + mountainWidth, canvas.height);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#2d4a3e';
                    const meadowHeight = Math.max(60, canvas.height * 0.08);
                    ctx.fillRect(0, canvas.height - meadowHeight, canvas.width, meadowHeight);
                }
            }
        }

        function drawTurkey() {
            ctx.save();
            
            // Draw speed boost glow effect behind turkey when ready or active
            const abilityState = leftoverBuffs.cranberry;
            const abilityConfig = LEFTOVER_CONFIG.cranberry;
            const isSpeedReady = abilityState.activeTimer <= 0 && abilityState.cooldownTimer <= 0 && leftoverBuffs.scraps >= abilityConfig.cost;
            const isSpeedActive = abilityState.activeTimer > 0;
            
            if (isSpeedActive) {
                // Active speed boost - intense red/orange pulsing glow
                const pulse = Math.sin(Date.now() * 0.015) * 0.3 + 0.7;
                const gradient = ctx.createRadialGradient(turkey.x, turkey.y, 0, turkey.x, turkey.y, 80);
                gradient.addColorStop(0, `rgba(255, 50, 50, ${0.6 * pulse})`);
                gradient.addColorStop(0.4, `rgba(255, 100, 0, ${0.4 * pulse})`);
                gradient.addColorStop(0.7, `rgba(255, 150, 0, ${0.2 * pulse})`);
                gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(turkey.x, turkey.y, 80, 0, Math.PI * 2);
                ctx.fill();
            } else if (isSpeedReady) {
                // Ready to use - golden pulsing glow
                const pulse = Math.sin(Date.now() * 0.006) * 0.4 + 0.6;
                const gradient = ctx.createRadialGradient(turkey.x, turkey.y, 0, turkey.x, turkey.y, 60);
                gradient.addColorStop(0, `rgba(255, 215, 0, ${0.5 * pulse})`);
                gradient.addColorStop(0.5, `rgba(255, 180, 0, ${0.25 * pulse})`);
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(turkey.x, turkey.y, 60, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.translate(turkey.x, turkey.y);
            ctx.scale(turkey.direction, 1);
            
            const scale = 1 + (turkey.evolution - 1) * 0.2;
            ctx.scale(scale, scale);
            
            // Peck animation - lunge forward
            const peckLunge = isPecking ? Math.sin((peckAnimTimer / 15) * Math.PI) * 20 : 0;
            ctx.translate(peckLunge, 0);
            
            // Tail feathers
            const tailColors = ['#8B0000', '#FF4500', '#FFD700', '#8B4513', '#FF6347'];
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = tailColors[i];
                ctx.beginPath();
                const angle = (i - 2) * 0.4 - Math.PI / 2;
                ctx.ellipse(
                    Math.cos(angle) * 25 - 10 - peckLunge, // Tail stays back during peck
                    Math.sin(angle) * 25 - 5,
                    12, 30,
                    angle + Math.PI / 2,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Body
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(0, 5, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head - move forward extra during peck
            const headExtend = isPecking ? 10 : 0;
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(20 + headExtend, -5, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Wattle (red thing under beak)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(28 + headExtend, 5, 5, 10, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Snood (red thing on top)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(25 + headExtend, -15, 4, 8, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // BIG MOUTH / Beak - extra extended during peck
            const beakExtend = isPecking ? 25 : 0;
            ctx.fillStyle = isPecking ? '#FF6600' : '#FFA500'; // Brighter orange when pecking
            ctx.beginPath();
            const mouthOpenAmount = isPecking ? 8 : turkey.mouthOpen * 15; // Closed beak during peck for sharp hit
            // Upper beak
            ctx.moveTo(30 + headExtend, -8);
            ctx.lineTo(55 + headExtend + beakExtend, -5 - mouthOpenAmount);
            ctx.lineTo(30 + headExtend, -2);
            ctx.fill();
            // Lower beak
            ctx.beginPath();
            ctx.moveTo(30 + headExtend, -2);
            ctx.lineTo(55 + headExtend + beakExtend, 5 + mouthOpenAmount);
            ctx.lineTo(30 + headExtend, 2);
            ctx.fill();
            
            // Peck impact effect
            if (isPecking && peckAnimTimer > 10) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                // Impact lines
                for (let i = 0; i < 4; i++) {
                    const angle = (i - 1.5) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(60 + headExtend + beakExtend, -2);
                    ctx.lineTo(75 + headExtend + beakExtend + Math.cos(angle) * 15, -2 + Math.sin(angle) * 15);
                    ctx.stroke();
                }
            }
            
            // Eye - angry during peck
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(25 + headExtend, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(26 + headExtend, -9, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyebrow during peck
            if (isPecking) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20 + headExtend, -15);
                ctx.lineTo(30 + headExtend, -13);
                ctx.stroke();
            }
            
            // Legs with simple stride animation
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            const legBaseY = 22;
            const hipOffsets = [-6, 6];
            const swingAmp = 8 * turkey.legSwingAmount;
            const liftAmp = 6 * turkey.legSwingAmount;
            const drawAnimatedLeg = (hipX, phaseOffset) => {
                const phase = turkey.legPhase + phaseOffset;
                const swing = Math.sin(phase) * swingAmp;
                const lift = Math.max(0, Math.cos(phase)) * liftAmp;
                const kneeX = hipX + swing * 0.4;
                const kneeY = legBaseY + 8 - lift;
                const footX = hipX + swing;
                const footY = legBaseY + 20;
                
                ctx.beginPath();
                ctx.moveTo(hipX, legBaseY - 2);
                ctx.lineTo(kneeX, kneeY);
                ctx.lineTo(footX, footY);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX - 6, footY + 5);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX + 4, footY + 6);
                ctx.moveTo(footX, footY);
                ctx.lineTo(footX + 8, footY + 2);
                ctx.stroke();
            };
            drawAnimatedLeg(hipOffsets[0], 0);
            drawAnimatedLeg(hipOffsets[1], Math.PI);
            
            ctx.restore();
        }

        function drawApple(apple) {
            ctx.save();
            ctx.translate(apple.x, apple.y + Math.sin(Date.now() / 300 + apple.bobOffset) * 5);
            
            if (currentLevel === LEVEL_IDS.NORTHERN_LIGHTS_BOSS) {
                // Pineapple body
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.ellipse(0, 0, apple.size / 2.2, apple.size / 1.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#D67A00';
                ctx.lineWidth = 2;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, apple.size / 2.5, apple.size / 1.8, i * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Leaves
                ctx.fillStyle = '#1f8a5c';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse((i - 1.5) * 5, -apple.size / 1.4 - i * 2, 6, 16, (i - 1.5) * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                return;
            } else if (currentLevel === LEVEL_IDS.PARADE) {
                ctx.fillStyle = '#ff8fb1';
                ctx.fillRect(-apple.size / 2, -apple.size / 2, apple.size, apple.size);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(-apple.size / 2, -apple.size / 2, apple.size, apple.size);
                ctx.strokeStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(-apple.size / 2, 0);
                ctx.lineTo(apple.size / 2, 0);
                ctx.moveTo(0, -apple.size / 2);
                ctx.lineTo(0, apple.size / 2);
                ctx.stroke();
                ctx.restore();
                return;
            }
            
            // Apple body
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(0, 0, apple.size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(-5, -5, apple.size / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Stem
            ctx.strokeStyle = '#5D3A1A';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -apple.size / 2);
            ctx.lineTo(2, -apple.size / 2 - 8);
            ctx.stroke();
            
            // Leaf
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(6, -apple.size / 2 - 5, 6, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPeckIndicator() {
            if (gameState !== 'boss' || !boss) return;
            
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const inRange = distToBoss < PECK_RANGE + bossRadius;
            
            // Draw range circle around turkey
            ctx.save();
            ctx.translate(turkey.x, turkey.y);
            
            // Range indicator
            ctx.strokeStyle = inRange ? 'rgba(255, 215, 0, 0.6)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = inRange ? 3 : 1;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.arc(0, 0, PECK_RANGE, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Cooldown indicator (arc that fills up as cooldown resets)
            if (peckCooldown > 0) {
                const cooldownPercent = peckCooldown / PECK_COOLDOWN_MAX;
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 35, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownPercent) * Math.PI * 2);
                ctx.stroke();
            } else if (inRange) {
                // Ready to peck indicator
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('PECK!', 0, -45);
            }
            
            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            if (boss.type === BOSS_TYPES.AURORA) {
                drawAuroraBossSprite();
            } else {
                drawPumpkinBossSprite();
            }
        }

        function drawPumpkinBossSprite() {
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            // Apply fading opacity - boss fades as it throws more pies
            ctx.globalAlpha = boss.opacity;
            
            // Apply shrinking scale
            const scale = boss.currentScale;
            ctx.scale(scale, scale);
            
            // Pie dish (also shrinks)
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(0, boss.height / 2 - 10, boss.width / 2 + 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pie with missing slices
            const sliceCount = 8;
            const sliceAngle = Math.PI * 2 / sliceCount;
            
            for (let i = 0; i < sliceCount; i++) {
                const startAngle = i * sliceAngle;
                const endAngle = startAngle + sliceAngle - 0.05; // Small gap between slices
                
                // Check if this slice is missing
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - startAngle) < 0.1;
                });
                
                if (!isMissing) {
                    // Draw pie filling slice
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw crust edge on this slice
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, boss.width / 2 - 2, startAngle, endAngle);
                    ctx.stroke();
                } else {
                    // Draw empty/bitten area where slice was
                    ctx.fillStyle = 'rgba(139, 90, 43, 0.3)'; // Dark inner pie color
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2 - 15, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Whipped cream swirls (only on remaining slices)
            ctx.fillStyle = '#FFFAF0';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const sliceIndex = Math.floor(angle / sliceAngle);
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - sliceIndex * sliceAngle) < 0.1;
                });
                
                if (!isMissing) {
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(angle) * 25,
                        Math.sin(angle) * 25,
                        10, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Center cream dollop (gets smaller as more slices are gone)
            const centerSize = Math.max(5, 15 - boss.missingSlices.length);
            ctx.beginPath();
            ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil face (shrinks with the pie)
            ctx.fillStyle = '#000';
            // Eyes
            ctx.beginPath();
            ctx.arc(-15, -5, 6, 0, Math.PI * 2);
            ctx.arc(15, -5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil eyebrows - get more distressed as health drops
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const eyebrowLift = boss.missingSlices.length * 2;
            ctx.moveTo(-25, -15 - eyebrowLift);
            ctx.lineTo(-8, -12);
            ctx.moveTo(25, -15 - eyebrowLift);
            ctx.lineTo(8, -12);
            ctx.stroke();
            
            // Evil smile (becomes worried frown as health drops)
            ctx.beginPath();
            if (boss.missingSlices.length > 4) {
                // Worried frown
                ctx.arc(0, 20, 12, Math.PI + 0.3, -0.3);
            } else {
                // Evil smile
                ctx.arc(0, 10, 15, 0.2, Math.PI - 0.2);
            }
            ctx.stroke();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for health bar
            
            // Health bar - always fully visible even when boss is fading
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#333';
            ctx.fillRect(boss.x - 40, boss.y - boss.height / 2 - 20, 80, 10);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(boss.x - 38, boss.y - boss.height / 2 - 18, 76 * Math.max(0, boss.health / boss.maxHealth), 6);
            
            ctx.restore();
        }

        function drawAuroraBossSprite() {
            if (!boss) return;
            const auroraVulnerable = isAuroraBossVulnerable();
            ctx.save();
            ctx.translate(boss.x, boss.y);
            const pulse = 0.95 + Math.sin(boss.pulse) * (auroraVulnerable ? 0.2 : 0.12);
            const twist = Math.sin(boss.pulse * 0.8) * 0.25;
            ctx.rotate(twist);

            const outerGradient = ctx.createRadialGradient(0, 0, boss.radius * 0.35, 0, 0, boss.radius * 1.35);
            outerGradient.addColorStop(0, 'rgba(8, 12, 26, 0.95)');
            outerGradient.addColorStop(0.4, 'rgba(9, 51, 89, 0.85)');
            outerGradient.addColorStop(0.75, 'rgba(64, 255, 196, 0.25)');
            outerGradient.addColorStop(1, 'rgba(2, 4, 10, 0.05)');
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * 1.3 * pulse, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowColor = '#7fffd4';
            ctx.shadowBlur = 35;
            ctx.strokeStyle = 'rgba(127, 255, 212, 0.85)';
            ctx.lineWidth = 3;
            const spikes = 18;
            ctx.beginPath();
            for (let i = 0; i <= spikes; i++) {
                const angle = (i / spikes) * Math.PI * 2;
                const wobble = Math.sin(boss.pulse * 4 + i * 1.3) * 0.18;
                const radius = boss.radius * (1.05 + wobble);
                const spikeRadius = radius + Math.sin(boss.pulse * 6 + i) * 18;
                const spikeX = Math.cos(angle) * spikeRadius;
                const spikeY = Math.sin(angle) * spikeRadius;
                if (i === 0) {
                    ctx.moveTo(spikeX, spikeY);
                } else {
                    ctx.lineTo(spikeX, spikeY);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;

            const innerGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, boss.radius * 0.9);
            innerGradient.addColorStop(0, 'rgba(255,255,255,0.95)');
            innerGradient.addColorStop(0.25, 'rgba(111,255,255,0.8)');
            innerGradient.addColorStop(0.6, 'rgba(66, 208, 255, 0.5)');
            innerGradient.addColorStop(1, 'rgba(7, 11, 25, 0.9)');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * 0.95 * pulse, 0, Math.PI * 2);
            ctx.fill();

            if (auroraVulnerable) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.85)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(0, 0, boss.radius * 1.45, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            ctx.strokeStyle = 'rgba(94, 241, 255, 0.45)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const angle = i * (Math.PI / 3) + boss.pulse * 0.4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const bend = Math.sin(boss.pulse * 3 + i) * 0.5;
                ctx.quadraticCurveTo(
                    Math.cos(angle) * boss.radius * 0.4,
                    Math.sin(angle) * boss.radius * 0.4,
                    Math.cos(angle + bend) * boss.radius * 0.85,
                    Math.sin(angle + bend) * boss.radius * 0.85
                );
                ctx.stroke();
            }

            const eyeGlow = 0.7 + Math.sin(boss.pulse * 2) * 0.3;
            const eyeOffsets = [-26, 0, 26];
            eyeOffsets.forEach((offset, index) => {
                ctx.save();
                ctx.translate(offset, -12 + Math.sin(boss.pulse + index) * 4);
                ctx.rotate(Math.sin(boss.pulse * 1.5 + index) * 0.2);
                ctx.fillStyle = 'rgba(5, 10, 18, 0.95)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 11, 24, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(148, 255, 246, ${eyeGlow})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 7, 16, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#03131f';
                ctx.beginPath();
                ctx.ellipse(Math.sin(boss.pulse * 3 + index) * 2, 0, 3, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            ctx.strokeStyle = '#7fffd4';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#03070f';
            ctx.beginPath();
            ctx.moveTo(-32, 28);
            for (let i = 0; i <= 6; i++) {
                const x = -32 + i * 10;
                const y = 28 + (i % 2 === 0 ? 18 : 6);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(32, 28);
            ctx.stroke();
            ctx.fill();

            ctx.fillStyle = '#d4fff9';
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                const x = -27 + i * 10;
                const height = i % 2 === 0 ? 18 : 12;
                ctx.moveTo(x, 28);
                ctx.lineTo(x + 5, 28 + height);
                ctx.lineTo(x + 10, 28);
                ctx.closePath();
                ctx.fill();
            }

            ctx.strokeStyle = 'rgba(148, 255, 246, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-12, 40);
            ctx.quadraticCurveTo(-8, 56 + Math.sin(boss.pulse * 5) * 6, -20, 78);
            ctx.moveTo(15, 42);
            ctx.quadraticCurveTo(22, 60 + Math.cos(boss.pulse * 4) * 6, 6, 82);
            ctx.stroke();

            ctx.restore();

            ctx.save();
            ctx.fillStyle = '#03060d';
            ctx.fillRect(boss.x - 60, boss.y - boss.radius - 30, 120, 12);
            ctx.fillStyle = '#7fffd4';
            const healthPercent = Math.max(0, boss.health / boss.maxHealth);
            ctx.fillRect(boss.x - 58, boss.y - boss.radius - 28, 116 * healthPercent, 8);

            if (boss.graceTimer > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '18px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(boss.graceTimer / 60);
                ctx.fillText(`Aurora charging... ${secondsLeft}s`, boss.x, boss.y - boss.radius - 50);
            } else if (auroraVulnerable) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '18px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('Aurora recharging - peck now!', boss.x, boss.y - boss.radius - 50);
            }
            ctx.restore();
        }

        function drawHunter() {
            if (!hunter) return;
            
            ctx.save();
            ctx.translate(hunter.x, hunter.y);
            
            // Breathing animation
            const breathe = Math.sin(hunter.breathePhase || 0) * 2;
            
            // Draw danger zone indicator when shooting
            if (!hunter.isReloading && hunter.graceTimer <= 0) {
                ctx.globalAlpha = 0.15 + Math.sin(Date.now() * 0.01) * 0.1;
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(0, 0, 200, -0.5, 0.5);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Legs with walking animation
            ctx.fillStyle = '#8B4513';
            const legSwing = hunter.isReloading ? Math.sin(hunter.animPhase || 0) * 5 : 0;
            ctx.fillRect(-12 + legSwing, 20, 10, 25);
            ctx.fillRect(2 - legSwing, 20, 10, 25);
            
            // Body with breathing
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(-15, -20 + breathe, 30, 40);
            
            // Vest details
            ctx.fillStyle = '#4A5D23';
            ctx.fillRect(-12, -15 + breathe, 6, 30);
            ctx.fillRect(6, -15 + breathe, 6, 30);
            
            // Arms
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(15, -15 + breathe, 8, 25);
            ctx.fillRect(-23, -15 + breathe, 8, 25);
            
            // Head
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(0, -30 + breathe, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Hunter hat - orange safety
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(-18, -45 + breathe, 36, 10);
            ctx.fillRect(-12, -55 + breathe, 24, 12);
            
            // Gun pointing right (toward turkey)
            ctx.save();
            const gunAngle = Math.atan2(turkey.y - hunter.y, turkey.x - hunter.x);
            ctx.translate(15, -5 + breathe);
            ctx.rotate(gunAngle);
            
            // Gun body
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, -4, 35, 8);
            // Gun stock
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(-15, -6, 18, 12);
            // Gun barrel
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(30, -3, 12, 6);
            
            // Muzzle flash
            if (hunter.muzzleFlash > 0) {
                const flashSize = hunter.muzzleFlash * 3;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(45, 0, flashSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(45, 0, flashSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Angry eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -32 + breathe, 3, 0, Math.PI * 2);
            ctx.arc(5, -32 + breathe, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyebrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -38 + breathe);
            ctx.lineTo(-2, -36 + breathe);
            ctx.moveTo(10, -38 + breathe);
            ctx.lineTo(2, -36 + breathe);
            ctx.stroke();
            
            // Show grace period indicator with countdown
            if (hunter.graceTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(hunter.graceTimer / 60);
                ctx.fillText('üí§ ' + secondsLeft + 's', 0, -70);
            } else if (hunter.isReloading) {
                // Show reloading indicator
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil((HUNTER_RELOAD_FRAMES - hunter.reloadTimer) / 60);
                ctx.fillText('üîÑ RELOADING ' + secondsLeft + 's', 0, -70);
                
                // Reload progress bar
                ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                ctx.fillRect(-30, -60, 60, 8);
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.fillRect(-30, -60, 60 * (hunter.reloadTimer / HUNTER_RELOAD_FRAMES), 8);
            } else {
                // Show shots remaining
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.font = 'bold 12px Fraunces';
                ctx.textAlign = 'center';
                const shotsLeft = 3 - hunter.shotsFired;
                ctx.fillText('üéØ ' + shotsLeft + ' shots', 0, -70);
            }
            
            ctx.restore();
        }
        
        function drawHunterWife() {
            if (!hunterWife) return;
            
            ctx.save();
            ctx.translate(hunterWife.x, hunterWife.y);
            
            // Face left (toward turkey)
            ctx.scale(-1, 1);
            
            const breathe = Math.sin(hunterWife.breathePhase || 0) * 1.5;
            const armSwing = hunterWife.armSwing || 0;
            
            // Draw net warning indicator when winding up
            if (hunterWife.isWindingUp) {
                ctx.globalAlpha = 0.2 + armSwing * 0.3;
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                const targetAngle = Math.atan2(turkey.y - hunterWife.y, hunterWife.x - turkey.x);
                ctx.moveTo(-30, 0);
                ctx.lineTo(-30 + Math.cos(targetAngle) * 150, Math.sin(targetAngle) * 150);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            }
            
            // Dress/body
            ctx.fillStyle = '#8B0000'; // Dark red dress
            ctx.beginPath();
            ctx.moveTo(-15, -15 + breathe);
            ctx.lineTo(-20, 35);
            ctx.lineTo(20, 35);
            ctx.lineTo(15, -15 + breathe);
            ctx.closePath();
            ctx.fill();
            
            // Apron
            ctx.fillStyle = '#FFF8DC';
            ctx.beginPath();
            ctx.moveTo(-10, -5 + breathe);
            ctx.lineTo(-12, 30);
            ctx.lineTo(12, 30);
            ctx.lineTo(10, -5 + breathe);
            ctx.closePath();
            ctx.fill();
            
            // Legs
            ctx.fillStyle = '#DEB887';
            const legSwing = Math.sin(hunterWife.animPhase || 0) * 3;
            ctx.fillRect(-10 + legSwing, 32, 8, 15);
            ctx.fillRect(2 - legSwing, 32, 8, 15);
            
            // Shoes
            ctx.fillStyle = '#2F1810';
            ctx.fillRect(-12 + legSwing, 45, 12, 5);
            ctx.fillRect(0 - legSwing, 45, 12, 5);
            
            // Arms
            ctx.fillStyle = '#DEB887';
            // Back arm
            ctx.fillRect(12, -10 + breathe, 8, 20);
            
            // Front arm holding net (animated)
            ctx.save();
            ctx.translate(-15, -5 + breathe);
            ctx.rotate(-0.3 - armSwing * 1.5); // Wind up rotation
            ctx.fillRect(0, 0, 8, 22);
            
            // Net in hand
            ctx.translate(4, 22);
            // Net pole
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-2, 0, 4, 40);
            // Net hoop
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 45, 25, 0, Math.PI * 2);
            ctx.stroke();
            // Net mesh
            ctx.strokeStyle = '#D2B48C';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(-20 + i * 8, 30);
                ctx.quadraticCurveTo(-10 + i * 4, 55, 0, 70);
                ctx.stroke();
            }
            ctx.restore();
            
            // Head
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(0, -25 + breathe, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // Hair - bun style
            ctx.fillStyle = '#4A3728';
            ctx.beginPath();
            ctx.arc(0, -25 + breathe, 14, Math.PI, 0);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, -38 + breathe, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-4, -27 + breathe, 2.5, 0, Math.PI * 2);
            ctx.arc(4, -27 + breathe, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Determined expression
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-7, -33 + breathe);
            ctx.lineTo(-2, -31 + breathe);
            ctx.moveTo(7, -33 + breathe);
            ctx.lineTo(2, -31 + breathe);
            ctx.stroke();
            
            // Status indicators
            ctx.scale(-1, 1); // Flip text back
            if (hunterWife.graceTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(hunterWife.graceTimer / 60);
                ctx.fillText('üéØ ' + secondsLeft + 's', 0, -60);
            } else if (hunterWife.isWindingUp) {
                ctx.fillStyle = 'rgba(255, 150, 50, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('ü•Ö THROWING!', 0, -60);
            } else {
                ctx.fillStyle = 'rgba(200, 150, 100, 0.8)';
                ctx.font = 'bold 12px Fraunces';
                ctx.textAlign = 'center';
                const cooldownLeft = Math.ceil((hunterWife.throwCooldown - hunterWife.throwTimer) / 60);
                ctx.fillText('ü•Ö ' + cooldownLeft + 's', 0, -60);
            }
            
            ctx.restore();
        }
        
        function drawThrownNets() {
            thrownNets.forEach(net => {
                ctx.save();
                ctx.translate(net.x, net.y);
                ctx.rotate(net.rotation);
                ctx.globalAlpha = net.life;
                
                const size = net.size;
                
                // Net hoop
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.stroke();
                
                // Net mesh
                ctx.strokeStyle = '#D2B48C';
                ctx.lineWidth = 2;
                // Radial lines
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * size / 2, Math.sin(angle) * size / 2);
                    ctx.stroke();
                }
                // Circular lines
                for (let r = 1; r <= 3; r++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, (size / 2) * (r / 3), 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Expanding danger effect
                if (net.expanding) {
                    ctx.strokeStyle = '#FF4500';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = net.life * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2 + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function drawThrownAxes() {
            thrownAxes.forEach(axe => {
                ctx.save();
                ctx.translate(axe.x, axe.y);
                ctx.rotate(axe.rotation);
                
                // Axe handle
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-3, -axe.size / 2, 6, axe.size);
                
                // Axe head
                ctx.fillStyle = '#708090';
                ctx.beginPath();
                ctx.moveTo(-3, -axe.size / 2);
                ctx.lineTo(-axe.size / 2 - 5, -axe.size / 2 + 5);
                ctx.lineTo(-axe.size / 2 - 5, -axe.size / 2 + 15);
                ctx.lineTo(-3, -axe.size / 2 + 10);
                ctx.closePath();
                ctx.fill();
                
                // Axe head other side
                ctx.beginPath();
                ctx.moveTo(3, -axe.size / 2);
                ctx.lineTo(axe.size / 2 + 5, -axe.size / 2 + 5);
                ctx.lineTo(axe.size / 2 + 5, -axe.size / 2 + 15);
                ctx.lineTo(3, -axe.size / 2 + 10);
                ctx.closePath();
                ctx.fill();
                
                // Metal shine
                ctx.strokeStyle = '#A9A9A9';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-axe.size / 2, -axe.size / 2 + 8);
                ctx.lineTo(axe.size / 2, -axe.size / 2 + 8);
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        function drawNetTrap() {
            if (!netTrap.isTrapped) return;
            
            ctx.save();
            ctx.translate(netTrap.trapX, netTrap.trapY);
            
            // Pulsing effect based on timer
            const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
            
            // Net surrounding turkey
            ctx.strokeStyle = `rgba(139, 69, 19, ${pulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.stroke();
            
            // Net mesh pattern
            ctx.strokeStyle = `rgba(210, 180, 140, ${pulse * 0.8})`;
            ctx.lineWidth = 2;
            
            // Radial lines
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * 50, Math.sin(angle) * 50);
                ctx.stroke();
            }
            
            // Circular lines
            for (let r = 1; r <= 4; r++) {
                ctx.beginPath();
                ctx.arc(0, 0, 50 * (r / 4), 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Danger indicator - countdown
            const secondsLeft = Math.ceil(netTrap.trapTimer / 60);
            ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
            ctx.font = 'bold 18px Fraunces';
            ctx.textAlign = 'center';
            ctx.fillText('‚ö†Ô∏è TRAPPED! ' + secondsLeft + 's', 0, -70);
            
            // Escape hint message - show peck instruction
            ctx.fillStyle = 'rgba(157, 193, 131, 0.95)';
            ctx.font = 'bold 14px Fraunces';
            ctx.fillText('üêî PECK to escape! (SPACE/Double-click)', 0, -90);
            
            // Warning flash when axe is coming
            if (netTrap.axeThrown && thrownAxes.length > 0) {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.8)';
                ctx.font = 'bold 14px Fraunces';
                ctx.fillText('ü™ì AXE INCOMING!', 0, 80);
            }
            
            ctx.restore();
        }
        
        function drawBarriers() {
            barriers.forEach(barrier => {
                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                
                if (barrier.type === 'haybale') {
                    // Draw hay bale
                    ctx.fillStyle = '#DAA520';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, barrier.width / 2, barrier.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hay texture lines
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    for (let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * 10 - 5, -barrier.height / 2 + 5);
                        ctx.lineTo(i * 10 + 5, barrier.height / 2 - 5);
                        ctx.stroke();
                    }
                    
                    // Binding ropes
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, -barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(0, barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (barrier.type === 'rock') {
                    // Draw rock
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 2, barrier.height / 4);
                    ctx.lineTo(-barrier.width / 3, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 4, -barrier.height / 2 + 5);
                    ctx.lineTo(barrier.width / 2, -barrier.height / 4);
                    ctx.lineTo(barrier.width / 2 - 5, barrier.height / 2);
                    ctx.lineTo(-barrier.width / 3, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Rock highlights
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 4, -barrier.height / 3);
                    ctx.lineTo(0, -barrier.height / 4);
                    ctx.lineTo(-barrier.width / 6, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (barrier.type === 'tree') {
                    // Draw tree stump/trunk
                    ctx.fillStyle = '#4A3728';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 4, barrier.width, barrier.height * 0.75);
                    
                    // Tree top (dark pine)
                    ctx.fillStyle = '#1a3a1a';
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 30);
                    ctx.lineTo(-barrier.width - 10, -barrier.height / 4);
                    ctx.lineTo(barrier.width + 10, -barrier.height / 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Second layer
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 10);
                    ctx.lineTo(-barrier.width - 5, 0);
                    ctx.lineTo(barrier.width + 5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bark texture
                    ctx.strokeStyle = '#3D2914';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-5, barrier.height / 2);
                    ctx.moveTo(5, -5);
                    ctx.lineTo(5, barrier.height / 2 - 10);
                    ctx.stroke();
                } else if (barrier.type === 'bunker') {
                    ctx.fillStyle = '#4c5c68';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.fillStyle = '#2f3941';
                    ctx.fillRect(-barrier.width / 2 + 10, -barrier.height / 2 + 10, barrier.width - 20, barrier.height - 20);
                    ctx.fillStyle = '#b0c4de';
                    ctx.beginPath();
                    ctx.arc(0, -barrier.height / 2 + 10, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (barrier.type === 'auroraTree') {
                    const gradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    gradient.addColorStop(0, '#5ef1ff');
                    gradient.addColorStop(1, '#5ef179');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2);
                    ctx.lineTo(-barrier.width / 2, barrier.height / 2);
                    ctx.lineTo(barrier.width / 2, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#2a3b4f';
                    ctx.fillRect(-8, barrier.height / 2, 16, 30);
                } else if (barrier.type === 'iceWall') {
                    const iceGradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    iceGradient.addColorStop(0, '#c8f3ff');
                    iceGradient.addColorStop(1, '#5ed0ff');
                    ctx.fillStyle = iceGradient;
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                } else if (barrier.type === 'cornWall') {
                    const time = Date.now() * 0.002;
                    const sway = Math.sin(time + (barrier.waveOffset || 0)) * 5;
                    ctx.fillStyle = '#f4d03f';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 2, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 2, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 2 + sway, barrier.height / 2);
                    ctx.lineTo(-barrier.width / 2 + sway, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#8e6b1a';
                    ctx.lineWidth = 2;
                    for (let stalkX = -barrier.width / 2 + 10; stalkX < barrier.width / 2; stalkX += 15) {
                        ctx.beginPath();
                        ctx.moveTo(stalkX, -barrier.height / 2);
                        ctx.lineTo(stalkX + sway * 0.2, barrier.height / 2);
                        ctx.stroke();
                    }
                } else if (barrier.type === 'floatStage') {
                    ctx.fillStyle = '#4c1b2f';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.fillStyle = '#ffefc1';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2 - 14, barrier.width, 14);
                } else if (barrier.type === 'balloonStack') {
                    const colors = ['#ff8fb1', '#ffd166', '#7df9ff'];
                    for (let b = 0; b < 3; b++) {
                        ctx.fillStyle = colors[b % colors.length];
                        ctx.beginPath();
                        ctx.arc((b - 1) * 12, -barrier.height / 2 + b * 28, 24, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-3, -barrier.height / 2, 6, barrier.height);
                } else if (barrier.type === 'workshopRail') {
                    const wobble = Math.sin(Date.now() * 0.003 + (barrier.waveOffset || 0)) * 4;
                    ctx.fillStyle = '#ff8fb1';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2 + wobble, barrier.width, barrier.height);
                }
                
                ctx.restore();
            });
        }

        // Draw the glowing labyrinth exit
        function drawLabyrinthExit() {
            if (!labyrinthExit || !isLabyrinthLevel()) return;
            
            ctx.save();
            ctx.translate(labyrinthExit.x, labyrinthExit.y);
            
            // Update pulse animation
            labyrinthExit.pulsePhase = (labyrinthExit.pulsePhase || 0) + 0.05;
            const pulse = Math.sin(labyrinthExit.pulsePhase) * 0.3 + 0.7;
            const outerPulse = Math.sin(labyrinthExit.pulsePhase * 0.5) * 0.2 + 0.8;
            
            // Outer glow rings
            for (let i = 3; i >= 0; i--) {
                const ringSize = labyrinthExit.width * (1.2 + i * 0.25) * outerPulse;
                const alpha = (0.15 - i * 0.03) * pulse;
                ctx.beginPath();
                ctx.arc(0, 0, ringSize / 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 150, ${alpha})`;
                ctx.fill();
            }
            
            // Main exit portal - different style based on level
            const exitSize = labyrinthExit.width * 0.8;
            
            // Swirling portal effect
            const time = Date.now() * 0.002;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, exitSize / 2);
            
            if (currentLevel === LEVEL_IDS.SPACE_ESCAPE) {
                // Space warp gate - purple/blue
                gradient.addColorStop(0, `rgba(200, 150, 255, ${pulse})`);
                gradient.addColorStop(0.5, `rgba(100, 50, 200, ${pulse * 0.8})`);
                gradient.addColorStop(1, `rgba(50, 0, 100, ${pulse * 0.5})`);
            } else if (currentLevel === LEVEL_IDS.WOOD_ESCAPE) {
                // Forest exit - green/gold
                gradient.addColorStop(0, `rgba(200, 255, 150, ${pulse})`);
                gradient.addColorStop(0.5, `rgba(100, 200, 50, ${pulse * 0.8})`);
                gradient.addColorStop(1, `rgba(50, 100, 0, ${pulse * 0.5})`);
            } else if (currentLevel === LEVEL_IDS.BARN_ESCAPE) {
                // Barn exit - golden/orange
                gradient.addColorStop(0, `rgba(255, 230, 150, ${pulse})`);
                gradient.addColorStop(0.5, `rgba(255, 180, 50, ${pulse * 0.8})`);
                gradient.addColorStop(1, `rgba(180, 100, 0, ${pulse * 0.5})`);
            } else {
                // Corn labyrinth - yellow/green
                gradient.addColorStop(0, `rgba(255, 255, 150, ${pulse})`);
                gradient.addColorStop(0.5, `rgba(200, 220, 50, ${pulse * 0.8})`);
                gradient.addColorStop(1, `rgba(100, 150, 0, ${pulse * 0.5})`);
            }
            
            ctx.beginPath();
            ctx.arc(0, 0, exitSize / 2, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Swirl lines
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.6})`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                const startAngle = time + i * Math.PI / 2;
                ctx.arc(0, 0, exitSize * 0.3, startAngle, startAngle + Math.PI * 0.5);
                ctx.stroke();
            }
            
            // Exit arrow pointing up
            ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.beginPath();
            ctx.moveTo(0, -exitSize * 0.25);
            ctx.lineTo(-exitSize * 0.15, exitSize * 0.05);
            ctx.lineTo(exitSize * 0.15, exitSize * 0.05);
            ctx.closePath();
            ctx.fill();
            
            // "EXIT" text
            ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.font = 'bold 14px Fraunces';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('EXIT', 0, exitSize * 0.2);
            
            ctx.restore();
        }

        function drawBomber() {
            if (!bomber) return;
            ctx.save();
            ctx.translate(bomber.x, bomber.y);
            ctx.fillStyle = '#2b3e4f';
            ctx.beginPath();
            ctx.moveTo(-bomber.width / 2, bomber.height / 2);
            ctx.lineTo(0, -bomber.height / 2);
            ctx.lineTo(bomber.width / 2, bomber.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#1b2a35';
            ctx.fillRect(-20, -10, 40, 20);
            
            const glow = 0.5 + Math.sin(bomber.stealthPulse) * 0.4;
            ctx.strokeStyle = `rgba(173,216,230,${glow})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, bomber.width / 2, Math.PI, 0);
            ctx.stroke();
            ctx.restore();

            // Status text
            ctx.save();
            ctx.fillStyle = '#DAA520';
            ctx.font = '16px Fraunces';
            ctx.textAlign = 'center';
            if (bomber.graceTimer > 0) {
                ctx.fillText('Stealth bomber incoming...', bomber.x, bomber.y - 60);
            } else if (bomber.isReloading) {
                const secondsLeft = Math.ceil((bomber.reloadFrames - bomber.reloadTimer) / 60);
                ctx.fillText(`Reloading bomb bay: ${secondsLeft}s`, bomber.x, bomber.y - 60);
            } else if (!bomber.activeBomb) {
                ctx.fillText('Bomb bay ready!', bomber.x, bomber.y - 60);
            }
            ctx.restore();
        }

        function drawBomberBombs() {
            bomberBombs.forEach(bomb => {
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#888';
                ctx.beginPath();
                ctx.moveTo(-5, -15);
                ctx.lineTo(-5, 15);
                ctx.moveTo(5, -15);
                ctx.lineTo(5, 15);
                ctx.stroke();
                ctx.restore();
                
                if (!bomb.exploded) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,69,0,0.2)';
                    ctx.setLineDash([6, 10]);
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, bomb.explosionRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function drawAuroraWaves() {
            auroraWaves.forEach(wave => {
                ctx.save();
                ctx.strokeStyle = `rgba(126,255,212,${wave.alpha})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 12]);
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            ctx.setLineDash([]);
        }

        function drawAuroraBlasts() {
            auroraBlasts.forEach(blast => {
                ctx.save();
                const innerRadius = Math.max(10, blast.radius - 40);
                const outerRadius = blast.radius + 80;
                const gradient = ctx.createRadialGradient(
                    blast.x,
                    blast.y,
                    innerRadius,
                    blast.x,
                    blast.y,
                    outerRadius
                );
                gradient.addColorStop(0, `rgba(94,241,255,${blast.alpha * 0.4})`);
                gradient.addColorStop(0.5, `rgba(168,85,255,${blast.alpha * 0.6})`);
                gradient.addColorStop(1, 'rgba(8,17,32,0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(blast.x, blast.y, outerRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(212,255,249,${blast.alpha})`;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(blast.x, blast.y, blast.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawRoamingAuroras() {
            if (!roamingAuroras.length) return;
            const time = Date.now() * 0.0005;
            roamingAuroras.forEach(sprite => {
                const gradient = ctx.createRadialGradient(
                    sprite.x,
                    sprite.y,
                    sprite.radius * 0.2,
                    sprite.x,
                    sprite.y,
                    sprite.radius
                );
                gradient.addColorStop(0, sprite.innerColor);
                gradient.addColorStop(1, sprite.outerColor);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    sprite.x,
                    sprite.y,
                    sprite.radius * 0.8,
                    sprite.radius,
                    Math.sin(time + sprite.wobbleOffset) * 0.4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
        }

        function drawProjectiles() {
            bossProjectiles.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                
                if (proj.type === 'bullet' || proj.isHunter) {
                    // Hunter bullet rendered as a glowing flare round
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const flicker = 1 + Math.sin((Date.now() + proj.x + proj.y) * 0.02) * 0.15;
                    const tailLength = Math.max(45, proj.size * 4) * flicker;
                    ctx.rotate(angle);
                    
                    // Bright tail streak
                    ctx.globalCompositeOperation = 'lighter';
                    const tailGradient = ctx.createLinearGradient(0, 0, -tailLength, 0);
                    tailGradient.addColorStop(0, 'rgba(255,240,200,0.95)');
                    tailGradient.addColorStop(0.4, 'rgba(255,130,70,0.8)');
                    tailGradient.addColorStop(1, 'rgba(120,30,0,0)');
                    ctx.strokeStyle = tailGradient;
                    ctx.lineWidth = Math.max(3, proj.size * 0.7);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-tailLength, 0);
                    ctx.stroke();
                    
                    // Flare core
                    ctx.shadowColor = 'rgba(255,160,80,0.8)';
                    ctx.shadowBlur = 12;
                    const flareGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, proj.size * 1.2);
                    flareGradient.addColorStop(0, 'rgba(255,255,255,0.95)');
                    flareGradient.addColorStop(0.3, 'rgba(255,230,180,0.9)');
                    flareGradient.addColorStop(0.9, 'rgba(255,90,20,0.2)');
                    ctx.fillStyle = flareGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, proj.size * 1.2, proj.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nose cone glint
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-proj.size * 0.2, -proj.size * 0.35);
                    ctx.lineTo(proj.size * 0.8, 0);
                    ctx.lineTo(-proj.size * 0.2, proj.size * 0.35);
                    ctx.stroke();
                } else if (proj.type === 'auroraStreak') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    const tailLength = proj.trailLength || 140;
                    ctx.rotate(angle);
                    ctx.lineWidth = 6;
                    const gradient = ctx.createLinearGradient(0, 0, -tailLength, 0);
                    gradient.addColorStop(0, proj.color || '#7FFFD4');
                    gradient.addColorStop(0.7, 'rgba(168,85,255,0.6)');
                    gradient.addColorStop(1, 'rgba(8,16,32,0)');
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-tailLength, 0);
                    ctx.stroke();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'aurora') {
                    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, proj.size);
                    gradient.addColorStop(0, proj.color || '#7FFFD4');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'auroraNova') {
                    const pulse = 1 + Math.sin(Date.now() * 0.01 + proj.life * 0.05) * 0.15;
                    const radius = proj.size * pulse;
                    const gradient = ctx.createRadialGradient(0, 0, radius * 0.4, 0, 0, radius);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                    gradient.addColorStop(0.5, proj.color || 'rgba(126,255,212,0.8)');
                    gradient.addColorStop(1, 'rgba(8,17,32,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Pie slice projectile
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, proj.size, 0, Math.PI / 3);
                    ctx.fill();
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawParadeConfetti() {
            paradeConfetti.forEach(piece => {
                ctx.save();
                ctx.translate(piece.x, piece.y);
                ctx.rotate(piece.rotation || 0);
                ctx.globalAlpha = Math.max(0, piece.life);
                ctx.fillStyle = piece.color;
                
                // Draw different confetti shapes
                const size = piece.size || 4;
                const shapeType = Math.floor((piece.x + piece.y) * 100) % 3;
                
                if (shapeType === 0) {
                    // Square
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else if (shapeType === 1) {
                    // Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Rectangle streamer
                    ctx.fillRect(-size/4, -size, size/2, size * 2);
                }
                
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            if (roamingAuroras.length) {
                drawRoamingAuroras();
            }
            
            if (gameState === 'playing' || gameState === 'boss') {
                drawBarriers(); // Draw barriers behind other elements
                drawLabyrinthExit(); // Draw exit portal for labyrinth levels
                apples.forEach(drawApple);
                if (currentLevel === LEVEL_IDS.STEALTH_BOMBER) {
                    drawBomberBombs();
                }
                drawProjectiles();
                if (auroraBlasts.length) {
                    drawAuroraBlasts();
                }
                if (auroraWaves.length) {
                    drawAuroraWaves();
                }
                drawPeckIndicator(); // Draw peck range indicator behind turkey
                drawTurkey();
                if (boss) drawBoss();
                if (hunter) drawHunter();
                if (hunterWife) drawHunterWife();
                if (thrownNets.length) drawThrownNets();
                if (thrownAxes.length) drawThrownAxes();
                if (netTrap.isTrapped) drawNetTrap();
                if (currentLevel === LEVEL_IDS.STEALTH_BOMBER && bomber) {
                    drawBomber();
                }
                drawParticles();
                drawParadeConfetti();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        updateLeftoverUI();
        updateUI();
        draw();
    </script>
</body>
</html>
