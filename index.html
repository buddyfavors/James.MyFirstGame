<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turkey Evolution - Thanksgiving Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;700;900&family=Caveat:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --autumn-orange: #D2691E;
            --harvest-gold: #DAA520;
            --pumpkin: #FF7518;
            --cranberry: #9F1D35;
            --turkey-brown: #8B4513;
            --sage-green: #9DC183;
            --cream: #FFFDD0;
            --bark: #3D2914;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Fraunces', serif;
            background: linear-gradient(135deg, #2D1B0E 0%, #4A2C17 50%, #1A0F05 100%);
            min-height: 100vh;
            min-height: 100dvh;
            margin: 0;
            display: block;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: linear-gradient(180deg, #87CEEB 0%, #FDB347 30%, #D2691E 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .level-display {
            font-family: 'Caveat', cursive;
            font-size: 28px;
            color: var(--cream);
            text-shadow: 3px 3px 0 var(--bark), -1px -1px 0 var(--bark);
            background: linear-gradient(135deg, var(--cranberry), var(--turkey-brown));
            padding: 8px 20px;
            border-radius: 30px;
            border: 3px solid var(--harvest-gold);
        }

        .score-display {
            font-size: 22px;
            color: var(--harvest-gold);
            text-shadow: 2px 2px 0 var(--bark);
        }

        .xp-bar-container {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            max-width: 80%;
            height: 25px;
            background: var(--bark);
            border-radius: 15px;
            border: 3px solid var(--harvest-gold);
            overflow: hidden;
            box-shadow: inset 0 3px 10px rgba(0,0,0,0.5);
        }

        .xp-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--sage-green), var(--pumpkin), var(--cranberry));
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--pumpkin);
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            color: var(--cream);
            text-shadow: 1px 1px 2px var(--bark);
        }

        /* Mobile UI adjustments */
        @media (max-width: 600px) {
            .ui-overlay {
                padding: 8px 12px;
            }
            
            .level-display {
                font-size: 18px;
                padding: 5px 12px;
                border-width: 2px;
            }
            
            .score-display {
                font-size: 18px;
            }
            
            .xp-bar-container {
                height: 20px;
                bottom: 10px;
            }
            
            .xp-text {
                font-size: 11px;
            }
        }

        .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(29, 15, 5, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: safe center;
            z-index: 100;
            overflow-y: auto;
            padding: 20px 10px;
            -webkit-overflow-scrolling: touch;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-family: 'Caveat', cursive;
            font-size: 64px;
            color: var(--pumpkin);
            text-shadow: 4px 4px 0 var(--cranberry), 8px 8px 0 var(--bark);
            margin-bottom: 20px;
            animation: wobble 2s ease-in-out infinite;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }

        .subtitle {
            font-size: 24px;
            color: var(--harvest-gold);
            margin-bottom: 30px;
        }

        .instructions {
            color: var(--cream);
            font-size: 18px;
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
            margin-bottom: 30px;
            padding: 0 15px;
        }

        .btn {
            font-family: 'Fraunces', serif;
            font-size: 24px;
            font-weight: 700;
            padding: 15px 50px;
            background: linear-gradient(135deg, var(--pumpkin), var(--autumn-orange));
            color: var(--cream);
            border: 4px solid var(--harvest-gold);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 2px 2px 0 var(--bark);
            box-shadow: 0 6px 0 var(--bark), 0 10px 20px rgba(0,0,0,0.3);
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 var(--bark), 0 15px 30px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 var(--bark), 0 5px 10px rgba(0,0,0,0.3);
        }

        .level-name {
            font-family: 'Caveat', cursive;
            font-size: 48px;
            color: var(--sage-green);
            text-shadow: 3px 3px 0 var(--bark);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .boss-name {
            color: var(--cranberry);
            font-size: 56px;
        }

        .turkey-emoji {
            font-size: 80px;
            animation: bounce 0.5s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--harvest-gold);
            font-size: 14px;
            opacity: 0.8;
        }

        /* Touch indicator for mobile */
        .touch-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid var(--harvest-gold);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 50;
            background: radial-gradient(circle, rgba(218,165,32,0.3) 0%, transparent 70%);
        }

        .touch-indicator.visible {
            opacity: 1;
        }

        .touch-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: var(--harvest-gold);
            border-radius: 50%;
        }

        /* Mobile screen adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 36px;
                text-shadow: 2px 2px 0 var(--cranberry), 4px 4px 0 var(--bark);
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .instructions {
                font-size: 14px;
                line-height: 1.5;
                margin-bottom: 20px;
                max-width: 90%;
            }

            .btn {
                font-size: 18px;
                padding: 12px 35px;
                border-width: 3px;
            }

            .level-name {
                font-size: 32px;
            }

            .boss-name {
                font-size: 36px;
            }

            .turkey-emoji {
                font-size: 50px;
            }

            .touch-indicator {
                width: 60px;
                height: 60px;
                border-width: 3px;
            }

            .touch-indicator::after {
                width: 14px;
                height: 14px;
            }
        }

        @media (max-height: 500px) {
            h1 {
                font-size: 28px;
                margin-bottom: 8px;
            }

            .subtitle {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .instructions {
                font-size: 12px;
                margin-bottom: 12px;
            }

            .turkey-emoji {
                font-size: 40px;
            }

            .btn {
                font-size: 16px;
                padding: 10px 30px;
            }
        }

        /* Extra small height screens (small phones in landscape or very compact screens) */
        @media (max-height: 400px) {
            .start-screen, .game-over-screen, .level-up-screen, .boss-screen, .win-screen {
                justify-content: flex-start;
                padding-top: 10px;
            }

            h1 {
                font-size: 24px;
                margin-bottom: 5px;
            }

            .subtitle {
                font-size: 12px;
                margin-bottom: 8px;
            }

            .instructions {
                font-size: 11px;
                margin-bottom: 10px;
                line-height: 1.3;
            }

            .turkey-emoji {
                font-size: 30px;
            }

            .btn {
                font-size: 14px;
                padding: 8px 25px;
                margin-bottom: 10px;
            }
        }

        /* Ensure button is always tappable and visible */
        .btn {
            min-height: 44px;
            min-width: 120px;
            flex-shrink: 0;
        }

        /* Show/hide controls based on device */
        .mobile-controls {
            display: none;
        }

        .desktop-controls {
            display: inline;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: inline;
            }

            .desktop-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
        
        <!-- Touch indicator for mobile -->
        <div class="touch-indicator" id="touchIndicator"></div>
        
        <div class="ui-overlay">
            <div class="level-display" id="levelDisplay">Level 1: Barn Turkey Barn</div>
            <div class="score-display"><span id="scoreIcon" aria-hidden="true">üçé</span> <span id="scoreDisplay">0</span></div>
        </div>
        
        <div class="xp-bar-container">
            <div class="xp-bar" id="xpBar" style="width: 0%"></div>
            <div class="xp-text" id="xpText">0 / 10 XP</div>
        </div>

        <div class="start-screen" id="startScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Turkey Evolution</h1>
            <p class="subtitle">A Thanksgiving Adventure</p>
            <div class="instructions">
                You're a hungry turkey with a BIG mouth!<br><br>
                üéØ Gobble apples, grow absurdly huge, and outsmart every Thanksgiving trap.<br>
                ü§Ø Each run throws in new chaos‚Äîmischievous hunters, stealth bombers, even cosmic food fights.<br>
                ü•ß Just keep snacking, pecking, and surviving‚Ä¶ there are way more levels than we should spoil here.<br><br>
                <span class="desktop-controls">Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move<br>Press <strong>SPACE</strong> to peck attack!</span>
                <span class="mobile-controls">üëÜ <strong>Touch & drag</strong> anywhere to move<br>üëÜüëÜ <strong>Double-tap</strong> to peck attack!</span>
            </div>
            <button class="btn" onclick="startGame()">Start Gobbling!</button>
            <a href="vr.html" style="display: block; margin-top: 20px; color: #DAA520; font-size: 16px; text-decoration: none; opacity: 0.9;">ü•Ω Try VR Version</a>
        </div>

        <div class="level-up-screen hidden" id="levelUpScreen">
            <div class="turkey-emoji">ü¶É</div>
            <h1>Level Up!</h1>
            <p class="level-name" id="newLevelName">Turkey Run</p>
            <p class="instructions" id="levelDescription">You've escaped the barn! Now run through the fields!</p>
            <p class="instructions" id="levelCountdown" aria-live="polite" style="display: none;">Press SPACE or wait 10s for the next level.</p>
            <button class="btn" onclick="continueGame()">Continue</button>
        </div>

        <div class="boss-screen hidden" id="bossScreen">
            <div style="font-size: 80px;" id="bossEmoji">ü•ß</div>
            <h1>Boss Fight!</h1>
            <p class="boss-name" id="bossName">Pumpkin Pie</p>
            <p class="instructions" id="bossInstructions">The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck from range (<span class="desktop-controls">SPACE</span><span class="mobile-controls">double-tap</span>)<br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!</p>
            <button class="btn" onclick="startBossFight()">Fight!</button>
        </div>

        <div class="game-over-screen hidden" id="gameOverScreen">
            <div style="font-size: 80px;">üíÄ</div>
            <h1>Game Over!</h1>
            <p class="subtitle" id="deathMessage">The turkey has been caught!</p>
            <p class="instructions">Final Score: <span id="finalScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Try Again</button>
        </div>

        <div class="win-screen hidden" id="winScreen">
            <div style="font-size: 80px;">üèÜ</div>
            <h1>Victory!</h1>
            <p class="level-name">The Turkey Survives Thanksgiving!</p>
            <p class="instructions">You've evolved from a barn turkey to a legendary survivor!<br><br>Final Score: <span id="winScore">0</span> treats</p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const touchIndicator = document.getElementById('touchIndicator');
        const gameContainer = document.querySelector('.game-container');
        const bossEmojiEl = document.getElementById('bossEmoji');
        const bossNameEl = document.getElementById('bossName');
        const bossInstructionsEl = document.getElementById('bossInstructions');
        const scoreIconEl = document.getElementById('scoreIcon');
        const levelCountdownEl = document.getElementById('levelCountdown');

        // Base canvas dimensions (used for game logic)
        const BASE_WIDTH = 600;
        const BASE_HEIGHT = 800;

        const BOSS_TYPES = {
            PUMPKIN: 'pumpkinPie',
            AURORA: 'auroraSpirit'
        };

        // Game State
        let gameState = 'start'; // start, playing, levelup, boss, gameover, win
        let currentLevel = 1;
        let score = 0;
        let xp = 0;
        let xpNeeded = 10;
        let nextBossType = null;
        let levelCountdownInterval = null;
        let levelCountdownRemaining = 0;

        // Touch state
        let touchActive = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let canvasScale = 1;

        // Peck attack state
        let peckCooldown = 0;
        const PECK_COOLDOWN_MAX = 30; // frames between pecks
        const PECK_RANGE = 100; // distance to peck the boss
        const PECK_DAMAGE = 1;
        let isPecking = false;
        let peckAnimTimer = 0;

        // Level definitions
        const levels = {
            1: { name: 'Barn Turkey Barn', xpNeeded: 10, bgColor: '#8B4513', description: 'Eat apples in the cozy barn!' },
            2: { name: 'Turkey Run', xpNeeded: 15, bgColor: '#228B22', description: 'Run through the autumn fields!' },
            3: { name: 'Hunter Hunt Down', xpNeeded: 20, bgColor: '#2F4F4F', description: 'Hide behind barriers to survive! The hunter is waking up...' },
            4: { name: 'Stealth Bomber Siege', xpNeeded: 3, bgColor: '#0f1a2b', description: 'B-2 bomber overhead! Survive 3 bombing runs.' },
            5: { name: 'Northern Lights Siege', xpNeeded: 1, bgColor: '#082137', description: 'Aurora beast attacks! Pineapples fuel your survival.' }
        };

        // Turkey
        const turkey = {
            x: 300,
            y: 400,
            width: 60,
            height: 50,
            speed: 5,
            mouthOpen: 0,
            direction: 1,
            evolution: 1
        };

        // Apples
        let apples = [];

        // Boss
        let boss = null;
        let bossProjectiles = [];

        // Hunter (Level 3)
        let hunter = null;

        // Bomber (Level 4)
        let bomber = null;
        let bomberBombs = [];
        let bomberRoundsSurvived = 0;

        // Northern lights effects
        let auroraWaves = [];

        // Barriers for hiding
        let barriers = [];

        // Particles
        let particles = [];

        // Input
        const keys = {};

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                if (gameState === 'levelup') {
                    e.preventDefault();
                    continueGame();
                    return;
                }
                
                // Peck attack on space bar
                if (gameState === 'boss' || gameState === 'playing') {
                    e.preventDefault();
                    tryPeckAttack();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });
        
        // Peck attack function
        function tryPeckAttack() {
            if (peckCooldown > 0) return;
            if (gameState !== 'boss' || !boss) return;
            
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            
            if (distToBoss < PECK_RANGE + bossRadius) {
                // Successful peck!
                isPecking = true;
                peckAnimTimer = 15;
                peckCooldown = PECK_COOLDOWN_MAX;
                
                // Damage boss
                const damage = boss.type === BOSS_TYPES.AURORA ? PECK_DAMAGE + 1 : PECK_DAMAGE;
                boss.health -= damage;
                
                // Visual feedback
                const hitColor = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FF7518';
                spawnParticles(boss.x, boss.y, hitColor, 12);
                spawnParticles(turkey.x + turkey.direction * 30, turkey.y - 10, '#FFD700', 8);
                
                // Knockback effect on boss
                if (boss.type !== BOSS_TYPES.AURORA) {
                    boss.x += (boss.x - turkey.x) * 0.1;
                }
                
                if (boss.health <= 0) {
                    const primaryBurst = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FFD700';
                    const secondaryBurst = boss.type === BOSS_TYPES.AURORA ? '#a855ff' : '#FF7518';
                    spawnParticles(boss.x, boss.y, primaryBurst, 30);
                    spawnParticles(boss.x, boss.y, secondaryBurst, 20);
                    if (boss.type !== BOSS_TYPES.AURORA) {
                        spawnParticles(boss.x, boss.y, '#FFFAF0', 15);
                    }
                    boss = null;
                    levelUp();
                }
                
                updateUI();
            } else {
                // Out of range - still show peck animation but no damage
                isPecking = true;
                peckAnimTimer = 10;
                peckCooldown = PECK_COOLDOWN_MAX / 2; // Shorter cooldown for missed peck
                spawnParticles(turkey.x + turkey.direction * 40, turkey.y - 5, '#FFA500', 3);
            }
        }

        // Touch event helpers
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (touch.clientX - rect.left) / canvasScale,
                y: (touch.clientY - rect.top) / canvasScale
            };
        }

        function updateTouchIndicator(clientX, clientY) {
            const rect = gameContainer.getBoundingClientRect();
            const indicatorSize = touchIndicator.offsetWidth || 80;
            const offset = indicatorSize / 2;
            touchIndicator.style.left = (clientX - rect.left - offset) + 'px';
            touchIndicator.style.top = (clientY - rect.top - offset) + 'px';
        }

        // Double-tap detection for peck attack
        let lastTapTime = 0;
        const DOUBLE_TAP_DELAY = 300; // ms

        // Touch events for dragging movement
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState !== 'playing' && gameState !== 'boss') return;
            
            const touch = e.touches[0];
            const currentTime = Date.now();
            
            // Check for double-tap
            if (currentTime - lastTapTime < DOUBLE_TAP_DELAY) {
                tryPeckAttack();
                lastTapTime = 0; // Reset to prevent triple-tap triggering
            } else {
                lastTapTime = currentTime;
            }
            
            touchActive = true;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchCurrentX = touch.clientX;
            touchCurrentY = touch.clientY;
            
            touchIndicator.classList.add('visible');
            updateTouchIndicator(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive) return;
            
            const touch = e.touches[0];
            touchCurrentX = touch.clientX;
            touchCurrentY = touch.clientY;
            
            updateTouchIndicator(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
            touchIndicator.classList.remove('visible');
        }, { passive: false });

        canvas.addEventListener('touchcancel', (e) => {
            touchActive = false;
            touchIndicator.classList.remove('visible');
        });

        // Handle window resize for responsive canvas
        function resizeCanvas() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            gameContainer.style.width = viewportWidth + 'px';
            gameContainer.style.height = viewportHeight + 'px';
            
            const scaleX = viewportWidth / BASE_WIDTH;
            const scaleY = viewportHeight / BASE_HEIGHT;
            canvasScale = Math.min(scaleX, scaleY);
            
            const newWidth = Math.floor(BASE_WIDTH * canvasScale);
            const newHeight = Math.floor(BASE_HEIGHT * canvasScale);
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function configureBossScreen(type) {
            if (type === BOSS_TYPES.AURORA) {
                bossEmojiEl.textContent = 'üåå';
                bossNameEl.textContent = 'Northern Light Monster';
                bossInstructionsEl.innerHTML = 'The Aurora Beast awakens!<br>üçç Pineapples are your only ammo<br>üå≤ Hide behind the glowing trees<br>üëä Peck or lob pineapples after it charges';
            } else {
                bossEmojiEl.textContent = 'ü•ß';
                bossNameEl.textContent = 'Pumpkin Pie';
                bossInstructionsEl.innerHTML = 'The dreaded Pumpkin Pie appears!<br>üçé Eat apples to damage it<br>üëä Peck from range (<span class="desktop-controls">SPACE</span><span class="mobile-controls">double-tap</span>)<br>ü¶É Or just <strong>EAT THE BOSS</strong> directly!';
            }
        }

        function queueBossFight(type) {
            nextBossType = type;
            configureBossScreen(type);
            document.getElementById('bossScreen').classList.remove('hidden');
            gameState = 'boss'; // boss intro state
        }

        function clearLevelCountdown() {
            if (levelCountdownInterval !== null) {
                clearInterval(levelCountdownInterval);
                levelCountdownInterval = null;
            }
            levelCountdownRemaining = 0;
            if (levelCountdownEl) {
                levelCountdownEl.style.display = 'none';
            }
        }

        function startLevelCountdown() {
            if (!levelCountdownEl) return;
            clearLevelCountdown();
            levelCountdownRemaining = 10;
            levelCountdownEl.style.display = 'block';
            levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
            levelCountdownInterval = setInterval(() => {
                if (gameState !== 'levelup') {
                    clearLevelCountdown();
                    return;
                }
                levelCountdownRemaining--;
                if (levelCountdownRemaining <= 0) {
                    clearInterval(levelCountdownInterval);
                    levelCountdownInterval = null;
                    levelCountdownEl.textContent = 'Starting next level...';
                    if (gameState === 'levelup') {
                        continueGame();
                    }
                } else {
                    levelCountdownEl.textContent = `Press SPACE or wait ${levelCountdownRemaining}s for the next level.`;
                }
            }, 1000);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameState = 'playing';
            resetLevel();
            gameLoop();
        }

        function continueGame() {
            if (gameState !== 'levelup') return;
            clearLevelCountdown();
            document.getElementById('levelUpScreen').classList.add('hidden');
            gameState = 'playing';
            resetLevel();
        }

        function startBossFight() {
            document.getElementById('bossScreen').classList.add('hidden');
            initBoss(nextBossType || BOSS_TYPES.PUMPKIN);
            nextBossType = null;
            gameState = 'boss';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            clearLevelCountdown();
            currentLevel = 1;
            score = 0;
            xp = 0;
            turkey.evolution = 1;
            turkey.x = 300;
            turkey.y = 400;
            gameState = 'playing';
            resetLevel();
        }

        function resetLevel() {
            apples = [];
            particles = [];
            bossProjectiles = [];
            bomberBombs = [];
            auroraWaves = [];
            boss = null;
            hunter = null;
            bomber = null;
            barriers = [];
            xp = 0;
            bomberRoundsSurvived = 0;
            xpNeeded = (levels[currentLevel] && levels[currentLevel].xpNeeded) || 10;
            turkey.x = 300;
            turkey.y = 400;
            
            const shouldSpawnCollectibles = currentLevel !== 5;
            const initialCollectibles = currentLevel === 4 ? 6 : 5;
            if (shouldSpawnCollectibles) {
                for (let i = 0; i < initialCollectibles; i++) {
                    spawnApple();
                }
            }

            if (currentLevel === 3) {
                initHunterEncounter();
            } else if (currentLevel === 4) {
                spawnBarriersForLevel(4);
                initBomberLevel();
            } else if (currentLevel === 5) {
                spawnBarriersForLevel(5);
                queueBossFight(BOSS_TYPES.AURORA);
            }

            updateUI();
        }
        
        function initHunterEncounter() {
            hunter = {
                x: BASE_WIDTH / 2,
                y: BASE_HEIGHT / 2,
                width: 50,
                height: 70,
                speed: 0,
                shootTimer: 0,
                graceTimer: 180,
                shotsFired: 0,
                reloadTimer: 0,
                isReloading: false
            };
            
            spawnBarriersForLevel(3);
            
            const corners = [
                { x: 80, y: 100 },
                { x: BASE_WIDTH - 80, y: 100 },
                { x: 80, y: BASE_HEIGHT - 150 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 150 }
            ];
            const randomCorner = corners[Math.floor(Math.random() * corners.length)];
            turkey.x = randomCorner.x;
            turkey.y = randomCorner.y;
        }

        function spawnBarriersForLevel(level) {
            barriers = [];
            if (level === 3) {
                const barrierPositions = [
                    { x: 120, y: 150, type: 'haybale' },
                    { x: BASE_WIDTH - 120, y: 150, type: 'haybale' },
                    { x: 120, y: BASE_HEIGHT - 200, type: 'haybale' },
                    { x: BASE_WIDTH - 120, y: BASE_HEIGHT - 200, type: 'haybale' },
                    { x: BASE_WIDTH / 2 - 150, y: BASE_HEIGHT / 2 - 100, type: 'rock' },
                    { x: BASE_WIDTH / 2 + 150, y: BASE_HEIGHT / 2 - 100, type: 'rock' },
                    { x: BASE_WIDTH / 2 - 150, y: BASE_HEIGHT / 2 + 150, type: 'rock' },
                    { x: BASE_WIDTH / 2 + 150, y: BASE_HEIGHT / 2 + 150, type: 'rock' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 - 180, type: 'tree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 + 200, type: 'tree' }
                ];
                
                barrierPositions.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.type === 'tree' ? 40 : 60,
                        height: pos.type === 'tree' ? 80 : 45,
                        type: pos.type
                    });
                });
            } else if (level === 4) {
                const bunkerRows = [
                    { x: BASE_WIDTH / 2 - 200, y: BASE_HEIGHT - 220 },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT - 260 },
                    { x: BASE_WIDTH / 2 + 200, y: BASE_HEIGHT - 220 }
                ];
                bunkerRows.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: 80,
                        height: 40,
                        type: 'bunker'
                    });
                });
                // scatter trees for cover
                for (let i = 0; i < 4; i++) {
                    barriers.push({
                        x: 80 + i * 120,
                        y: 200 + (i % 2) * 150,
                        width: 40,
                        height: 90,
                        type: 'tree'
                    });
                }
            } else if (level === 5) {
                // glowing pine obstacles
                const crystalRings = [
                    { x: BASE_WIDTH / 2 - 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 + 180, y: BASE_HEIGHT / 2, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 - 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2, y: BASE_HEIGHT / 2 + 160, type: 'auroraTree' },
                    { x: BASE_WIDTH / 2 - 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' },
                    { x: BASE_WIDTH / 2 + 90, y: BASE_HEIGHT / 2 + 120, type: 'iceWall' }
                ];
                crystalRings.forEach(pos => {
                    barriers.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.type === 'iceWall' ? 70 : 50,
                        height: pos.type === 'iceWall' ? 120 : 100,
                        type: pos.type
                    });
                });
            }
        }

        function initBomberLevel() {
            bomber = {
                x: BASE_WIDTH / 2,
                y: 230, // Slightly lower so it clears the UI overlay
                width: 160,
                height: 50,
                direction: 1,
                speed: 1.5,
                stealthPulse: 0,
                graceTimer: 180,
                isReloading: false,
                reloadTimer: 0,
                reloadFrames: 360, // 6 seconds at ~60fps for faster reloads
                activeBomb: null,
                roundsToSurvive: 3
            };
        }

        function dropBomberBomb() {
            if (!bomber) return;
            const targetX = turkey.x + (Math.random() - 0.5) * 120;
            const bomb = {
                x: bomber.x,
                y: bomber.y + 30,
                vx: (targetX - bomber.x) / 120,
                vy: 1.5,
                gravity: 0.08,
                exploded: false,
                explosionRadius: 120,
                trailTimer: 0
            };
            bomberBombs.push(bomb);
            bomber.activeBomb = bomb;
            bomber.isReloading = true;
            bomber.reloadTimer = 0;
        }

        function updateBomber() {
            if (!bomber || currentLevel !== 4 || gameState !== 'playing') return;
            
            bomber.stealthPulse += 0.02;
            bomber.x += bomber.speed * bomber.direction;
            if (bomber.x < 80 || bomber.x > BASE_WIDTH - 80) {
                bomber.direction *= -1;
            }

            if (bomber.graceTimer > 0) {
                bomber.graceTimer--;
                return;
            }

            if (!bomber.activeBomb && !bomber.isReloading && bomberRoundsSurvived < bomber.roundsToSurvive) {
                dropBomberBomb();
            }

            if (bomber.isReloading) {
                bomber.reloadTimer++;
                if (bomber.reloadTimer >= bomber.reloadFrames) {
                    bomber.isReloading = false;
                    bomber.reloadTimer = 0;
                    bomber.activeBomb = null;
                }
            }
        }

        function resolveBombExplosion(bomb) {
            spawnParticles(bomb.x, bomb.y, '#FFA500', 20);
            spawnParticles(bomb.x, bomb.y, '#FF4500', 20);
            const dist = Math.hypot(turkey.x - bomb.x, turkey.y - bomb.y);
            if (dist < bomb.explosionRadius) {
                gameOver('The stealth bomber roasted you!');
                return true;
            }
            bomberRoundsSurvived++;
            xp = bomberRoundsSurvived;
            bomber.activeBomb = null;
            if (bomberRoundsSurvived >= bomber.roundsToSurvive) {
                levelUp();
            }
            updateUI();
            return false;
        }

        function updateBomberBombs() {
            if (!bomber || currentLevel !== 4) return;
            for (let i = bomberBombs.length - 1; i >= 0; i--) {
                const bomb = bomberBombs[i];
                if (!bomb.exploded) {
                    bomb.vy += bomb.gravity;
                    bomb.x += bomb.vx;
                    bomb.y += bomb.vy;
                    
                    bomb.trailTimer++;
                    if (bomb.trailTimer % 5 === 0) {
                        spawnParticles(bomb.x, bomb.y, '#B0C4DE', 2);
                    }

                    // Barrier collision
                    for (let j = 0; j < barriers.length; j++) {
                        const barrier = barriers[j];
                        if (bomb.x > barrier.x - barrier.width / 2 &&
                            bomb.x < barrier.x + barrier.width / 2 &&
                            bomb.y > barrier.y - barrier.height / 2 &&
                            bomb.y < barrier.y + barrier.height / 2) {
                            bomb.exploded = true;
                            barriers.splice(j, 1);
                            if (resolveBombExplosion(bomb)) return;
                            bomberBombs.splice(i, 1);
                            break;
                        }
                    }

                    if (bomb.y >= BASE_HEIGHT - 80) {
                        bomb.exploded = true;
                        if (resolveBombExplosion(bomb)) return;
                        bomberBombs.splice(i, 1);
                        continue;
                    }
                }
            }
        }

        function initBoss(type = BOSS_TYPES.PUMPKIN) {
            if (type === BOSS_TYPES.AURORA) {
                boss = {
                    type,
                    x: BASE_WIDTH / 2,
                    y: BASE_HEIGHT / 2 - 120,
                    radius: 90,
                    health: 18,
                    maxHealth: 18,
                    attackTimer: 0,
                    graceTimer: 240,
                    pulse: 0
                };
            } else {
                boss = {
                    type: BOSS_TYPES.PUMPKIN,
                    x: 300,
                    y: 150,
                    width: 100,
                    height: 100,
                    health: 10,
                    maxHealth: 10,
                    speed: 2,
                    direction: 1,
                    attackTimer: 0,
                    opacity: 1,
                    shotsThrown: 0,
                    missingSlices: [],
                    currentScale: 1
                };
            }
            
            const corners = [
                { x: 80, y: BASE_HEIGHT - 150 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 150 },
                { x: 80, y: BASE_HEIGHT - 300 },
                { x: BASE_WIDTH - 80, y: BASE_HEIGHT - 300 }
            ];
            const randomCorner = corners[Math.floor(Math.random() * corners.length)];
            turkey.x = randomCorner.x;
            turkey.y = randomCorner.y;
            
            apples = [];
            const initialDrops = type === BOSS_TYPES.AURORA ? 6 : 3;
            for (let i = 0; i < initialDrops; i++) {
                spawnApple();
            }
        }

        function spawnApple() {
            apples.push({
                x: Math.random() * (BASE_WIDTH - 100) + 50,
                y: Math.random() * (BASE_HEIGHT - 150) + 50,
                size: 25,
                rotation: Math.random() * Math.PI * 2,
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function spawnParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 8 + 4,
                    color: color,
                    life: 1
                });
            }
        }

        function updateUI() {
            if (gameState === 'win' || !levels[currentLevel]) return;
            
            scoreIconEl.textContent = currentLevel === 5 ? 'üçç' : 'üçé';
            document.getElementById('levelDisplay').textContent = `Level ${currentLevel}: ${levels[currentLevel].name}`;
            document.getElementById('scoreDisplay').textContent = score;

            let filled = xp;
            let needed = xpNeeded;
            let label = 'XP';

            if (currentLevel === 4) {
                filled = bomberRoundsSurvived;
                needed = (bomber && bomber.roundsToSurvive) || xpNeeded;
                label = 'Rounds Survived';
            } else if (currentLevel === 5 && boss && boss.type === BOSS_TYPES.AURORA) {
                filled = Math.max(0, boss.health);
                needed = boss.maxHealth;
                label = 'Boss HP';
            }

            const xpPercent = needed > 0 ? Math.min(100, (filled / needed) * 100) : 0;
            document.getElementById('xpBar').style.width = xpPercent + '%';
            const displayValue = Math.max(0, Math.round(filled));
            document.getElementById('xpText').textContent = `${label}: ${displayValue} / ${needed}`;
        }

        function update() {
            if (gameState !== 'playing' && gameState !== 'boss') return;

            // Update peck cooldowns
            if (peckCooldown > 0) peckCooldown--;
            if (peckAnimTimer > 0) {
                peckAnimTimer--;
            } else {
                isPecking = false;
            }

            // Move turkey
            let dx = 0, dy = 0;
            
            // Keyboard input
            if (keys['arrowleft'] || keys['a'] || keys['ArrowLeft']) dx -= 1;
            if (keys['arrowright'] || keys['d'] || keys['ArrowRight']) dx += 1;
            if (keys['arrowup'] || keys['w'] || keys['ArrowUp']) dy -= 1;
            if (keys['arrowdown'] || keys['s'] || keys['ArrowDown']) dy += 1;

            // Touch/drag input - movement based on drag direction from start point
            if (touchActive) {
                const dragDx = touchCurrentX - touchStartX;
                const dragDy = touchCurrentY - touchStartY;
                const dragDist = Math.hypot(dragDx, dragDy);
                
                // Dead zone of 10 pixels to prevent accidental movement
                if (dragDist > 10) {
                    // Normalize and scale by drag distance (more drag = faster movement)
                    const intensity = Math.min(dragDist / 50, 1.5); // Cap at 1.5x speed
                    dx += (dragDx / dragDist) * intensity;
                    dy += (dragDy / dragDist) * intensity;
                }
            }

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                const speedMultiplier = touchActive ? Math.min(Math.hypot(touchCurrentX - touchStartX, touchCurrentY - touchStartY) / 50, 1.5) : 1;
                turkey.x += dx * turkey.speed * speedMultiplier;
                turkey.y += dy * turkey.speed * speedMultiplier;
                turkey.direction = dx >= 0 ? 1 : -1;
            }

            // Animate mouth
            turkey.mouthOpen = Math.sin(Date.now() / 100) * 0.3 + 0.3;

            // Clamp position
            turkey.x = Math.max(turkey.width / 2, Math.min(BASE_WIDTH - turkey.width / 2, turkey.x));
            turkey.y = Math.max(turkey.height / 2, Math.min(BASE_HEIGHT - turkey.height / 2 - 30, turkey.y));

            // Check apple collisions
            for (let i = apples.length - 1; i >= 0; i--) {
                const apple = apples[i];
                const dist = Math.hypot(turkey.x - apple.x, turkey.y - apple.y);
                if (dist < turkey.width / 2 + apple.size / 2) {
                    const isPineappleRound = currentLevel === 5;
                    const fruitColor = isPineappleRound ? '#FFA500' : '#FF0000';
                    const leafColor = isPineappleRound ? '#2E8B57' : '#00FF00';
                    spawnParticles(apple.x, apple.y, fruitColor, 8);
                    spawnParticles(apple.x, apple.y, leafColor, 4);
                    apples.splice(i, 1);
                    score++;
                    
                    if (gameState === 'boss' && boss) {
                        const damage = boss.type === BOSS_TYPES.AURORA ? 2 : 1;
                        boss.health -= damage;
                        const bossParticleColor = boss.type === BOSS_TYPES.AURORA ? '#7FFFD4' : '#FF7518';
                        spawnParticles(boss.x, boss.y, bossParticleColor, 15);
                        if (boss.health <= 0) {
                            spawnParticles(boss.x, boss.y, '#FFD700', 30);
                            boss = null;
                            levelUp();
                        }
                    } else if (currentLevel !== 4 && gameState !== 'boss') {
                        xp++;
                        if (xp >= xpNeeded) {
                            if (currentLevel === 1) {
                                queueBossFight(BOSS_TYPES.PUMPKIN);
                            } else {
                                levelUp();
                            }
                        }
                    }
                    
                    spawnApple();
                    updateUI();
                }
            }

            // Update boss
            if (gameState === 'boss' && boss) {
                if (boss.type === BOSS_TYPES.AURORA) {
                    updateAuroraBoss();
                } else {
                    updatePumpkinBoss();
                }
            }

            // Update hunter (level 3) - Hunter stays in center but still shoots
            if (hunter && gameState === 'playing') {
                // Hunter stays in place - no movement code

                // Grace period at the start - hunter doesn't shoot immediately
                if (hunter.graceTimer > 0) {
                    hunter.graceTimer--;
                } else if (hunter.isReloading) {
                    // Hunter is reloading - 10 seconds (600 frames at 60fps)
                    hunter.reloadTimer++;
                    if (hunter.reloadTimer >= 600) {
                        hunter.isReloading = false;
                        hunter.reloadTimer = 0;
                        hunter.shotsFired = 0;
                    }
                } else {
                    // Hunter can shoot - fires 3 shots then reloads
                    hunter.shootTimer++;
                    if (hunter.shootTimer > 60) { // Slightly faster between shots in burst
                        hunter.shootTimer = 0;
                        const angle = Math.atan2(turkey.y - hunter.y, turkey.x - hunter.x);
                        bossProjectiles.push({
                            x: hunter.x,
                            y: hunter.y,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            size: 15,
                            isHunter: true,
                            type: 'bullet',
                            onHitMessage: 'You got shot!'
                        });
                        
                        hunter.shotsFired++;
                        if (hunter.shotsFired >= 3) {
                            // Start reloading after 3 shots
                            hunter.isReloading = true;
                        }
                    }
                }

            }

            if (currentLevel === 4 && gameState === 'playing') {
                updateBomber();
                updateBomberBombs();
            }

            // Update projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const proj = bossProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;

                // Check collision with turkey
                const dist = Math.hypot(turkey.x - proj.x, turkey.y - proj.y);
                if (dist < turkey.width / 2 + proj.size / 2) {
                    const message = proj.onHitMessage || (proj.isHunter ? 'You got shot!' : 'You were blasted!');
                    gameOver(message);
                    return;
                }
                
                // Check collision with barriers (projectiles get blocked)
                let hitBarrier = false;
                for (const barrier of barriers) {
                    if (proj.x > barrier.x - barrier.width / 2 &&
                        proj.x < barrier.x + barrier.width / 2 &&
                        proj.y > barrier.y - barrier.height / 2 &&
                        proj.y < barrier.y + barrier.height / 2) {
                        // Projectile hit barrier - destroy it with particles
                        const impactColor = proj.type === 'aurora' ? '#7FFFD4' : (proj.isHunter ? '#555' : '#FF7518');
                        spawnParticles(proj.x, proj.y, impactColor, 6);
                        bossProjectiles.splice(i, 1);
                        hitBarrier = true;
                        break;
                    }
                }
                if (hitBarrier) continue;

                // Remove off-screen
                if (proj.x < -50 || proj.x > canvas.width + 50 || proj.y < -50 || proj.y > canvas.height + 50) {
                    bossProjectiles.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            for (let i = auroraWaves.length - 1; i >= 0; i--) {
                const wave = auroraWaves[i];
                wave.radius += 3;
                wave.alpha -= 0.01;
                if (wave.alpha <= 0 || wave.radius >= wave.maxRadius) {
                    auroraWaves.splice(i, 1);
                }
            }
        }

        function updatePumpkinBoss() {
            boss.x += boss.speed * boss.direction;
            if (boss.x < 100 || boss.x > BASE_WIDTH - 100) {
                boss.direction *= -1;
            }

            boss.attackTimer++;
            if (boss.attackTimer > 60) {
                boss.attackTimer = 0;
                
                const sliceAngle = (boss.shotsThrown % 8) * (Math.PI / 4);
                boss.missingSlices.push(sliceAngle);
                
                const throwOffsetX = Math.cos(sliceAngle + Math.PI / 8) * (boss.width / 2 * boss.currentScale);
                const throwOffsetY = Math.sin(sliceAngle + Math.PI / 8) * (boss.height / 2 * boss.currentScale);
                
                bossProjectiles.push({
                    x: boss.x + throwOffsetX,
                    y: boss.y + throwOffsetY,
                    vx: (Math.random() - 0.5) * 4 + throwOffsetX * 0.05,
                    vy: 6,
                    size: 20,
                    type: 'pie',
                    onHitMessage: 'The pie got you!'
                });
                
                boss.shotsThrown++;
                boss.health -= 0.3;
                boss.currentScale = Math.max(0.4, 1 - (boss.shotsThrown * 0.06));
                boss.opacity = Math.max(0.3, 1 - (boss.shotsThrown * 0.03));
                
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FF7518', 10);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#DEB887', 6);
                spawnParticles(boss.x + throwOffsetX, boss.y + throwOffsetY, '#FFFAF0', 4);
                
                if (boss.health <= 0) {
                    spawnParticles(boss.x, boss.y, '#FFD700', 30);
                    spawnParticles(boss.x, boss.y, '#FF7518', 20);
                    spawnParticles(boss.x, boss.y, '#FFFAF0', 15);
                    boss = null;
                    levelUp();
                    updateUI();
                    return;
                }
                
                updateUI();
            }

            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const eatRange = turkey.width / 2 + boss.width / 2 - 10;
            
            if (distToBoss < eatRange) {
                boss.eatCooldown = boss.eatCooldown || 0;
                boss.eatCooldown--;
                
                if (boss.eatCooldown <= 0) {
                    boss.eatCooldown = 20;
                    boss.health -= 2;
                    
                    turkey.mouthOpen = 1;
                    spawnParticles(boss.x, boss.y, '#FF7518', 15);
                    spawnParticles(boss.x, boss.y, '#DEB887', 8);
                    spawnParticles(turkey.x + turkey.direction * 30, turkey.y, '#FFD700', 5);
                    
                    const pushDir = boss.x > turkey.x ? 1 : -1;
                    boss.x += pushDir * 15;
                    
                    if (boss.health <= 0) {
                        spawnParticles(boss.x, boss.y, '#FFD700', 40);
                        spawnParticles(boss.x, boss.y, '#FF7518', 30);
                        spawnParticles(boss.x, boss.y, '#FFFAF0', 20);
                        boss = null;
                        score += 5;
                        levelUp();
                        updateUI();
                        return;
                    }
                    
                    updateUI();
                }
            }
        }

        function updateAuroraBoss() {
            boss.pulse += 0.02;

            if (boss.graceTimer > 0) {
                boss.graceTimer--;
                return;
            }

            boss.attackTimer++;

            if (boss.attackTimer % 45 === 0) {
                const volley = 3;
                const baseAngle = Math.atan2(turkey.y - boss.y, turkey.x - boss.x);
                for (let i = 0; i < volley; i++) {
                    const offset = (i - 1) * 0.2;
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(baseAngle + offset) * 4.5,
                        vy: Math.sin(baseAngle + offset) * 4.5,
                        size: 22,
                        type: 'aurora',
                        color: `hsl(${180 + i * 40}, 80%, 70%)`,
                        onHitMessage: 'The northern lights consumed you!'
                    });
                }
                spawnParticles(boss.x, boss.y, '#7FFFD4', 12);
            }

            if (boss.attackTimer % 180 === 0) {
                auroraWaves.push({
                    x: boss.x,
                    y: boss.y,
                    radius: boss.radius,
                    maxRadius: boss.radius + 260,
                    alpha: 0.7
                });
            }
        }
        function levelUp() {
            currentLevel++;
            turkey.evolution++;
            
            if (currentLevel > 5) {
                gameState = 'win';
                document.getElementById('winScore').textContent = score;
                document.getElementById('winScreen').classList.remove('hidden');
                return;
            }

            gameState = 'levelup';
            document.getElementById('newLevelName').textContent = levels[currentLevel].name;
            document.getElementById('levelDescription').textContent = levels[currentLevel].description;
            document.getElementById('levelUpScreen').classList.remove('hidden');
            startLevelCountdown();
        }

        function gameOver(message) {
            gameState = 'gameover';
            document.getElementById('deathMessage').textContent = message;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const isPumpkinBossField = boss && boss.type === BOSS_TYPES.PUMPKIN && currentLevel === 1;
            const isAuroraBattle = boss && boss.type === BOSS_TYPES.AURORA;
            const backdropLevel = isAuroraBattle ? 5 : (isPumpkinBossField ? 2 : currentLevel);
            
            switch (backdropLevel) {
                case 1: {
                    gradient.addColorStop(0, '#8B4513');
                    gradient.addColorStop(1, '#5D3A1A');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#4A2C17';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < canvas.width; i += 60) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, canvas.height);
                        ctx.stroke();
                    }
                    
                    ctx.fillStyle = '#DAA520';
                    for (let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        ctx.ellipse(
                            (i * 25) % canvas.width,
                            canvas.height - 30 + Math.sin(i) * 10,
                            20, 8, 0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    break;
                }
                case 2: {
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(0.6, '#FDB347');
                    gradient.addColorStop(1, '#228B22');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    
                    for (let i = 0; i < 4; i++) {
                        const tx = i * 160 + 50;
                        ctx.fillStyle = '#5D3A1A';
                        ctx.fillRect(tx - 10, canvas.height - 180, 20, 100);
                        ctx.beginPath();
                        ctx.fillStyle = ['#FF6347', '#FF8C00', '#FFD700', '#DC143C'][i % 4];
                        ctx.arc(tx, canvas.height - 200, 50, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                }
                case 4: {
                    gradient.addColorStop(0, '#030711');
                    gradient.addColorStop(1, '#0f1a2b');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#ffffff22';
                    for (let i = 0; i < 80; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * canvas.width, Math.random() * 200, Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#1a3a1a';
                    ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
                    break;
                }
                case 5: {
                    gradient.addColorStop(0, '#05030f');
                    gradient.addColorStop(0.5, '#112144');
                    gradient.addColorStop(1, '#04121f');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const auroraColors = ['#5ef1ff', '#a855ff', '#5ef179', '#ffd15e'];
                    auroraColors.forEach((color, index) => {
                        ctx.beginPath();
                        ctx.moveTo(0, 200 + index * 30);
                        for (let x = 0; x <= canvas.width; x += 20) {
                            const y = 200 + index * 30 + Math.sin((x / canvas.width) * Math.PI * 2 + index) * 40;
                            ctx.lineTo(x, y);
                        }
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.lineTo(0, canvas.height);
                        ctx.closePath();
                        ctx.fillStyle = color + '33';
                        ctx.fill();
                    });
                    
                    ctx.fillStyle = '#0b1d2c';
                    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                    break;
                }
                default: {
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#16213e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#FFFACD';
                    ctx.beginPath();
                    ctx.arc(500, 80, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0f0f23';
                    for (let i = 0; i < 6; i++) {
                        const tx = i * 100;
                        ctx.beginPath();
                        ctx.moveTo(tx, canvas.height);
                        ctx.lineTo(tx + 40, canvas.height - 250 - Math.random() * 100);
                        ctx.lineTo(tx + 80, canvas.height);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#2d4a3e';
                    ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                }
            }
        }

        function drawTurkey() {
            ctx.save();
            ctx.translate(turkey.x, turkey.y);
            ctx.scale(turkey.direction, 1);
            
            const scale = 1 + (turkey.evolution - 1) * 0.2;
            ctx.scale(scale, scale);
            
            // Peck animation - lunge forward
            const peckLunge = isPecking ? Math.sin((peckAnimTimer / 15) * Math.PI) * 20 : 0;
            ctx.translate(peckLunge, 0);
            
            // Tail feathers
            const tailColors = ['#8B0000', '#FF4500', '#FFD700', '#8B4513', '#FF6347'];
            for (let i = 0; i < 5; i++) {
                ctx.fillStyle = tailColors[i];
                ctx.beginPath();
                const angle = (i - 2) * 0.4 - Math.PI / 2;
                ctx.ellipse(
                    Math.cos(angle) * 25 - 10 - peckLunge, // Tail stays back during peck
                    Math.sin(angle) * 25 - 5,
                    12, 30,
                    angle + Math.PI / 2,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Body
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(0, 5, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head - move forward extra during peck
            const headExtend = isPecking ? 10 : 0;
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(20 + headExtend, -5, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Wattle (red thing under beak)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(28 + headExtend, 5, 5, 10, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Snood (red thing on top)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(25 + headExtend, -15, 4, 8, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // BIG MOUTH / Beak - extra extended during peck
            const beakExtend = isPecking ? 25 : 0;
            ctx.fillStyle = isPecking ? '#FF6600' : '#FFA500'; // Brighter orange when pecking
            ctx.beginPath();
            const mouthOpenAmount = isPecking ? 8 : turkey.mouthOpen * 15; // Closed beak during peck for sharp hit
            // Upper beak
            ctx.moveTo(30 + headExtend, -8);
            ctx.lineTo(55 + headExtend + beakExtend, -5 - mouthOpenAmount);
            ctx.lineTo(30 + headExtend, -2);
            ctx.fill();
            // Lower beak
            ctx.beginPath();
            ctx.moveTo(30 + headExtend, -2);
            ctx.lineTo(55 + headExtend + beakExtend, 5 + mouthOpenAmount);
            ctx.lineTo(30 + headExtend, 2);
            ctx.fill();
            
            // Peck impact effect
            if (isPecking && peckAnimTimer > 10) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                // Impact lines
                for (let i = 0; i < 4; i++) {
                    const angle = (i - 1.5) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(60 + headExtend + beakExtend, -2);
                    ctx.lineTo(75 + headExtend + beakExtend + Math.cos(angle) * 15, -2 + Math.sin(angle) * 15);
                    ctx.stroke();
                }
            }
            
            // Eye - angry during peck
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(25 + headExtend, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(26 + headExtend, -9, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyebrow during peck
            if (isPecking) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20 + headExtend, -15);
                ctx.lineTo(30 + headExtend, -13);
                ctx.stroke();
            }
            
            // Legs
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-5, 20);
            ctx.lineTo(-8, 35);
            ctx.moveTo(-8, 35);
            ctx.lineTo(-15, 40);
            ctx.moveTo(-8, 35);
            ctx.lineTo(-5, 42);
            ctx.moveTo(-8, 35);
            ctx.lineTo(-2, 40);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(5, 20);
            ctx.lineTo(8, 35);
            ctx.moveTo(8, 35);
            ctx.lineTo(2, 40);
            ctx.moveTo(8, 35);
            ctx.lineTo(8, 42);
            ctx.moveTo(8, 35);
            ctx.lineTo(15, 40);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawApple(apple) {
            ctx.save();
            ctx.translate(apple.x, apple.y + Math.sin(Date.now() / 300 + apple.bobOffset) * 5);
            
            if (currentLevel === 5) {
                // Pineapple body
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.ellipse(0, 0, apple.size / 2.2, apple.size / 1.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#D67A00';
                ctx.lineWidth = 2;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, apple.size / 2.5, apple.size / 1.8, i * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Leaves
                ctx.fillStyle = '#1f8a5c';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse((i - 1.5) * 5, -apple.size / 1.4 - i * 2, 6, 16, (i - 1.5) * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                return;
            }
            
            // Apple body
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(0, 0, apple.size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(-5, -5, apple.size / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Stem
            ctx.strokeStyle = '#5D3A1A';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -apple.size / 2);
            ctx.lineTo(2, -apple.size / 2 - 8);
            ctx.stroke();
            
            // Leaf
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(6, -apple.size / 2 - 5, 6, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPeckIndicator() {
            if (gameState !== 'boss' || !boss) return;
            
            const distToBoss = Math.hypot(turkey.x - boss.x, turkey.y - boss.y);
            const bossRadius = boss.type === BOSS_TYPES.AURORA ? boss.radius : boss.width / 2;
            const inRange = distToBoss < PECK_RANGE + bossRadius;
            
            // Draw range circle around turkey
            ctx.save();
            ctx.translate(turkey.x, turkey.y);
            
            // Range indicator
            ctx.strokeStyle = inRange ? 'rgba(255, 215, 0, 0.6)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = inRange ? 3 : 1;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.arc(0, 0, PECK_RANGE, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Cooldown indicator (arc that fills up as cooldown resets)
            if (peckCooldown > 0) {
                const cooldownPercent = peckCooldown / PECK_COOLDOWN_MAX;
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 35, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownPercent) * Math.PI * 2);
                ctx.stroke();
            } else if (inRange) {
                // Ready to peck indicator
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                ctx.fillText('PECK!', 0, -45);
            }
            
            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            if (boss.type === BOSS_TYPES.AURORA) {
                drawAuroraBossSprite();
            } else {
                drawPumpkinBossSprite();
            }
        }

        function drawPumpkinBossSprite() {
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            // Apply fading opacity - boss fades as it throws more pies
            ctx.globalAlpha = boss.opacity;
            
            // Apply shrinking scale
            const scale = boss.currentScale;
            ctx.scale(scale, scale);
            
            // Pie dish (also shrinks)
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(0, boss.height / 2 - 10, boss.width / 2 + 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw pie with missing slices
            const sliceCount = 8;
            const sliceAngle = Math.PI * 2 / sliceCount;
            
            for (let i = 0; i < sliceCount; i++) {
                const startAngle = i * sliceAngle;
                const endAngle = startAngle + sliceAngle - 0.05; // Small gap between slices
                
                // Check if this slice is missing
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - startAngle) < 0.1;
                });
                
                if (!isMissing) {
                    // Draw pie filling slice
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw crust edge on this slice
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, boss.width / 2 - 2, startAngle, endAngle);
                    ctx.stroke();
                } else {
                    // Draw empty/bitten area where slice was
                    ctx.fillStyle = 'rgba(139, 90, 43, 0.3)'; // Dark inner pie color
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, boss.width / 2 - 15, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Whipped cream swirls (only on remaining slices)
            ctx.fillStyle = '#FFFAF0';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const sliceIndex = Math.floor(angle / sliceAngle);
                const isMissing = boss.missingSlices.some(missAngle => {
                    return Math.abs(missAngle - sliceIndex * sliceAngle) < 0.1;
                });
                
                if (!isMissing) {
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(angle) * 25,
                        Math.sin(angle) * 25,
                        10, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Center cream dollop (gets smaller as more slices are gone)
            const centerSize = Math.max(5, 15 - boss.missingSlices.length);
            ctx.beginPath();
            ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil face (shrinks with the pie)
            ctx.fillStyle = '#000';
            // Eyes
            ctx.beginPath();
            ctx.arc(-15, -5, 6, 0, Math.PI * 2);
            ctx.arc(15, -5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Evil eyebrows - get more distressed as health drops
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const eyebrowLift = boss.missingSlices.length * 2;
            ctx.moveTo(-25, -15 - eyebrowLift);
            ctx.lineTo(-8, -12);
            ctx.moveTo(25, -15 - eyebrowLift);
            ctx.lineTo(8, -12);
            ctx.stroke();
            
            // Evil smile (becomes worried frown as health drops)
            ctx.beginPath();
            if (boss.missingSlices.length > 4) {
                // Worried frown
                ctx.arc(0, 20, 12, Math.PI + 0.3, -0.3);
            } else {
                // Evil smile
                ctx.arc(0, 10, 15, 0.2, Math.PI - 0.2);
            }
            ctx.stroke();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for health bar
            
            // Health bar - always fully visible even when boss is fading
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#333';
            ctx.fillRect(boss.x - 40, boss.y - boss.height / 2 - 20, 80, 10);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(boss.x - 38, boss.y - boss.height / 2 - 18, 76 * Math.max(0, boss.health / boss.maxHealth), 6);
            
            ctx.restore();
        }

        function drawAuroraBossSprite() {
            ctx.save();
            ctx.translate(boss.x, boss.y);
            const pulse = 0.9 + Math.sin(boss.pulse) * 0.1;
            const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, boss.radius * pulse);
            gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.4, 'rgba(126,255,212,0.8)');
            gradient.addColorStop(0.7, 'rgba(94,241,255,0.6)');
            gradient.addColorStop(1, 'rgba(72,61,139,0.2)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#b9f2ff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, boss.radius * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            
            // Eyes
            ctx.fillStyle = '#0b1220';
            ctx.beginPath();
            ctx.ellipse(-20, -10, 8, 18, 0.3, 0, Math.PI * 2);
            ctx.ellipse(20, -10, 8, 18, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth beam
            ctx.strokeStyle = '#7fffd4';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(-25, 20);
            ctx.quadraticCurveTo(0, 35 + Math.sin(boss.pulse) * 5, 25, 20);
            ctx.stroke();
            
            ctx.restore();
            
            // Health bar & text
            ctx.save();
            ctx.fillStyle = '#0b1220';
            ctx.fillRect(boss.x - 60, boss.y - boss.radius - 30, 120, 12);
            ctx.fillStyle = '#7fffd4';
            const healthPercent = Math.max(0, boss.health / boss.maxHealth);
            ctx.fillRect(boss.x - 58, boss.y - boss.radius - 28, 116 * healthPercent, 8);
            
            if (boss.graceTimer > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = '18px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(boss.graceTimer / 60);
                ctx.fillText(`Aurora charging... ${secondsLeft}s`, boss.x, boss.y - boss.radius - 50);
            }
            ctx.restore();
        }

        function drawHunter() {
            if (!hunter) return;
            
            ctx.save();
            ctx.translate(hunter.x, hunter.y);
            
            // Body
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(-15, -20, 30, 40);
            
            // Head
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(0, -30, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Hunter hat
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(-18, -45, 36, 10);
            ctx.fillRect(-12, -55, 24, 12);
            
            // Gun
            ctx.fillStyle = '#333';
            ctx.fillRect(-30, -5, 25, 6);
            ctx.fillRect(-35, -8, 8, 12);
            
            // Legs
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-12, 20, 10, 25);
            ctx.fillRect(2, 20, 10, 25);
            
            // Angry eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -32, 3, 0, Math.PI * 2);
            ctx.arc(5, -32, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Show grace period indicator with countdown
            if (hunter.graceTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil(hunter.graceTimer / 60);
                ctx.fillText('üí§ ' + secondsLeft + 's', 0, -70);
                
                // Warning text for player
                ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                ctx.font = 'bold 18px Fraunces';
                ctx.fillText('FIND COVER!', 0, 80);
            } else if (hunter.isReloading) {
                // Show reloading indicator
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.font = 'bold 14px Fraunces';
                ctx.textAlign = 'center';
                const secondsLeft = Math.ceil((600 - hunter.reloadTimer) / 60);
                ctx.fillText('üîÑ RELOADING ' + secondsLeft + 's', 0, -70);
                
                // Reload progress bar
                ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                ctx.fillRect(-30, -60, 60, 8);
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.fillRect(-30, -60, 60 * (hunter.reloadTimer / 600), 8);
            } else {
                // Show shots remaining
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.font = 'bold 12px Fraunces';
                ctx.textAlign = 'center';
                const shotsLeft = 3 - hunter.shotsFired;
                ctx.fillText('üéØ ' + shotsLeft + ' shots', 0, -70);
            }
            
            ctx.restore();
        }
        
        function drawBarriers() {
            barriers.forEach(barrier => {
                ctx.save();
                ctx.translate(barrier.x, barrier.y);
                
                if (barrier.type === 'haybale') {
                    // Draw hay bale
                    ctx.fillStyle = '#DAA520';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, barrier.width / 2, barrier.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hay texture lines
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    for (let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * 10 - 5, -barrier.height / 2 + 5);
                        ctx.lineTo(i * 10 + 5, barrier.height / 2 - 5);
                        ctx.stroke();
                    }
                    
                    // Binding ropes
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, -barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(0, barrier.height / 4, barrier.width / 2 - 3, 5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (barrier.type === 'rock') {
                    // Draw rock
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 2, barrier.height / 4);
                    ctx.lineTo(-barrier.width / 3, -barrier.height / 2);
                    ctx.lineTo(barrier.width / 4, -barrier.height / 2 + 5);
                    ctx.lineTo(barrier.width / 2, -barrier.height / 4);
                    ctx.lineTo(barrier.width / 2 - 5, barrier.height / 2);
                    ctx.lineTo(-barrier.width / 3, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Rock highlights
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.moveTo(-barrier.width / 4, -barrier.height / 3);
                    ctx.lineTo(0, -barrier.height / 4);
                    ctx.lineTo(-barrier.width / 6, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (barrier.type === 'tree') {
                    // Draw tree stump/trunk
                    ctx.fillStyle = '#4A3728';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 4, barrier.width, barrier.height * 0.75);
                    
                    // Tree top (dark pine)
                    ctx.fillStyle = '#1a3a1a';
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 30);
                    ctx.lineTo(-barrier.width - 10, -barrier.height / 4);
                    ctx.lineTo(barrier.width + 10, -barrier.height / 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Second layer
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2 - 10);
                    ctx.lineTo(-barrier.width - 5, 0);
                    ctx.lineTo(barrier.width + 5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bark texture
                    ctx.strokeStyle = '#3D2914';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-5, barrier.height / 2);
                    ctx.moveTo(5, -5);
                    ctx.lineTo(5, barrier.height / 2 - 10);
                    ctx.stroke();
                } else if (barrier.type === 'bunker') {
                    ctx.fillStyle = '#4c5c68';
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.fillStyle = '#2f3941';
                    ctx.fillRect(-barrier.width / 2 + 10, -barrier.height / 2 + 10, barrier.width - 20, barrier.height - 20);
                    ctx.fillStyle = '#b0c4de';
                    ctx.beginPath();
                    ctx.arc(0, -barrier.height / 2 + 10, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (barrier.type === 'auroraTree') {
                    const gradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    gradient.addColorStop(0, '#5ef1ff');
                    gradient.addColorStop(1, '#5ef179');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -barrier.height / 2);
                    ctx.lineTo(-barrier.width / 2, barrier.height / 2);
                    ctx.lineTo(barrier.width / 2, barrier.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#2a3b4f';
                    ctx.fillRect(-8, barrier.height / 2, 16, 30);
                } else if (barrier.type === 'iceWall') {
                    const iceGradient = ctx.createLinearGradient(0, -barrier.height / 2, 0, barrier.height / 2);
                    iceGradient.addColorStop(0, '#c8f3ff');
                    iceGradient.addColorStop(1, '#5ed0ff');
                    ctx.fillStyle = iceGradient;
                    ctx.fillRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-barrier.width / 2, -barrier.height / 2, barrier.width, barrier.height);
                }
                
                ctx.restore();
            });
        }

        function drawBomber() {
            if (!bomber) return;
            ctx.save();
            ctx.translate(bomber.x, bomber.y);
            ctx.fillStyle = '#2b3e4f';
            ctx.beginPath();
            ctx.moveTo(-bomber.width / 2, bomber.height / 2);
            ctx.lineTo(0, -bomber.height / 2);
            ctx.lineTo(bomber.width / 2, bomber.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#1b2a35';
            ctx.fillRect(-20, -10, 40, 20);
            
            const glow = 0.5 + Math.sin(bomber.stealthPulse) * 0.4;
            ctx.strokeStyle = `rgba(173,216,230,${glow})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, bomber.width / 2, Math.PI, 0);
            ctx.stroke();
            ctx.restore();

            // Status text
            ctx.save();
            ctx.fillStyle = '#DAA520';
            ctx.font = '16px Fraunces';
            ctx.textAlign = 'center';
            if (bomber.graceTimer > 0) {
                ctx.fillText('Stealth bomber incoming...', bomber.x, bomber.y - 60);
            } else if (bomber.isReloading) {
                const secondsLeft = Math.ceil((bomber.reloadFrames - bomber.reloadTimer) / 60);
                ctx.fillText(`Reloading bomb bay: ${secondsLeft}s`, bomber.x, bomber.y - 60);
            } else if (!bomber.activeBomb) {
                ctx.fillText('Bomb bay ready!', bomber.x, bomber.y - 60);
            }
            ctx.restore();
        }

        function drawBomberBombs() {
            bomberBombs.forEach(bomb => {
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#888';
                ctx.beginPath();
                ctx.moveTo(-5, -15);
                ctx.lineTo(-5, 15);
                ctx.moveTo(5, -15);
                ctx.lineTo(5, 15);
                ctx.stroke();
                ctx.restore();
                
                if (!bomb.exploded) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,69,0,0.2)';
                    ctx.setLineDash([6, 10]);
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, bomb.explosionRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function drawAuroraWaves() {
            auroraWaves.forEach(wave => {
                ctx.save();
                ctx.strokeStyle = `rgba(126,255,212,${wave.alpha})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 12]);
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            ctx.setLineDash([]);
        }

        function drawProjectiles() {
            bossProjectiles.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                
                if (proj.type === 'bullet' || proj.isHunter) {
                    // Bullet
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, proj.size, proj.size / 2, Math.atan2(proj.vy, proj.vx), 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'aurora') {
                    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, proj.size);
                    gradient.addColorStop(0, proj.color || '#7FFFD4');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Pie slice projectile
                    ctx.fillStyle = '#FF7518';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, proj.size, 0, Math.PI / 3);
                    ctx.fill();
                    ctx.strokeStyle = '#DEB887';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            
            if (gameState === 'playing' || gameState === 'boss') {
                drawBarriers(); // Draw barriers behind other elements
                apples.forEach(drawApple);
                if (currentLevel === 4) {
                    drawBomberBombs();
                }
                drawProjectiles();
                if (boss && boss.type === BOSS_TYPES.AURORA) {
                    drawAuroraWaves();
                }
                drawPeckIndicator(); // Draw peck range indicator behind turkey
                drawTurkey();
                if (boss) drawBoss();
                if (hunter) drawHunter();
                if (currentLevel === 4 && bomber) {
                    drawBomber();
                }
                drawParticles();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        draw();
    </script>
</body>
</html>
